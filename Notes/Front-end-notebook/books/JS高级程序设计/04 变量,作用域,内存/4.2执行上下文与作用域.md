### 4.2 执行上下文与作用域

**变量对象**

变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的**变量对象(variable object)**,
而这个上下文中定义的所有**变量和函数**都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。

**上下文对象**

全局上下文是最外层的上下文。根据ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。浏览器中，全局上下文就是我们常说的window 对象,因此所有通过var 定义的全局变量和函数都会成为window 对象的属性和方法.

**上下文销毁**

上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

**函数上下文**

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。



**代码执行**

上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）



内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索



### 4.2.1 作用域链增强

虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：

* try/catch语句的catch块
* with语句

这两种情况下，都会在作用域链前端添加一个变量对象。对with 语句来说，会向作用域链前端添加指定的对象；对catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明.

```js
function buildUrl() {
  let qs = '?debug=true';
  
  with(location) {
    let url = href+qs;
  }
  return url;
}
```



### 4.2.2 变量声明

ES6 不仅增加了let 和const 两个关键字，而且还让这两个关键字压倒性地超越var成为首选.



#### **1.使用var的函数作用域声明**

在使用var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文

```js
function add(num1, num2) {
  var sum = num1 + num2;   //定义局部变量sum 
  return sum;
}

let result = add(10,20);
console.log(sum); //报错: sum在这里不是有效变量

//如果省略var,sum在add()被调用之后就变成可以访问的了.
funcction add(num1, num2) {
  sum = num1+num2;   //调用函数之后,sum被添加到全局上下文
  return sum;
}
let result = add(10,20); //30
console.log(sum);        //30
```

未经声明而初始化变量是JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。



**变量提升**

var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。

```js
var name = 'Jake';
//等价于
name = 'Jake';
var name;

function fn1() {
  var name = 'Jake';
}
//等价于
function fn1() {
  var name;
  name = 'Jake';
}
```

通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出undefined 而不是Reference Error：

```js
console.log(name); //undefined
var name = 'Jake';

function() {
  console.log(name); //undefined
  var name="Jake";
}
```



#### 2.使用let的块级作用域声明

ES6 新增的let 关键字跟var 很相似，但它的作用域是块级的，这也是JavaScript 中的新概念。块级作用域由最近的一对包含花括号{}界定,

if块, while块,function块,单独的块也是let声明变量的作用域.

```js
if(true) {
  let a;
}
console.log(a); //ReferenceError:a没有定义

while (true) {
let b;
}
console.log(b); // ReferenceError: b 没有定义


function foo() {
let c;
}
console.log(c); // ReferenceError: c 没有定义


// 这没什么可奇怪的
// var 声明也会导致报错
// 这不是对象字面量，而是一个独立的块
// JavaScript 解释器会根据其中内容识别出它来
{
let d;
}
console.log(d); // ReferenceError: d 没有定义
```



let 与var 的另一个不同之处是在同一作用域内不能声明两次。重复的var 声明会被忽略，而重复的let 声明会抛出SyntaxError。

```js
var a;
var a; //不会报错

{
  let b;
  let b; //SyntaxError: 标识符b已经声明过了
}
```



let 的行为非常适合在循环中声明迭代变量。使用var 声明的迭代变量会泄漏到循环外部，这种情况应该避免.

```js
for(var i=0;i<10;i++) {}
console.log(i); //10


for(let i=0;i<10;i++) {}
console.log(i); //ReferenceError: j没有定义
```

严格来讲，let 在JavaScript 运行时中也会被提升，但由于“**暂时性死区**”（temporal dead zone）的缘故，实际上不能在声明之前使用let 变量。因此，从写JavaScript 代码的角度说，let 的提升跟var是不一样的。



#### **2.1.var与let的区别**

* 块作用域
* 重复声明
* 挂载在window上
* 变量提升



#### 3.const常量声明

使用const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值.

与let相同,块级作用域.

const 声明只应用到**顶级原始数据类型或者对象**。换句话说，赋值为对象的const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。

```js
const a; //SyntaxError 常量声明时没有初始化

const b = 3;
console.log(b); // 3
b = 4; // TypeError: 给常量赋值

const o1 = {};
o1 = {}; //TypeError: 给常量赋值

const o2={};
o2.name = 'Jake';
console.log(o2.name); //'Jake'
```

如果想让整个对象都不能修改，可以使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：

```js
const o3 = Object.freeze({});
o3.name = 'Jake';
console.log(o3.name); //undefined
```

由于const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8 引擎就执行这种优化。



#### 4.生产实践

如果开发流程并不会因此而受很大影响，就应该尽可能地多使用const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。



#### 5.标识符查找

当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。

1.**搜索开始于作用域链前端**，以给定的名称搜索对应的标识符。

2.如果在**局部上下文**中找到该标识符，则搜索停止，变量确定；

3.如果没有找到变量名，则继续沿**作用域链**搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至**全局上下文**的变量对象。

4.如果仍然没有找到标识符，则说明其未声明。

