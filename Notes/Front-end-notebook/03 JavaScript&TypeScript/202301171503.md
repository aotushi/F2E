---
alias: 位运算符
---


#### 概述

> 在`JavaScript`内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。

> 位运算符将它的操作数视为32位的二进制串（0和1组成）而非十进制八进制或十六进制数。例如：十进制数字9用二进制表示为1001，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的JavaScript数值。

> 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与`0`进行二进制或运算，等同于对该数去除小数部分，即取整数位。([网道](https://wangdoc.com/javascript/operators/bit) )

javascript位运算符表格一览

| Operator                                                     | Usage     | Description                                                  |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------------ |
| 按位与 AND                                                   | a & b     | 在a,b的位表示中,每一个对应的位都为1则返回1,否则返回0         |
| 按位或 OR                                                    | a \| b    | 在a,b的位标识中,每一个对应的位,只要有一个为1则返回1,否则返回0 |
| 按位异或 XOR                                                 | a ^ b     | 在a,b的位表示中，每一个对应的位，两个不相同则返回1，相同则返回0. |
| 按位非[ NOT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT) | `~ a`     | 反转被操作数的位。                                           |
| 左移[ shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Left_shift) | `a << b`  | 将a的二进制串向左移动b位,右边移入0.                          |
| 算术右移                                                     | `a >> b`  | 把a的二进制表示向右移动b位，丢弃被移出的所有位.(译注:算术右移左边空出的位是根据最高位是0和1来进行填充的) |
| 无符号右移(左边空出位用0填充)                                | `a >>> b` | 把a的二进制表示向右移动b位，丢弃被移出的所有位，并把左边空出的位都填充为0 |
|                                                              |           |                                                              |

位运算 NOT 是三步的处理过程：

- 操作数被转换为32bit整數，以位序列（0和1组成）表示.若超過32bits，則取低位32bit，如下所示：

  ```javascript
  Before: 11100110111110100000000000000110000000000001
  After:              10100000000000000110000000000001
  ```

- 第一个操作数的每一位都与第二个操作数的对应位组对: 第一位对应第一位,第二位对应第二位,以此类推.

- 运算符被应用到每一对"位"上, 最终的运算结果由每一对“位”的运算结果组合起来.

例如,十进制数9的二进制表示是1001,十进制数15的二进制表示是1111.因此,当位运算符应用到这两个值时,结果如下:

简单的理解，对任一数值 x 进行按位非操作的结果为 **-(x + 1)**

| 表达式  | 结果 | 二进制描述                       |
| ------- | ---- | -------------------------------- |
| 15 & 9  | 9    | 1111 & 1001                      |
| 15 \| 9 | 15   | 1111 & 1001                      |
| 15 ^ 9  | 6    | 1111 ^ 1001   => 0110            |
| ~ 15    | -16  | ~00000...1111 ===> 1111.....0000 |
|         |      |                                  |

#### 0. 计算机中如何表示数字

数字以一系列高低电信号的形式保存在计算机硬件中,因此他们被认为是基数为2的数(基数为2的数称为二进制数).

由于在计算机中所有信息的都是由二进制位(binary digit)或位(bit)表示,因此二进制数计算的'原子'单位是单个数位.有两种取值:高或低,开或关,真或假,1或0.

在64位<u>双字(doubleword/DW)</u>中,从右向左依次将位编号位0,1,2,3...,RISC-V中的双字为64位宽,因此可以表示2的64次方种不同的组合模式.这些组合自然可以表示从0到2的64次方减1(18 446 774 073 709 551 615)之间的数.
$$
00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000000_2=0_{10}\\

00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000001_2=1_{10}\\
00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000000\quad00000010_2=2_{10}\\
...\\
11111111\quad11111111\quad 11111111\quad 11111111\quad 11111111 \quad11111111\quad 11111111 \quad11111101_2 = 18\;446\;744\;073\;709\;551\;613_{10}\\

11111111\quad11111111\quad 11111111\quad 11111111\quad 11111111 \quad11111111\quad 11111111 \quad11111110_2 = 18\;446\;744\;073\;709\;551\;614_{10}\\

11111111\quad11111111\quad 11111111\quad 11111111\quad 11111111 \quad11111111\quad 11111111 \quad11111111_2 = 18\;446\;744\;073\;709\;551\;615_{10}\\
$$
位(bit),音译'比特',表示二进制位.位是计算机内部数据存储的最小单位,一个二进制位只可以表示0或1两种状态中的一种,两个二进制位有4种状态,三个二进制位可表示8种状态.

字节(Byte),字节是通过网络传输信息(或硬盘,内存存储存储信息),计算机种数据处理的基本单位.规定一个字节由8个二进制位构成,即1个字节等于8个比特.(1Byte = 8bit).通常1个字节可以存入一个ASCII码,2个字节可以存放一个汉字国标码. 一个ascii码就是一个字节,因为ascii码的二进制范围是00000000到11111111,十进制范围是0到255.

字(word),是计算机进行数据处理时,一次存取,加工和传送的数据长度称为字.

* 1个字等于两个字节等于16位

* 一个字通常由1个或多个字节构成.计算机的字长决定了其cpu一次操作处理实际位数的多少.计算机的字长越长,性能越好.

双字(D)

* 1个双字等于2个字等于32位
* 1个双字是4个字节



**原码表示**

计算机程序可以计算正数和负数,因此需要一种表示方法了区分正数和负数.最显然的一个方法是增加一个符号位来表示,这种表示方法称为**原码表示**(sing and magnitude).因为存在符号位位置不明确及需要额外的步骤来设置符号,导致被放弃.

**补码**(two's complement)

简化硬件表示法:前导0表示正数,前导1表示负数.
$$
00000000\quad00000000\quad 00000000\quad 00000000\quad 00000000 \quad00000000\quad 00000000 \quad00000000_2 = 0_{10}\\

00000000\quad00000000\quad 00000000\quad 00000000\quad 00000000 \quad00000000\quad 00000000 \quad00000001_2 = 1_{10}\\

00000000\quad00000000\quad 00000000\quad 00000000\quad 00000000 \quad00000000\quad 00000000 \quad00000010_2 = 2_{10}\\

...\\

01111111\;11111111\;11111111\;11111111\;11111111\;11111111\;11111111 \;11111101_2 = 9\;223\;372\;036\;854\;775\;805_{10}\\

01111111\;11111111\;11111111\;11111111\;11111111\;11111111\;11111111 \;11111110_2 = 9\;223\;372\;036\;854\;775\;806_{10}\\

01111111\;11111111\;11111111\;11111111\;11111111\;11111111\;11111111 \;11111111_2 = 9\;223\;372\;036\;854\;775\;807_{10}\\
...\\
10000000\;00000000\;00000000\;00000000\;00000000\;00000000\;00000000\;00000000_2 = -9\;223\;372\;036\;854\;775\;808_{10}\\

10000000\;00000000\;00000000\;00000000\;00000000\;00000000\;00000000\;00000001_2 = -9\;223\;372\;036\;854\;775\;807_{10}\\

10000000\;00000000\;00000000\;00000000\;00000000\;00000000\;00000000\;00000010_2 = -9\;223\;372\;036\;854\;775\;806_{10}\\

...\\

11111111\;11111111\;11111111\;11111111\;11111111\;11111111\;11111111 \;11111101_2 = -3_{10}\\

11111111\;11111111\;11111111\;11111111\;11111111\;11111111\;11111111 \;11111110_2 = -2_{10}\\

11111111\;11111111\;11111111\;11111111\;11111111\;11111111\;11111111 \;11111111_2 = -1_{10}\\
$$
从0到`9 223 372 036 854 775 807`(2<sup>63</sup> - 1)的正数与之前的表示相同.位模式1000...000<sub>2</sub>表示最小负数-9 223 372 036 854 775 808<sub>10</sub>(-2<sup>63</sup>). 而后是一组递增的负数: 从-9 223 372 036 854 775 807<sub>10</sub>(1000...000<sub>2</sub>)到-1(111...111<sub>2</sub>).

二进制补码有一个负数没有相应的正数: -9 223 372 036 854 775 808<sub>10</sub>.

二进制补码的优点:  所有负数的最高有效位都为1.因此硬件只需要检测这一位就可以查看是正数还是负数(数字0被认为是正数).这个为通常称为**符号位(sign bit)**. 通过符号位,可以用每位数值乘以2的幂之和来表示正负数的64位数:

符号位乘以-2<sup>63</sup>,然后其余位分别乘以他们各自基值的正值.
$$
(x_{63} × -2^{63}) + (x_{62} * 2^{62}) + (x_{61} * 2^{61}) + ... + (x_1 * 2^1) + (x_0 * 2^0)
$$


例题: 二进制转换为十进制

下面这个64位二进制补码的十进制是多少?

11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111100<sub>2</sub>

答案:

(1\*-2<sup>63</sup>) + (1\*2<sup>62</sup>) + (1\*2<sup>61</sup>) + ... + (1\*2<sup>2</sup>) + (0\*2<sup>1</sup>) + (0*2<sup>0</sup>)

= -2<sup>63</sup> + 2<sup>62</sup> + 2<sup>61</sup> + ... + 2<sup>2</sup> + 0 + 0

= -9 223 372 036 854 775 808<sub>10</sub> + 9 223 372 036 854 775 804<sub>10</sub>

= -4<sub>10</sub>



二进制补码的两种快捷方式

<u>对二进制补码求相反数的快速方法</u>

把每个0都转为1以及每个1都转为0,然后对结果加1. 这个捷径基于以下观察: 一个数与其取反表达式的和一定是111...111<sub>2</sub>,它表示负1. 由于x+<span style="text-decoration: overline">x</span> = -1.,因此x+<span style="text-decoration: overline">x</span>+1 = 0或x+1 = -<span style="text-decoration: overline">x</span>.(用符号来表示<span style="text-decoration: overline">x</span>按位取反)



<u>将一个用n位表示的二进制数转换位一个用多于n位表示的数</u>

先取位数更少的数的最高位(符号位),并将其复制来填充位数更多的数的新位.原来的非符号位被复制到新双字的右侧部分.这个方式通常被称为符号扩展(sign extension)

实例,将16位二进制数2<sub>10</sub>和-2<sub>10</sub>转换成64位二进制数

数字2的16位二进制数
00000000 00000010<sub>2</sub> = 2<sub>10</sub>

通过把最高有效位(0)复制48份放到双字的左侧,将其转换位64位数.把原来的值放到右侧:

00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000010<sub>2</sub> = 2<sub>10</sub>

使用前面的快捷方式对16位二进制数2求反,因此:

11111111 11111101<sub>2</sub> + 1<sub>2</sub> = 11111111 11111110<sub>2</sub>

将负数转换成64位意味着要将符号位复制48次并放到左侧:

11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111110<sub>2</sub> = -2<sub>10</sub>

该方式之所以有效是因为在正数二进制补码的左侧实际上是无限个0,而负数的二进制补码在左边是无限个1. 二进制位模式隐藏了前面的位以适应硬件的宽度,符号扩展只是恢复了一些.



**计算机中为什么需要补码和反码**

> https://demonlee.tech/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%BF%90%E7%AE%97%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81



二进制位运算符

> 二进制运算符将他们的操作数作为32个二进制位(0或1)的集合,并蒋方舟标准的JS数值.

#### 二进制位与(AND) `&`

> 按位与运算符(&)在两个操作数对应的二进制位都为1时,该位的结果值才为1, 否则为0

##### 语法

```javascript
a & b
```

##### 描述

操作数被转换为32位整数，并由一系列位（0和1）表示。 超过32位的数字将丢弃其最高有效位。 例如，以下大于32位的整数将被转换为32位整数：

```javascript
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001
```

第一个操作数中的每个位都与第二个操作数中的相应位配对：第一位到第一位，第二位到第二位，依此类推。

将运算符应用于每对位，然后按位构造结果。

```javascript
.    9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 & 9 (base 10) = 00000000000000000000000000001000 (base 2) = 8 (base 10)
```

将任何数字`x`与`0`进行按位与运算将得出`0`。

##### 实例

<u>如何判断一个数字是不是2的n次方幂</u>

方案1: 按位与操作符

通过二进制的方法来判断.规律: 只要num是2的次方幂,最高位必然是1,其余为0.num-1则最高位必然是0, 其余位为1.

```javascript
8的二进制 1000 8-1 的二进制 0111    按位与运算      1000&0111 => 0000   所以8是2的n次方幂
9的二进制 1001 9-1 的二进制 1000    按位与运算      1001&1000 => 1000   所以9不是2的次方幂。
24的二进制 11000  24-1的二进制 10111 按位与运算     11000&10111 => 10000  所以24不是2的次方幂。
```

通过num.toString(2)来获取num的二进制

```javascript
//代码实现

function check(num) {
  return (num > 0 ) &&((num & (num-1)) === 0)
}

function check(num) {
  return /^10$/.test(num.toString(2))
}

function check(num) {
  return Number.isInteger(Math.log2(num))
}
```







#### 按位非运算符

按位非(~)运算符,反转操作数的位.

注意位运算符“非”将所有的32位取反，而值的最高位(最左边的一位)为1则表示负数(2-补码表示法)。

对非数值变量取反,得到的一定是负1,因为实际上等于对0取反.

```javascript
二进制相反数是该二进制每位反转,然后+1;
15的反码是~15, 那么~15 + 1 = -15,所以 ~15 = -15 - 1;

~x 相当于 -(x+1)
~~x 相当于-(-(x+1) + 1) x+1-1
```

对一个非数值变量取反操作,得到的一定是-1,因为实际上等于对0做取反操作

```javascript
~null //-1
~NaN //-1
~'xx' //-1
~{} //-1
~function func() {} //-1
```



`~1`的步骤:

* 将十进制数字1转换为32位的二进制: `0000 0000 ... 0000 0001`    
* 按位取反 `1111 1111 ... 1111 1110`.这个就是结果,但我们需要将它再取反,获得容易计算的二进制数.
* 最高位数字1表示负数,0表示正数. 将除了符号位之外的其他数字取反. `1000 0000 ... 0000 0001`
* 末位加1取其补码(**二进制负数等于反码+1**)  `1000 000 ... 000 0010`
* 转换为十进制 `-2`



> 来源: https://www.cnblogs.com/moqiutao/p/6275483.html
>
> * 按位取反的运算规则是所有的计算机语言都是这样的。这样做的主要原因是为了为了统一减法和加法，在计算机中，减法会变成加一个负数，而负数会以补码的形式存储。而这样主要是因为补码和数字的十进制数有这么转换关系，负数：**`补码(x) = -x - 1`**，正数：**`补码(x) = x`**
> * 因为补码是针对负数存在的，那么只要数据类型有**`无符号数`**，就没有这样的烦恼了，比如C语言有无符号整型，就能对无符号整型直接按位取反。
> * 如果没有无符号类型，而且也只是想要按位取反，而不是附带补码的按位取反，需要另外的方法。让全1的数据和当前数据做按位抑或就行了。比如，你有一个32位的数据a，需要对它做按位取反，那么这样就行了：**`0xFFFF ^ a`**
>
> https://juejin.cn/post/6844903717611782157
>
> * 二进制的负数就是取该二进制数的补码,然后+1  (补码就是按位取反后的数)
> * 二进制数, 最高位为0表示正数,最高位为1表示负数.
> * `~`按位非操作其实就是取补码的过程,也就是上述求该值负数的逆过程,所以可以简单的理解为该值取负值后减1。
>
> 



**应用**

**1. indexOf()**

```javascript
//判断数组或字符串是否存在某个元素
if (str.indexOf(query) !== -1) {}
if (str.indexOf(query) >= 0) {}

if (~str.indexOf(query))
不存在返回-1,~-1 = 0 ,大于-1的值,0,1,2,3 ... 按位非的值1,2,3,4...都大于0
```



**2. ~~value**

对于浮点数,~~value可以代替parseInt(value),而且前者效率更高些

```javascript
parseInt(-2.99); //-2
~~(-2.99); //-2
```



```javascript
console.log('~null: ', ~null);       // => -1
console.log('~undefined: ', ~undefined);  // => -1
console.log('~0: ', ~0);          // => -1
console.log('~{}: ', ~{});         // => -1
console.log('~[]: ', ~[]);         // => -1
console.log('~(1/0): ', ~(1/0));      // => -1
console.log('~false: ', ~false);      // => -1
console.log('~true: ', ~true);       // => -2
console.log('~1.2543: ', ~1.2543);     // => -2
console.log('~4.9: ', ~4.9);       // => -5
console.log('~(-2.999): ', ~(-2.999));   // => 1



console.log('~~null: ', ~~null);       // => 0
console.log('~~undefined: ', ~~undefined);  // => 0
console.log('~~0: ', ~~0);          // => 0
console.log('~~{}: ', ~~{});         // => 0
console.log('~~[]: ', ~~[]);         // => 0
console.log('~~(1/0): ', ~~(1/0));      // => 0
console.log('~~false: ', ~~false);      // => 0
console.log('~~true: ', ~~true);       // => 1
console.log('~~1.2543: ', ~~1.2543);     // => 1
console.log('~~4.9: ', ~~4.9);       // => 4
console.log('~~(-2.999): ', ~~(-2.999));   // => -2
```



#### 2.位移运算符

在二进制基础上对数字进行移动操作



##### 2.1 `<<` 按位左移运算符

> Bitwise left shift operator

**what**
> 将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。

**语法**
```js
a << b
```

**描述**
例如， 9 << 2 得出 36：
```js
9 (十进制): 00000000000000000000000000001001 (二进制)


9 << 2 (十进制): 00000000000000000000000000100100 (二进制) = 36 (十进制)
```

移动任意数字 x 至左边 y 位，得出 x * 2 ** y。 
所以例如：9 << 3 等价于 9 * 2³ = 9 * 8 = 72。





##### 2.2 `>>` 按位右移运算符
> Bitwise right shift opearotr

**what**
是将一个操作数按指定移动的位数向右移动，右边移出位被丢弃，左边移出的空位补符号位（最左边那位）

**语法**
```js
a >> b
```

**描述**
这个操作符向右移动第一个操作数(operand)指定位数. 向右移动(shifted off to right)的多余位将被丢弃. 最左边位的副本从左边移入. 由于最左边新位与之前最左边位有相同的值, 符号位(最左边位)不会变. 所以又被称作'sign-propagating'(符号传播).

考虑十进制(decimal)数字9 和 -9 的32位二进制表示
```js
     9 (base 10): 00000000000000000000000000001001 (base 2)
    -9 (base 10): 11111111111111111111111111110111 (base 2)
```
注意,负10进制数字-9的二进制表示是正十进制数字9的二进制表示的补码.也就是说(That is),它通过将`000000000000000000000000001001`的所有位取反并加1来计算的。
在这两种情况下, 二进制数的符号都是由最左边位给出: 对于正十进制数9,二进制表示的最左边位是0, 对于负十进制数-9, 二进制表示的最左边位是1

给予10进制数字9和-9的二进制表示:
`9>>2` 产生2:
```js
     9 (base 10): 00000000000000000000000000001001 (base 2)
                  --------------------------------
9 >> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)
```
注意,两个最右边位, `01`, 已经移出, 并且最左边位的两个副本, `0` 已经从左边移入(shift in)

`-9 >> 2`,产生 `-3`
```js
     -9 (base 10): 11111111111111111111111111110111 (base 2)
                   --------------------------------
-9 >> 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)
```

注意两个最右边位,`11`,是如何移出的. 但就最左边位而言, 在这种情况下, 最左边位是`1`. 所以最左边`1`位的两个副本已经从左边移入 - 这保留了负号.

左操作数将被转换成32位整数,这意味着浮点数字将被删除, 不在 32 位边界内的数字将溢出/下溢。
右操作数将被转换成无符号32位整数,然后取模32(then take modulo 32), 因此，实际偏移量将始终是介于 0 和 31 之间的正整数（包括 0 和 31）。例如, `100>>32`和`100>>0`一样(结果是100), 因为32取模32是0.  ???






##### 2.3 `>>>` 按位无符号右移运算符

**Define**

> Bitwise unsigned right shift oprator
>
> the unsigned right shift operator(>>>) (zero-fill right shift) shifts the first operand the specified number of bits to the right. Excess bits shifted off to the right are discarded. Zero bits are shifted in from the left. The sign bit becomes 0, so the result is always non-negative. Unlike the other bitwise operators, zero-fill right shift returns an unsigned 32-bit integer.

无符号右移操作符（>>>）（零填充右移）将第一个操作数向右移动指定的位数。向右移出的多余的位被丢弃,再从从左边移入0。符号位变为0，所以结果总是非负的。与其他位操作符不同，零填充右移返回一个无符号的32位整数。

**Desc**

> this operator shifts first operand the specified number of bits to the right.
>
> 这个操作符向右移动第一个操作数具体位数
>
> Excess bits <u>shifted off(移出)</u> to the right are discarded.
>
> 向右移出多余的比特(位)被丢弃
>
> Zero bits are <u>shifted in(移入)</u> from the left.
>
> 0位从左边被移入
>
> The sign bit becomes `0`, so the result always non-negative.
>
> 符号位成为0, 所以结果总是非负的.
>
> Unlike the other bitwise operators, zero-fill right shift returns an unsigned 32-bit integer.
>
> 和其他位操作符不同, `0填充右移`返回一个 无符号 的32位整数





对非负整数,零填充右移符号和符号传播右移得到一样的结果.例如

```javascript
9(base 10): 00000000000000000000000000001001 (base 2)
9>>>2(base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)
```

对负数来说,两者结果不同

```javascript 
-9    (base 10):   11111111111111111111111111110111 (base 2)
-9>>>2(base 10):   00111111111111111111111111111101 (base 2)

//如何快速得出右移后的十进制数
1.取反加1 11....11
2.计算 1*(-2的31次方) + 1*(2的30次方) + ... + 1*(2的1次方) + 1*(2的0次方) = 1073741821 = 9>>>2

-1>>>0 这里JS会把符号位替换成0,所以结果并不是-1,而是-2的32次方+1

```

**注意**

* 取整,但不可对负数取整.

* JS做位运算时,小数部分会忽略

* 非数值运算会变成0

```javascript
1.01 >>> 2
1.01(10)        00000000000000000000000000000001 //? 这里写错了,应该是仍然存在小数位吧,但在应用右移操作符时应该会被忽略
1.01(10) >>> 2  00000000000000000000000000000000 //转换成十进制为0

-2 >>> 0
2        00000000000000000000000000000010
-2       11111111111111111111111111111110  //进制转负数需要取反且加1
-2 >>> 0 11111111111111111111111111111110  //结果是将二进制转换成10进制  




1>>>0  //1
1.5>>>0 //1
-1>>>0 //4294967295
null>>>0 //0
undefined>>>0 //0
'sldkfj'>>>0 //0
```



**Other**

1.1 JS中为什么浮点数也能参与位运算,在java,go,c中是不允许的?

在JS中Number类型不区分整型,浮点型的.为了不丢失精度,JS中的Number类型实际上是一个基于IEEE754标准的双精度64位浮点数.

JS需要位运算时,会将操作数转成32位比特序列,也就是补码.再按照64位浮点数存储.

1.2 JS中非数值类型如何进行位运算?

* 对于非数值类型,会首先将操作数转成一个整型(就是0),然后再进行计算.实际上这是一个伪命题,实质上是对非数值操作数的整型表达式进行的位运算.
* JS中的整型在内存中是一个64位双精度浮点型,但JS在进行位运算时,会将操作数转成带符号位的32位比特序列,也就是补码(????).运算结束后,再按照64位存储.这里肯定会存在精度丢失的问题,JS如何处理呢?超过32位的部分直接截断.



