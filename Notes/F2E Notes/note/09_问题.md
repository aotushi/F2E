## 面试题收集

> https://gitee.com/zxfjd3g/wh221017_vue2-study
> https://gitee.com/zxfjd3g
>
> [Trivia questions in front end interviews | Front End Interview Handbook](https://www.frontendinterviewhandbook.com/zh/trivia/)
>
> https://github.com/h5bp/Front-end-Developer-Interview-Questions
> 
> https://github.com/yangshun/front-end-interview-handbook
> 
> https://github.com/paddingme/Front-end-Web-Development-Interview-Question
> 
> https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions
> 
> https://www.frontendinterviewhandbook.com/zh/trivia/
> 
  https://juejin.cn/post/6844903918753808398#heading-11
> 
> https://github.com/Easay/issuesSets
> 
> [web前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/)




## HTML

### 标签语义化

什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。

#### 好处
- 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
- 方便其他设备解析，如盲人阅读器根据语义渲染网页
- 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。


#### 语义化标签
* 新的语义化元素：article 、footer 、header 、nav 、section,progress,detail&summary
* 新的 API：音频(用于媒介回放的 video 和 audio 元素)、图形（绘图 canvas 元素）



### doctype作用
doctype是文档类型声明，目的是告诉解析器要使用什么样的文档类型定义（DTD）来解析文档。
浏览器本身分为两种模式，<u>一种是标准模式，一种是怪异模式</u>，浏览器通过doctype来区分这两种模式. doctype来声明标准模式，如果不存在就怪异模式，有些样式会和标准模式存在差异.



### 行内元素和块级元素

#### 区别
区别: 一是排列方式，二是宽高边距设置，三是默认宽度。
块级元素会独占一行，而内联元素和内联块元素则会在一行内显示；
块级元素和内联块元素可设置width/height/边距/填充属性，而内联元素无法设置width/height/垂直方向边距(填充)
块级元素的 width 默认为100%，而内联元素则是根据其自身的内容或子元素来决定其宽度；

而行内块级元素又同时拥有块级元素和行内元素的特点。
|                              | `block`                                                     | `inline-block`                             | `inline`                                                     |
| ---------------------------- | ----------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 定位                         | 从新的一行开始，并且不允许旁边有 HTML 元素（除非是`float`） | 与其他内容一起流动，并允许旁边有其他元素。 | 与其他内容一起流动，并允许旁边有其他元素。                   |
| 能否设置`width`和`height`    | 能                                                          | 能                                         | 不能,设置会被忽略                                            |
| 可以使用`vertical-align`对齐 | 不可以                                                      | 可以                                       | 可以                                                         |
| 边距(margin)和填充(padding)  | 各个方向都存在                                              | 各个方向都存在                             | 只有水平方向存在。垂直方向会被忽略。 尽管`border`和`padding`在`content`周围，但垂直方向上的空间取决于'line-height' |
| 浮动（float）                | -                                                           | -                                          | 就像一个`block`元素，可以设置垂直边距和填充                  |





#### 来源
> [CSS中 块级元素、行内元素、行内块元素区别](https://juejin.cn/post/6998925491797229599)
> https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements

#### 行内元素
**是什么**
行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的高度一般由元素内部的字体大小决定，宽度由内容的长度控制。 

**特点**
* 不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化；
* 高/宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效  上下无效；
* 设置行高有效，等同于给父级元素设置行高；
* 元素的宽度就是它包含的文字或图片的宽度，不可改变；
* 行内元素中不能放块级元素，a链接里面不能再放链接；

**有哪些**
> https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements#list_of_inline_elements

```md
a abbr acronym audio 
b bdi bdo big br button 
canvas cite code 
data datalist del dfn 
em embed
i iframe img input ins 
kbd label 
map mark meter 
noscript 
object output
picture progress
1 
ruby 
s samp script select slotsmall sapn strong sub sup svg 
template textarea time
u tt 
var video 
wbr
```



#### 块级元素
**是什么**
占据一整行，可自定义宽度/高度等. 可容纳块级元素和行内元素.
**特点**
* 每个块元素独占一行
* 高度，行高，外边距（margin）以及内边距（padding）都可以控制；
* 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%；
* 多个块状元素标签写在一起，默认排列方式为从上至下
**块元素介绍**
```sh
标题类: h1-h6
结构类: header article aside footer p div
表格类: table thead tbody tr th td tfoot
列表类: dl dt dd / li ol ul
表单类: form
语义类: adress caption(标题) figure,canvas,video,audio
```

**使用js判断元素是否是块级元素**
>https://segmentfault.com/q/1010000003994838

```js
//chatgpt生成: 1.获取元素的display属性; 2.判断元素tagName

window.getComputedStyle(ele).display === 'block'

document.getElementById('myEle').tagName
```


#### 行内块元素
**是什么**
行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如：input、img就是行内块级元素，它可设置高宽以及一行多个

**特点**
* 高度、行高、外边距以及内边距都可以控制；
* 默认宽度就是它本身内容的宽度，不独占一行，但是之间会有空白缝隙，设置它上一级的 font-size 为 0，才会消除间隙；

**元素介绍**
```sh
button input textarea select img
```

#### 元素之间的转换
* display：block ，定义元素为块级元素
* display : inline ，定义元素为行内元素
* display：inline-block，定义元素为行内块级元素



### link标签和script标签位置
为什么最好把CSS的`<link>`标签放在`<head></head>`之间？
为什么最好把 JS 的`<script>`标签恰好放在`</body>`之前，有例外情况吗？

把`<link>`放在`<head>`中
将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。

把`<script>`标签恰好放在`</body>`之前
脚本在下载和执行期间会阻止 HTML 解析。把`<script>`标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。

例外情况是当你的脚本里包含`document.write()`时。但是现在，`document.write()`不推荐使用。同时，将`<script>`标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，`<script>`使用`defer`属性，放在`<head>`中。



### defer 与 async区别
html文件都是按顺序执行的，script标签中没有加defer和async时，浏览器在解析文档时遇到script标签(下载和执行)就会阻塞文档解析，先加载JS文件，加载完之后立即执行，执行完毕后才能继续解析文档。 

而在script标签中写入defer或者async时，就会使JS文件异步加载，即html执行到script标签时，JS加载和文档解析同时进行.
* async是在JS加载完成后, 立即执行JS脚本，阻塞文档解析
* defer则是JS加载完成后，在文档解析完成后,再执行JS脚本


### 渐进式渲染
渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。
使用场景: 带宽小的时代/不稳定的移动互联网场景
案例:
* 图片懒加载
* 分层次渲染: 页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。
* 异步加载 HTML 片段. 当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器


### img标签中使用srcset属性.
因为需要设计响应式图片。我们可以使用两个新的属性: srcset 和 sizes——来提供更多额外的资源图像和提示，帮助浏览器选择正确的一个资源.
* srcset 提供多图像资源
* sizes  用媒体查询方法来指定图像宽度
浏览器处理过程:
* 查看设备宽度
* 检查 sizes 列表中哪个媒体条件是第一个为真
* 查看给予该媒体查询的槽大小
* 加载 srcset 列表中引用的最接近所选的槽大小的图像


```html
<img 
    src="/static/flamingo-fallback.jpg"
    srcset="
    /static/flamingo4x.png 4x,
    /static/flamingo3x.png 3x,
    /static/flamingo2x.png 2x,
    /static/flamingo1x.png 1x " >


<img 
  src="https://cloud4.gogoing.site/files/2020-08-21/bbc63bf5-6f56-4d0a-a996-72fff804725c.png"
  sizes="(max-width: 376px) 375px, (max-width: 769px) 768px, 1024px"
  srcset="
    https://cloud3.gogoing.site/files/2020-08-21/bbc63bf5-6f56-4d0a-a996-72fff804725c.png 375w,
    https://cloud2.gogoing.site/files/2020-08-21/69d2679d-eefe-434a-8755-7f8b09166bf3.png 768w,
    https://cloud1.gogoing.site/files/2020-08-21/291087d7-beda-402f-9c28-b23e71beb32e.png 1024w"
>

```



### href 与 src 区别
> https://zhuanlan.zhihu.com/p/91960069

| -                         | 是什么                                | 用在哪里          | 作用                                      | 浏览器解析方式                                                                                                                | 其它 |     |
| ------------------------- | ------------------------------------- | ----------------- | ----------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- | ---- | --- |
| href(hypertext Reference) | 表示超文本引用,指向网络资源所在位置   | link/a            | href 用于在当前文档和引用资源之间确立联系 | 当浏览器遇到href会并行下载资源并且不会停止对当前文档的处理(同时也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式) | 0    |     |
| src(source)               | 表示引用资源,目的是把文件下载到页面上 | img/script/iframe | src 用于替换当前内容                                          | 当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载或执行完毕(这也是script标签为什么放在底部而不是头部的原因)    | 0    |     |




## CSS
> https://segmentfault.com/a/1190000013325778


### 页面中引入CSS文有几种方式
向页面中添加样式表的时候，层叠机制的原理是次序决定优先级。

如果为某个元素应用样式时，有两个或更多特殊性相等的规则相互竞争，则后声明的样式胜出。

* 行内样式
* 内部样式表
* 链接 `<link type="text/css" rel="stylesheet" href="style.css">`
* 导入 `@import url(style.css)`

```css
//行内
<div style="color: green; margin-top: 30px;border: 1px solid red;width: 500px">行内样式实例1</div>

//内部样式表
<style> 
p { color: #6478de; border: red 1px solid; } 
</style>

//链入外部样式
<style> p { color: #6478de; border: red 1px solid; } </style>

//导入外部样式
<style> @import "qt_02_style.css"; </style>
```

### link 与 @import 的区别
就结论而言，强烈建议使用`link`标签，慎用`@import`方式。

> https://segmentfault.com/a/1190000015950516

**区别**
* 从属关系: `@import`是 CSS 提供的语法规则，只有导入样式表的作用；`link`是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。
* 加载顺序: 加载页面时，`link`标签引入的 CSS 被同时加载；`@import`引入的 CSS 将在页面加载完毕后被加载。
* 兼容性: `@import`是CSS2.1才有的语法，故只可在 IE5+ 才能识别；`link`标签不存在兼容性问题。
* DOM可控性: `@import`不能被DOM控制




### 盒模型

#### 是什么?
>[The box model - Learn web development | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model)

盒模型作为一个整体应用到块级盒子并定义盒子的的不同部分(margin,border,padding,context),如何一起创建一个页面上的盒子.

指网页布局中，每个 HTML 元素都可以看作是一个矩形盒子（box），包括元素的内容区域、内边距（padding）、边框（border）和外边距（margin）四个部分。

可通过`box-sizing`进行设置。根据计算宽高的区域可分为：

- `content-box` (W3C 标准盒模型) 默认使用
- `border-box` (IE 盒模型)
- `padding-box`
- `margin-box` (浏览器未实现)

#### 作用
通过设置元素的盒模型属性(box-sizing 属性)，可以控制元素的大小、位置和边距，以及元素之间的距离和排列方式。盒模型也是响应式设计和网页布局的基础。

#### 分类
* 标准盒模型
* 替代(IE)盒模型

#### 差异
主要差异在于计算元素宽度和高度时所包含的内容不同。
标准盒模型:元素的宽度和高度只包括内容区域，不包括内边距、边框和外边距。
IE盒模型: 元素的宽度和高度包括了内容区域、内边距和边框，不包括外边距

默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。


#### 切换
默认浏览器会使用标准模型。
替代模型  box-sizing: border-box
标准模型  box-sizing: content-box

#### 实例
所有元素都使用替代模式
设置 box-sizing 在 `<html>` 元素上，然后设置所有元素继承该属性.
```css
html {
  box-sizing: border-box;
}

*, *::before, *::after {
  box-sizing: inherit;
}
```



### px、rem和em的区别
> https://github.com/Easay/issuesSets/issues/19

* px（像素）：相对长度单位，像素px是相对于显示器屏幕分辨率而言的。

* em：相对长度单位。相对于父元素的字体大小。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。
任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 `16px*62.5%=10px`, 这样`12px=1.2em, 10px=1em`, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。
```css
body {
  font-size: 62.5%; /* 设置为 10px */
}

h1 {
  font-size: 2.4em; /* 相当于 24px */
}

p {
  font-size: 1.6em; /* 相当于 16px */
}
```

* rem：是CSS3新增的一个相对单位。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。

#### vw vh vmin vmax
1vh等于1%的视口高度。例如，浏览器高度是900px，那么`1vh = 900*1%=9px`，同理，若视口宽度是750px,则1vw是7.5px。

vh和vw是相对于视口的宽度和高度，而vmin和vmax则关于视口高度和宽度两者的最小或者最大值。例如，如果浏览器的高宽分别为700px和1100px，则1vmin=7px，1vmax=11px；如果高宽分别是1080px和800px,则1vmin=8px,1vmax=10.8px。

#### 使用场景
假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。例如，可以这样定义一个至少有两个边触摸到屏幕的方形：
```css
.box {
    height: 100vmin;
    width: 100vmin;
}
```
如果需要让这个方框始终铺满整个视口的可见区域：
```css
.box {
    height: 100vmax;
    width: 100vmax;
}
```



### 伪类和伪元素
伪类选择符语法是以一个冒号开头，用于选择元素的特定状态或关系。

常见的用于超链接的伪类列举如下。(后面的样式会覆盖前面的，如果顺序颠倒会引起一些行为样式无法生效。)
```css
a:link{
}
a:visited{
}
a:hover,
a:focus{
}
/* 左键点击 */
a:active{
}
```

**CSS3新增的结构化伪类**
* `p:only-child`            选择所有父元素中仅有一个子元素p的这个元素
* `p:last-child`            选择兄弟元素中的最后一个元素(此处为p,就是匹配父元素中最后元素为p的p元素)
* `p:nth-child(An+B)`        选择父元素中的符合位置的子元素(此处为p)
* `p:nth-last-child(2)`      选择父元素倒数的第二个子元素

* `p:first-of-type`         选择每个p元素是其父元素的第一个p元素
* `p:last-of-type`          选择每个p元素是其父元素的最后一个p元素
* `p:nth-of-type(2)`         选择所有p元素第二个为p的子元素
* `p:nth-last-of-type(2)`    选择所有p元素倒数的第二个为p的子元素
* `p:only-of-type`          选择所有仅有一个子元素为p的元素

* 


**表单伪类**
:required：选择带有required属性的表单元素
:optional：为没有required属性的控件添加样式
HTML5为type属性新增了输入值，如email
```css
input[type="email"]:valid{
}
```


#### 伪元素
`::first-letter`：选择第一段文本的第一个字符
`::first-line`：选择第一段文本的第一行
`::before`：内容开头
`::after`：内容结尾


#### 盒模型内部/外部显示类型
> 了解
>https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#补充：内部和外部显示类型

外部显示类型: 外部显示类型来决定盒子是块级还是内联
内部显示类型: 决定了盒子内部元素是如何布局的, 默认情况下是按照**正常文档流**布局. 可以通过display:flex等方式改变内部显示类型.

### 浮动
#### 浮动问题
由于浮动元素不在文档流中, 浮动元素会漂浮在文档流的块框上。
* 父元素高度无法被撑开,影响与父元素同级的元素
* 与浮动元素同级的非浮动元素（内联元素）会跟随其后
* 若非第一个元素浮动，则该元素之前的元素也需要浮动

#### 清除浮动方法
>https://github.com/Easay/issuesSets/issues/12


一般来说，元素设置为浮动后会脱离文档流，不会对文档流中其他元素造成影响。但是文本内容会记住浮动元素的大小，并在排布时避开它。造成文本环绕浮动盒子的效果。要阻止行盒子环绕在浮动盒子外面，需要给包含行盒子的元素应用clear属性。

清除浮动主要是为了解决父元素因为子元素浮动而引起的内部高度为0的问题。

##### 清除浮动的方式有：

* 父级元素定义height（不推荐）
缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题。
* 结尾处加空div标签+clear:both（不推荐）
在最后加空div标签，并设定clear:both，会在空div标签上方创造出足够的垂直外边距，从而为包住浮动元素创造空间。父元素自动检测子盒子最高的高度，然后与其同高。
* 父级div定义伪类：after+zoom（推荐🌷）
IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE专有属性)可解决ie6,ie7浮动问题。
```css
.father:after{
      content:" ";
      clear:both;
      display: block;
      /* height:0px; */
  }
```

* 父级div定义overflow:hidden
缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素
* 父级div定义overflow:auto
当在父级div定义overflow: hidden|auto时，浏览器会自动检查浮动区域的高度。


#### 其它
* 元素浮动后,display自动变为block





### 说说BFC的理解
#### 定义

当元素在页面上垂直或水平排布时，它们之间如何相互影响，CSS有几套不同的规则，其中一套叫块级格式化上下文（Block Formatting Context）。
**格式化上下文**
Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。
最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。

BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。


#### 会渲染BFC的元素
>https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context
* document的根元素(`<html>`)
* 浮动(float值不为none)
* 绝对定位元素(元素position值为absolute/fixed)
* 行内块(元素display属性值为inline-block)
* 表格单元(元素display属性为table-cell,默认的HTML表格)
* 表格标题(元素display属性为table-caption,默认的HTML表格)
* 被拥有`display:table`属性隐式创建的匿名table表格
* 带有overflow属性(其值不能为visible/clip)的块元素
* `display:flow-root`
* contain属性值为layout/content/paint的元素
* Flex子元素(属性为display:flex/inline-flex的元素的直接子元素),如果它们本身不是flex或grid或table容器.
* Grid子元素(属性为display:grid/inline-grid的元素的直接子元素),如果它们本身不是flex或grid或table容器.
* 多列容器(元素其column-count/column-width不是auto,column-count不是1)
* column-span:all


#### BFC区域布局规则
1. 内部的Box按垂直方向排列;
2. 计算BFC的高度时，浮动元素也参与计算
3. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
4. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。(是不补偿最左边??)
5. BFC的区域不会与float box重叠。
6. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

#### BFC应用 ?
* 自适应两列布局
* 高度塌陷-内部浮动父元素高度为0
* 高度塌陷-相邻元素外边距重叠
* 高度塌陷-嵌套元素解决外边距塌陷



### 选择器优先级

#### 选择器
选择器是用来匹配HTML文档中特定元素的模式

#### 分类
##### 基本选择器
* 全局选择器
* 类型选择器
* 类选择器
* ID选择器
* 属性选择器

##### 分组选择器
* 选择器列表

##### 组合选择器
* 后代组合器
* 直接子代组合器(`a > b`) 选择选择前一个元素的直接子代的节点
* 一般兄弟组合器(`a ~ b`) 后一个节点在前一个节点后面的任意位置，并且共享同一个父节点。
* 相邻兄弟组合器(`a + b`) 后一个元素紧跟在前一个之后，并且共享同一个父节点。

##### 伪选择器
* 伪类选择器   `:`伪选择器支持按照未被包含在文档树中的状态信息来选择元素。
* 伪元素选择器 `::` 伪选择器用于表示无法用 HTML 语义表达的实体


#### 优先级
优先级就是CSS声明的一个<u>权重</u>，它由匹配的选择器中的<u>每一种选择器类型</u>的数值决定。

#### 计算优先级
<span style="color:blue">一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：</span>

1. **千位**： 如果声明在 [`style`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style) 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。
2. **百位**： 选择器中包含<u>ID选择器</u>则该位得一分。
3. **十位**： 选择器中包含<u>类选择器、属性选择器、伪类</u>则该位得一分。
4. **个位**：选择器中包含<u>元素、伪元素选择器</u>则该位得一分。

**注**: <span style="color:blue">通配符选择器 (`*`)，组合符 (`+`, `>`, `~`, ' ')，和否定伪类 (`:not`) 不会影响优先级。</span>


### flex弹性布局

#### 是什么?
Flexbox是一种用于布局的CSS3模块，它提供了一种灵活的方式来组织和对齐网页中的元素。通过定义容器和其子项的属性，可以轻松地实现各种布局，如水平和垂直居中、等高列、响应式布局等。


#### 实例
##### 如何实现响应式flex布局
通过使用媒体查询和弹性盒子属性，实现响应式Flex布局，以适应不同的屏幕尺寸。
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Flexbox Responsive Layout</title>
  <style>
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
    }

    .item {
      flex: 1 0 calc(33.333% - 20px);
      margin-bottom: 20px;
      background-color: #ccc;
      text-align: center;
      padding: 10px;
    }

    @media (max-width: 768px) {
      .item {
        flex: 1 0 calc(50% - 20px);
      }
    }

    @media (max-width: 480px) {
      .item {
        flex: 1 0 calc(100% - 20px);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="item">Item 1</div>
    <div class="item">Item 2</div>
    <div class="item">Item 3</div>
    <div class="item">Item 4</div>
    <div class="item">Item 5</div>
    <div class="item">Item 6</div>
  </div>
</body>
</html>
```

##### 等高列
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Equal Height Columns with Flexbox</title>
  <style>
    .container {
      display: flex;
    }

    .column {
      flex: 1;
      padding: 20px;
      background-color: #ccc;
    }

    .column:first-child {
      margin-right: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="column">
      <h2>Column 1</h2>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam malesuada felis vel augue accumsan, at posuere neque tincidunt. Sed pulvinar, nisi in fringilla fringilla, lorem nisl semper purus, vel consequat ipsum nibh vitae libero.</p>
    </div>
    <div class="column">
      <h2>Column 2</h2>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam malesuada felis vel augue accumsan, at posuere neque tincidunt. Sed pulvinar, nisi in fringilla fringilla, lorem nisl semper purus, vel consequat ipsum nibh vitae libero. Proin dictum arcu a libero pulvinar auctor. </p>
      <p>Praesent lobortis erat vel justo finibus, nec ullamcorper quam pretium. Vivamus sed ipsum ligula. Donec lobortis sodales massa eu placerat.</p>
    </div>
  </div>
</body>
</html>
```


#### flex容器6属性及作用
* **flex-direction**  主轴的方向（即子元素的排列方向: row | row-reverse | column | column-reverse。默认row。
* **flex-wrap** 子元素是否需要换行.可选值有:nowrap | wrap | wrap-reverse。默认nowrap。
* **flex-flow** 上面两项合并写法
* **justify-content** 子元素在主轴的对齐方式
	* flex-start
	* flex-end
	* center
	* space-between  两端对齐，项目之间的间隔都相等。
	* space-around   每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
* **align-items** 子元素在交叉轴上的对齐方式
	* flex-start  交叉轴的起点对齐
	* flex-end
	* center   交叉轴的起点对齐
	* baseline 项目的第一行文字的基线对齐。
	* stretch  默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
* **align-content** 定义了多根交叉轴存在时子元素在交叉轴上的对齐方式。如果项目只有一根轴线，该属性不起作用。

#### flex元素6属性
* order 定义子元素的排列顺序(在主轴上数字越小越靠前)
* flex-grow 元素的放大比例,默认为0.如果都为1,则每项元素在空间扩大时等分剩余空间
* flex-shrink 元素的缩小比例
	* 默认为1,空间不足时均等比例缩小
	* 如果一个子元素的flex-shrink属性为0,其它子元素的为1.则空间不足时,前者不缩小.
	* 负值对该属性无效
* flex-basis 默认值为auto,表示元素占据主轴空间的原大小.可以设置具体数值
* flex 上面3项的缩写. 
	* `flex:1`表示项目会根据剩余空间按等比例方法/缩小.最后值不为auto就不会按本身宽度而均分计算.
	* `flex:none`  等价于`flex:0 0 auto`
	* `flex:100px` 等价于`flex:1 1 100px`，表示项目会根据剩余空间按比例放大，也会按比例缩小，基准长度为100像素.
* align-self 单个元素的对齐方式


### position

#### position属性有那些值
position 属性用于指定一个元素在文档中的定位方式.
position有四个常用属性值：relative、absolute、fixed、static。三个不常用的：inherit、initial、sticky、unset

不设置Position的值或设置了position:static，top，left，right，bottom不起作用.
通过position属性，我们可以让元素相对于其正常位置，父元素或者浏览器窗口进行偏移。

#### position属性值介绍

##### static
默认值. 不设定position或者设定position:static都不会对这个div（或者别的标签）的布局有影响. top，left，right，bottom不会起作用

##### relative
* 相对定位. 未脱离文档流,基于元素的margin左上角进行偏移,不会影响其它元素的位置
* left和right同时存在，仅left有效;当top和bottom同时存在仅top有效。

##### absolute
* 绝对定位. 元素脱离了文档流,绝对定位元素相对于最近的非static祖先元素定位。
* 当祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）,可以理解为窗口/body元素.
* 关于盒子层叠的次序，可以设置一个叫z-index的属性，值越大，离眼睛越近。

##### fixed
* 固定定位. 以浏览器的窗口为参考点进行定位.
* 当出现滚动条时，对象不会随着滚动，IE6以下不支持该属性。

##### sticky
* 磁贴定位. 
* 像position:relative和position:fixed的合体:

#### 其它

##### 声明为fixed/absolute时
* 该元素将变为块级元素(例子,span设置absolute后,可以设置宽高)
* 如果该元素是块元素且宽度是100%,则宽度变为auto


### css实例

#### 隐藏元素的3种方法比较
|                     | 是否隐藏 | 是否在文档中占用空间 | 是否会触发事件 | 渲染 |
| ------------------- | -------- | -------------------- | -------------- | ---- |
| display: none       | 是       | 否                   | 否             | 触发重排     |
| visiblility: hidden | 是       | 是                   | 是             |     触发重绘 |
| opacity: 0          | 是       | 是                   | 是             | 触发重绘     |



#### 用css实现瀑布流
利用column-count和break-inside这两个CSS3属性即可

<iframe src="https://codesandbox.io/embed/staging-frog-598uwu?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="css3 瀑布流"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
   


#### 有什么不同的方式可以隐藏内容？
> https://www.frontendinterviewhandbook.com/zh/css-questions#有什么不同的方式可以隐藏内容使其仅适用于屏幕阅读器'
> 注意,链接提供的方法中涉及的Metadata格式化规范方法, WAI-ARIA规范和隐藏元素不太相关.

* display: none;：这是最常见的一种隐藏元素的方法。该属性可以完全从页面中删除元素，并在布局中不占用空间。然而，这种方法会将元素完全从文档流中删除，包括任何子元素和事件监听器。

* visibility: hidden;：这种方法与 display: none; 类似，但元素仍会占用布局空间。元素仍保留在文档流中，但对用户不可见，并且不会响应事件。

* opacity: 0;：该属性将元素的不透明度设置为 0，使元素在页面上不可见，但仍会保留在文档流中并响应事件。

* position: absolute;：将元素的 position 属性设置为absolute，可以将其从文档流中移除并相对于其最近的定位祖先进行定位。可以通过将 left 或 top 属性设置为负值来将元素移出视图区域。

* clip-path: polygon(0 0, 0 0, 0 0, 0 0);：该属性可以将元素裁剪成一个多边形，通过将其所有点的坐标设置为相同的值（例如，0），可以将元素完全裁剪并隐藏。

* height: 0; width: 0; overflow: hidden;：该属性将元素的高度和宽度设置为 0，并将其 overflow 属性设置为 hidden，以将其内容隐藏在元素内部。

* transform: scale(0);：该属性将元素缩放为 0，使其在页面上不可见，但仍会保留在文档流中并响应事件。


#### 编写高效的 CSS 应该注意什么？

浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。

选择器匹配语句链越短，浏览器的匹配速度越快。

避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。

原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。

搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。



#### div水平垂直居中的5种方法
* flex
* absolute+left/top+margin
* absolute+left/top+transform
* absolute+(left/right/top/bottom) + margin
* tabel-cell + vertical-align

<iframe src="https://codesandbox.io/embed/layout-divchui-zhi-ju-zhong-de-ji-zhong-fang-fa-k5np45?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="layout-div垂直居中的几种方法"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>






#### css水平、垂直居中的写法，请至少写出4种？

*水平居中*
- 行内元素: `text-align: center`
- 块级元素: `margin: 0 auto`
- position:absolute +left:50%+ transform:translateX(-50%)
- `display:flex + justify-content: center`

*垂直居中*
- 设置line-height 等于height
- position：absolute +top:50%+ transform:translateY(-50%)
- `display:flex + align-items: center`
- display:table+display:table-cell + vertical-align: middle;




#### 单行文本溢出
```css
overflow: hidden;
white-space: nowrap;
text-overflow: ellipsis;
```

#### 多行文本溢出
```css
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2; // 最多显示几行
-webkit-box-orient: vertical;
```



#### 画三角形
* border
* border+transform
* 伪元素
* linear-gradient
* clip-path
* svg
<iframe src="https://codesandbox.io/embed/san-jiao-xing-3mqln7?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="三角形"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>



#### inline-block元素间间距问题
> [去除inline-block元素间间距的N种方法 « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-去除间距/)

- 移除空格
- 使用margin负值
- 使用font-size:0
- letter-spacing
- word-spacing


#### 布局案例
##### 左侧固定右侧自适应
<iframe src="https://codesandbox.io/embed/bu-ju-zuo-ce-gu-ding-you-ce-zi-gua-ying-ez6btk?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="布局-左侧固定右侧自适应"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>




##### 圣杯布局
<iframe src="https://codesandbox.io/embed/bu-ju-sheng-bei-bu-ju-yt3zf5?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="布局-圣杯布局"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>



##### 双飞翼布局
<iframe src="https://codesandbox.io/embed/bu-ju-shuang-fei-yi-bu-ju-fnjxv4?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="布局-双飞翼布局"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>


#### 单行/多行文本居中
使用line-height实现
<iframe src="https://codesandbox.io/embed/wen-ben-chu-li-wc1nq3?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="文本处理"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>




### CSS 预处理器 //?

CSS 预处理器的原理: 是将类 CSS 语言通过 **Webpack 编译** 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能:

- 嵌套
- 变量
- 循环语句
- 条件语句
- 自动前缀
- 单位转换
- mixin 复用

```js
//less
0.嵌套 &代表当前选择器的父级.使用嵌套（nesting）代替层叠或与层叠结合使用

1.变量声明 @+变量名称=值
2.使用变量 
 2.1作为属性值
 2.2作为属性名 @{变量名称}
 2.3作为选择器 #@{变量名称} @{#变量名称}
 2.4


3.循环语句
4.条件语句

5.自动前缀




7.混入mixin
混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。
```


### 响应式设计

#### 是什么
一个网站能够兼容多个终端

#### 实现方法
通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。
```html
<meta name=’viewport’ content=”width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no”>
```


### 使用css画一个三角形/圆形/半圆
> https://github.com/Easay/issuesSets/issues/7


#### 三角形
**border方式**
```css
div {
	width: 0px;
	height: 0px;
	border-width: 0 40px 40px;
	border-style: solid;
	border-color: transparent transparent green;
}
```

**clip-path方式**
clip-path属性使用裁剪方式创建元素的可显示区域，区域内的部分显示，区域外的隐藏。
```css
#triangle{
	width:100px;
	height:100px;
	background: red;
	clip-path:polygon(0 100%,50% 0,100% 100%);
}
```

#### 圆形/半圆/扇形
```css
.circle {
    border-radius: 50%
}


.container{ //半圆
    width: 100px;
    height: 50px;
    background: red;
    border-radius: 50px 50px 0 0;
}

.container{ //扇形
    width: 50px;
    height: 50px;
    background: red;
    border-radius: 50px 0 0;
}
```


## JavaScript

### ES6新增特性
let和const
箭头函数
剩余参数（rest参数）和扩展运算符
模板字符串
解构赋值
类
Set和Map
Promise
Proxy
新增数组方法

### var/const/let的区别
- const定义常量, let/var定义变量
- const和let相对于var
  - 有块作用域
  - 没有变量提升
  - 不会添加到window上
  - 不能重复声明

### 声明变量的6种方式
>https://github.com/Easay/issuesSets/issues/113
* var
* let
* const
* function
* import
* class
#### 代码示例
代码1
```js
 function fun(str){
  let str = 'hello'+'world!';
  console.log(str);
}
fun('123');
```
结果：运行后是一个语法错误：Uncaught SyntaxError：Identifier 'code' has already been declared

代码二
```js
var str = 'hello';

function fun(){
  console.log(str);
  let str = 'world';
  console.log(str);
}
fun();
```
结果：只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响，这也就是传说中的 暂时性死区，ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错，所以上面是一段错误代码：Uncaught ReferenceError: Cannot access 'str' before initialization。

代码三
```js
const obj = {};
let str = '坚持一周写两篇博客';
let addObj = obj.names = str;

console.log(addObj); //坚持一周写两篇博客
console.log(obj);{names:"坚持一周写两篇博客"}
```

const需要注意：
* 只声明不赋值，会报错；
* 只在声明所在的块级作用域内有效；
* const命令声明的常量不提升，存在暂时性死区；
* 不可重复声明；
* 冻结对象，可以使用Object.freeze方法


**function**
ES6规定：
允许在块级作用域内声明函数。
函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
同时，函数声明还会提升到所在的块级作用域的头部。
上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。

// 浏览器的 ES6 环境
```js
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
```
**import**
import用于加载文件，在大括号接收的是一个或多个变量名，这些变量名需要与想要导入的变量名相同。

🌰：导入action.js文件中的某一个变量，这个变量里保存了一段代码块，所以要写成：import { Button } from 'action'，这个时候，就从action.js中获取到了一个叫 Button 的变量。

如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名，比如：
```js
import { NewButton as Button } from 'action.js';
```

**class**
```js
class Interest {
	constructor( x, y, e, z ){
		this.x = x;
		this.y = y;
		this.e = e;
		this.z = z;
	}

	MyInterest(){
		let arr = [];
		console.log(`我会${[...arr,this.x,this.y,this.e,this.z]}!`);
	}
}

let GetInterest = new Interest('唱','跳','rap','篮球');
console.log(GetInterest.MyInterest());  //我会唱,跳,rap,篮球!
```



### **执行上下文**

#### 是什么
当 JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

每个执行上下文都有3个属性:
* 变量对象(Variable object，VO)
* 作用域链(Scope chain)
* this

### 执行上下文栈

#### 定义

执行上下文栈（Execution context stack，ECS）来管理执行上下文
当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。


### 变量对象
#### 是什么
变量对象是与执行上下文相关的<span style="color:red">数据作用域</span>，存储了在上下文中定义的变量和函数声明。在函数被调用但是函数尚未被执行时被创建的.创建过程实际上就是函数初始化的过程.
全局上下文中的变量对象就是全局对象
函数上下文中的变量对象(活动对象)是进入函数上下文时被创建的

#### 变量对象的组成
执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：
1. 进入执行上下文
2. 代码执行
当进入执行上下文时，这时候还没有执行代码，
变量对象会包括：
1. 函数的所有形参 (如果是函数上下文)
   - 创建由名称和对应值组成的一个变量对象的属性
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 创建由名称和对应值（函数对象(function-object)）组成一个变量对象的属性
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 创建由名称和对应值（undefined）组成一个变量对象的属性
   - <span style="color:blue">如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</span>

#### 变量对象实例
```javascript
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：
```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```

代码执行:
在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值
还是上面的例子，当代码执行完后，这时候的 AO 是：
```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```


### 作用域
#### 产生的背景
将变量引入程序带来的问题: 变量存储在哪里? 程序需要的时候如何找到它们?
#### 是什么
存储变量和查找变量的规则.

#### 变量查找案例 (`var a = 2`)

以`var a = 2`为例:
* 首先, 编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。
* 遇到`var a`，<span style="color:blue;">编译器会询问作用域</span>是否在同作用域集合中存在同名变量
  * 是 编译器会忽略该声明，继续进行编译；
  * 否 它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a
* 编译器为引擎运行生成所需的代码,用来处理a=2这个赋值操作.<span style="color:blue;">引擎运行时会首先询问作用域</span>，在当前的作用域集合中是否存在一个叫作`a`的变量。
  * 是, 引擎就会使用这个变量
  * 否, 引擎会继续查找该变量
    * 找到, 就会将2赋值给它;
    * 没找到, 引擎就会举手示意并抛出一个异常 ?!!

#### 引擎查找变量两套规则

查找变量的两种查询方式:
- LHS查询  “赋值操作的目标是谁（LHS） 一般出现在赋值操作的左侧
- RHS查询  “谁是赋值操作的源头（RHS）”  一般出现在赋值操作的右侧

#### 查询未声明变量的处理过程
在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。具体表现如下:
- RHS查询遍寻不到所需的变量,引擎会抛出`ReferenceError`异常
- LHS查询遍寻不到所需变量,
  - 非严格模式: 全局作用域会创建一个具有该名称的变量,并返还给引擎(非'严格模式'下)
  - 严格模式: 抛出同RHS查询失败时类似的`ReferenceError`异常
- RHS查询找到一个变量,但对变量进行不合理操作(例如,对函数类型进行调用,引用null/undefined值中的属性), 引擎抛出`TypeError`.

> `ReferenceError` 同作用域判别失败相关
> `TypeError` 代表作用域判别成功了，但是对结果的操作是不合法的



#### 编程语言中作用域的类型

作用域共有两种主要的工作模型。
- 词法作用域: 最为普遍的，被大多数编程语言所采用的。<span style="color:blue;">词法作用域就是定义在词法阶段的作用域</span>。
- 动态作用域，仍有一些编程语言在使用（比如Bash脚本、Perl中的一些模式等）


#### JS中的作用域类型
* 全局作用域
* 函数作用域
* 块作用域

#### JS函数作用域的特点

> 在某个位置独立调用,将会局部提升

* 函数的作用域由函数的<u>定义位置决定</u>,和函数的调用位置无关
* 函数作用域在函数调用时<u>创建</u>，在调用结束时<u>销毁</u>  
* 函数每次调用都会产生一个<u>新的</u>函数作用域，函数作用域之间<u>相互独立</u>
* 在函数作用域中声明的变量是<u>局部变量</u>,只能在函数内部访问; 省略var或let，则变量默认会成为<u>全局</u>变量(不希望出现的情况)
* 在函数内部，使用var声明的变量和使用function开头的函数也会被<u>提升</u>



#### JS中的块作用域有哪些?

<u>with</u>

用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。

<u>try...catch</u>

其中声明的变量仅在catch内部有效

<u>let</u>

let关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说，let为其声明的变量<span style="color:blue;">隐式地劫持了所在的块作用域</span>


#### JS块作用域的实例

1.作用域作用-垃圾回收

让引擎清楚地知道没有必要继续保存某些数据

```javascript
function process(data) {
  //...
}
{ //在这个块中定义的内容完事可以销毁
	var someReallyBigData = {};
	process(someReallyBigData);
}

//
```

<u>2.let循环</u>

<span style="color:blue">for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</span>

下面通过另一种方式来说明每次迭代时进行重新绑定的行为：

```javascript
{
  let j;
  for (j=0; j<10; j++) {
    let i=j; //每个迭代重新绑定
    console.log(i);
  }
}

//说明了几件事情?
//1. for循环内存在块作用域
//2. let声明的变量会绑定到循环的每一次迭代中
```

<u>3.创建块作用域变量</u>

可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。





#### 作用域的使用
> 基于作用域隐藏变量和函数


#### 作用域嵌套

是什么?
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。

查找规则?
引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。



#### 作用域链

定义
由多个执行上下文的<u>变量对象</u>构成的链表叫做作用域链. 当查找变量时,会,就会,全局....


### 函数
#### 函数声明和函数表达式区别
* 以函数声明的方法定义的函数,函数名是必须的,而函数表达式的函数名是可选的。（函数声明整体会被提升到当前作用域的顶部，函数表达式也提升到顶部但是只有其变量名提升）
* 以函数声明的方法定义的函数,函数可以在函数声明之前调用,而函数表达式的函数只能在声明之后调用。

* 以函数声明的方法定义的函数并不是真正的声明,它们仅仅可以出现在全局中,或者嵌套在其他的函数中,但是它们不能出现在循环,条件或者try/catch/finally中,而函数表达式可以在任何地方声明。换句话说，函数声明不是一个完整的语句，所以不能出现在if-else,for循环，finally，try catch语句以及with语句中。


### 闭包
![image](https://cdn.staticaly.com/gh/aotushi/image-hosting@master/documentation/image.7g1aiggs0g00.webp)
#### 定义
一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。
也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。
简单来说,有权访问另一个函数作用域变量的函数.

#### 形成原因
存在上级作用域的引用


#### 如何创建
- 嵌套的内部函数引用了外部函数的变量, 当调用外部函数并执行返回的内部函数

#### 闭包作用
- 保护函数的私有变量不受外部干扰
- 形成不被销毁的栈内存
- 将上级作用域的引用保存下来,实现方法或属性的私有化

#### 缺点
* 内存泄露: 程序申请了内存,但没有及时释放,导致内存空间被浪费
* 内存溢出: 程序申请的内存超过系统提供的上限,导致无法分配内存.

#### 使用场景
闭包使用场景包括: 使用return返回函数; 函数作为参数; IIFE; 定时器setTimeout; 所有的回调函数.

1.回调
闭包有用之处在于它可以将一些数据和操作它的函数关联起来。这和面向对象编程明显相似。在面对象编程中，我们可以将某些数据（对象的属性）与一个或者多个方法相关联。(在<span style="color:red">定时器, 事件监听器,Ajax请求,跨窗口通信,Web Works或者其他的异步(或同步)任务</span>中,<span style="color:blue;"> 只要使用了回调函数,实际上就是在使用闭包.</span>)
因此，当你想只用一个方法操作一个对象时，可以使用闭包。

2.模拟私有方法
私有方法不仅可以限制代码的访问权限，还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口。


#### 闭包实例

##### 简述函数执行过程
```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```

简要复述其执行过程:

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2. 全局执行上下文初始化
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
4. checkscope 执行上下文初始化，创建变量对象、作用域链、this等
5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
7. f 执行上下文初始化，创建变量对象、作用域链、this等
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

问题:

当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

<span style="color:red"> f 执行上下文维护了一个作用域链</span>：



##### 实现一个只能执行3次的函数
有一个函数，参数是一个函数，返回值也是一个函数，返回的函数功能和入参的函数相似，但这个函数只能执行3次，再次执行无效，如何实现

```javascript
function sayHi() {
    console.log('hi')
}

function threeTimes(fn) {
    let times = 0
    return () => {
        if (times++ < 3) {
            fn()
        }
    }
}

const newFn = threeTimes(sayHi)
newFn()
newFn()
newFn()
newFn()
newFn() // 后面两次执行都无任何反应
```



##### 实现add函数,让add(a)(b)和add(a,b)两种调用结果相同

```javascript
function add(a, b) {
  if (b === undefined) {
    return function(x) {
       return a + x
    }
  }
  
  return a + b
}
```


#### 闭包面试题

1.for循环
```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0](); //输出3
data[1](); //输出3
data[2](); //输出3
```

如何改造:
* 立即执行函数
* 使用let
```js
var data = []
for (var i=0; i<3; i++) {
	//data[i] = (function() {console.log(i)})(i) 错误
	data[i] = (function(j){console.log(j)})(i)
}


//let
var data = []
for (let i=0; i<3; i++) {
	console.log(i)
}
```



#### 其它
##### IIFE是闭包吗?

```javascript
var a = 2;
(function IIFE() {
  console.log(a);
})();
```

以上代码并不是严格的闭包:
* 因为函数（示例代码中的IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行
* a是通过普通的词法作用域查找而非闭包被发现的。


##### 循环和闭包
```javascript
for (var i=1; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i*1000)
}
```

延迟函数的回调会在循环结束时才执行. 即使每个迭代中执行的setTimeout(..., 0), 所有的回调函数依然是在循环结束后才被执行.

**代码的问题:**

我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。<u>但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。</u>

解决:

IIFE解决方案:
```javascript
//正确代码
for (var i=1; i<=5; i++) {
  (function() {
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j*1000)
  })()
}
//改进
for (var i=1; i<=5; i++) {
  (function() {
    setTimeout(function timer() {
      console.log(i);
    }, i*1000)
  })(i);
}
```

使用let代替IIFE
使用let声明来代替IIFE创建新的作用域
```javascript
for (var i=1; i<=5; i++) {
  let j=i; //闭包的块作用域
  setTimeout(function timer() {
    console.log(j);
  }, j*1000);
}
```



##### 模块
通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。
* 接收参数
* 命名将要作为公共API返回的对象

```javascript
var foo = (function CoolModule(id) {
  function change() {
    //修改公共API
    publicAPI.identify = identify2;
  }
  
  function identify1() {
    console.log(id);
  }
  
  function identify2() {
    console.log(id.toUpperCase());
  }
  
  var publicAPI = {
    change: change,
    identify: identify1
  };
  
  return publicAPI;
})('foo module');

foo.identify(); //'foo module'
foo.change();
foo.identify(); //'FOO MODULE'
```

其他后续内容, 笔记中记录的比较详细, 面试就说到这里吧

### this

#### 介绍
* 执行上下文的一个属性
* 是在运行时进行绑定的,和函数声明的位置无关.

#### 使用原因
* 显式传递上下文对象会让代码越来越混乱
* 调用函数时候不用传递上下文对象, this隐式传递一个对象引用,API简洁易于复用

#### 绑定规则
* 默认绑定
  * 非严格模式下,函数直接调用,this绑定到window/globalThis; 严格模式下,this是undefined
* 隐式绑定
  * 调用位置上是否有上下文对象或者说是否被某个对象拥有或包含.(注意: 函数不属于对象,从作用域上来解释)
  * 规则:
    * 当引用函数有上下文对象时,隐式规则会把this绑定到上下文对象
    * <span style="color:red">对象属性引用链中只有最后一层在调用位置中起作用</span>
  * 存在的问题: 隐式丢失
    * 丢失绑定对象,会应用默认绑定.
  * 隐式丢失 几种情况
    * 将`对象.方法`赋值给变量,调用这个变量
    * 参数传递, 将函数是通过参数传递进函数
    * 把函数传入语言内置的函数
  * 隐式绑定存在问题
    * 隐式丢失中,无法控制回调函数的执行方式,也就无法控制调用位置以得到期望的值
    * 如何解决？ 固定this

* 显式绑定
  * 不想在对象内部包含函数引用，而想在某个对象上强制调用函数。  使用call/apply/bind
  * 如果call/apply第一个参数传入原始值？？
    * 装箱  基本类型转成它的对象形式
  * 显示绑定存在的问题（理解）
    * 虽然call和apply可以在任意地方调用,但是它是直接进行调用送的.设想,如果在某个第三方库中,其异步的回调函数需要改变this,如果这个时候使用call/apply会立即调用并更改this,异步在不知道完成与否的情况下,异步回调直接运行了.
* new绑定

使用new来调用函数,或者说发生构造函数调用时,会自动执行下面的操作:
1. 内存中新建一个对象
2. 将新建对象的隐式原型[[prototype]]指针赋值为构造函数的原型prototype
3. 这个新对象会绑定到函数调用的this
4. 如果函数返回非空对象,则返回;否则,返回新建对象.
```js
//隐式绑定丢失
//把函数传如语言内置的函数
function foo() {
  console.log(this.a)
}

var obj = {
  a:2,
  foo: foo
}

var a = 'oops, global!'
setTimeout(obj.foo, 100); //'oops, global'
//js内置的setTimeout函数和下面的伪代码类似
functionsetTimeout(fn, delay) {
  //delay
  fn()
}
```

```js
// new绑定

const newFn = () => {
	let obj = {}
	let fn = arguments[0]
	let args = [].slice.call(arguments, 1)
	obj.__proto__ = fn.prototype
	let res = fn.call(obj, args)
	return typeof res === 'object' ? res : obj
}
```

### this在不同场景下的取值?

- 常规情况下, 函数中的this取决于执行函数的方式
  - fn(): 直接调用  ==> **this是?**  window
  - new fn(): new调用 ==> **this是?**  新建的对象
  - obj.fn(): 通过对象调用 ==> **this是?**  obj
  - fn.call/apply(obj): 通过函数对象的call/apply来调用 ==> **this是?**  obj

- 特殊情况:
  - bind(obj)返回的函数  ==> **this是?**  obj
  - 箭头函数 ==> **this是?**  外部作用域的this
  - 回调函数
    - 定时器/ajax/promise/数组遍历相关方法回调  ==> **this是?**  window 或 当前的事件源
    - vue控制的回调函数  ==> **this是?**  组件的实例
    - React控制的生命周期回调, 事件监听回调  ==>  **this是?**  组件对象 / undefined

- 如何控制函数的this?  
  - 利用函数的bind()
  - 利用箭头函数
  - 也可以用外部保存了this的变量

### JS设计模式
>https://github.com/Easay/issuesSets/issues/71

* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式
* 单例模式

#### 简单工厂模式
简单工厂将实例化的操作单独放到一个类中，这个类就是简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。

当需要添加基类时，也要在工厂里添加对应的生产逻辑。

**简单工厂1**
```js
'use strict';

function createBook(name, time, type) {
  var o = {
    name: name,
    time: time,
    type: type,
    getName: function() {
      return this.name;
    }
  };

  return o;
}

var book1 = createBook('javascript', '2015', 'js');
var book2 = createBook('Nodejs', '2015', 'Nodejs');

console.log(book2);
```

**简单工厂2**
```js
'use strict';

// 篮球基类
var BasketBall = function() {
  this.intro = '篮球盛行于美国';
};

BasketBall.prototype = {
  getMember: function() {
    console.log('每个队伍需要5名队员');
  },

  getBallSize: function() {
    console.log('篮球很大');
  }
};

// 足球基类
var FootBall = function() {
  this.intro = '足球在世界范围内很流行';
};

FootBall.prototype = {
  getMember: function() {
    console.log('每个队伍需要11名队员');
  },

  getBallSize: function() {
    console.log('足球很大');
  }
};

// 网球基类
var Tennis = function() {
  this.intro = '每年有很多网球系列赛';
}

Tennis.prototype = {
  getMember: function() {
    console.log('每个队伍需要1名队员');
  },

  getBallSize: function() {
    console.log('网球很小');
  }
};

// 运动工厂
var SportsFactory = function(name) {
  switch(name) {
    case 'NBA':
      return new BasketBall();
    case 'wordCup':
      return new FootBall();
    case 'FrenchOpen':
      return new Tennis();
  }
};

// 为NBA杯创建一个篮球，只需要记住运动工厂 SportsFactory，调用并创建
var NBA = SportsFactory('NBA');
console.log(NBA);
```


#### 工厂方法模式
比较简单工厂模式，好处是增加基类时不需要修改Factory类。
```js
'use strict';
var Factory = function(type, text) {
  if (this instanceof Factory) {
    this[type](text);
  } else {
    return new Factory(type, text);
  }
};

Factory.prototype = {
  javascript: function(text) {
    console.log(text + 'javascript');
  },
  nodejs: function(text) {
    console.log(text + 'nodejs');
  }
};

Factory('javascript', '万能的');
```


#### 抽象工厂模式
```js
'use strict';

var VehicleFactory = function(subClass, superType) {

  // 判断抽象工厂中是否有该抽象类
  if (typeof VehicleFactory[superType] === 'function') {

    // 缓存类
    function F() {}

    // 继承父类属性和方法
    F.prototype = new VehicleFactory[superType]();

    // 将子类constructor指向子类
    F.constructor = subClass;

    // 子类原型继承”父类“
    subClass.prototype = new F();
  } else {
    throw new Error('未创建该抽象类');
  }
};

// 小汽车抽象类
VehicleFactory.Car = function() {
  this.type = 'car';
};

VehicleFactory.Car.prototype = {
  getPrice: function() {
    return new Error('抽象方法不能调用');
  },
  getSpeed: function() {
    return new Error('抽象方法不能调用');
  }
};

// 公交车抽象类
VehicleFactory.Bus = function() {
  this.type = 'bus';
};

VehicleFactory.Bus.prototype = {
  getPrice: function() {
    return new Error('抽象方法不能调用');
  },
  getSpeed: function() {
    return new Error('抽象方法不能调用');
  }
};

// 货车抽象类
VehicleFactory.Truck = function() {
  this.type = 'truck';
};

VehicleFactory.Truck.prototype = {
  getPrice: function() {
    return new Error('抽象方法不能调用');
  },
  getSpeed: function() {
    return new Error('抽象方法不能调用');
  }
};

// 宝马汽车子类
var BMW = function(price, speed) {
  this.price = price;
  this.speed = speed;
};

VehicleFactory(BMW, 'Car');

BMW.prototype.getPrice = function() {
  return this.price;
};
BMW.prototype.getSpeed = function() {
  return this.speed;
};

var a = new BMW(100, 2);

console.log(a.getPrice());
console.log(a.type);
```


#### 单例模式
保证一个类仅有一个实例，并提供一个访问它的全局访问点。想要保证一个类仅有一个实例，我们需要提供一个变量来标志当前是否已经为一个类创建过实例。
```js
'use strict';

var A = {
  Util: {
    util_method1: function() {},
    util_method2: function() {}
  },
  Tool: {
    tool_method1: function() {},
    tool_method2: function() {}
  },
  Ajax: {
    get: function() {},
    post: function() {}
  },
  others: {
    // ...
  }
};

A.Util.util_method2();
A.Tool.tool_method1();
A.Ajax.get();
```

**静态变量**
```js
'use strict';

var Config = (function() {
  // 私有变量
  var config = {
    MAX_NUM: 100,
    MIN_NUM: 1,
    COUNT: 1000
  };

  // 返回取值器对象
  return {
    // 取值器方法
    get: function(name) {
      return config[name] ? config[name] : null;
    }
  }
})();

var count = Config.get('COUNT');
console.log(count);
```

**惰性单例**
```js
'use strict';

// 惰性载入单例
var LazySingle = (function() {

  // 单例实例引用
  var _instance = null;

  // 单例
  function Single() {
    // 这里定义私有属性和方法
    return {
      publicMethod: function() {},
      publicProperty: '1.0'
    }
  }

  return function() {

    if (!_instance) {
      _instance = Single();
    }

    // 返回单例
    return _instance;
  }
})();


console.log( LazySingle().publicProperty ); // 1.0
console.log( LazySingle() === LazySingle() ); // true
```

**ES6重写**
```js
class SingletonApple {
  constructor(name, creator, products) {
    //首次使用构造器实例
    if (!SingletonApple.instance) {
      this.name = name;
      this.creator = creator;
      this.products = products;
      //将this挂载到SingletonApple这个类的instance属性上
      SingletonApple.instance = this;
    }
    return SingletonApple.instance;
  }
}

let appleCompany = new SingletonApple('苹果公司', '乔布斯', ['iPhone', 'iMac', 'iPad', 'iPod']);
let copyApple = new SingletonApple('苹果公司', '阿辉', ['iPhone', 'iMac', 'iPad', 'iPod']);

console.log(appleCompany === copyApple);  //true
```


**静态方法优化**
```js
class SingletonApple {
  constructor(name, creator, products) {
      this.name = name;
      this.creator = creator;
      this.products = products;
  }
  //静态方法
  static getInstance(name, creator, products) {
    if(!this.instance) {
      this.instance = new SingletonApple(name, creator, products);
    }
    return this.instance;
  }
}

let appleCompany = SingletonApple.getInstance('苹果公司', '乔布斯', ['iPhone', 'iMac', 'iPad', 'iPod']);
let copyApple = SingletonApple.getInstance('苹果公司', '阿辉', ['iPhone', 'iMac', 'iPad', 'iPod'])

console.log(appleCompany === copyApple); //true
```


#### 观察者模式
观察者模式，又叫发布-订阅者模式或消息机制，通过定义一种一对多的关系，让多个观察者对象同时监听某个主体对象，这个主体对象的状态发生变化时会通知所有的观察者对象，使得它们能自动更新自己。
```js
'use strict';

var Observer = (function(){
    // 定义静态私有变量message
    let _message = Object.create(null);
    return {
        subscribe: function(type,fn){
            if(!_message[type]){
                _message[type] = [fn];
            }else{
                _message[type].push(fn);
            }
        },
        unsubscribe: function(type,fn){
            // 如果消息队列不存在或不是数组，则直接返回
            if(!_message[type] || !Array.isArray(_message[type])){
                return ;
            }
            for(let i=_message[type].length-1;i>=0;i--){
                if(_message[type][i]===fn){
                    _message[type].splice(i,1);
                }
            }
        },
        publish: function(type){
            if(!_message[type]) return;
            let cbs = _message[type];
            let args = [].slice.call(arguments,1);
            for(let i=0;i<cbs.length;i++){
                cbs[i].apply(this,args);
            }
        }
    }
})();
```



### 原型链
#### 是什么
由相互关联的原型组成的<span style="color: blue">链状结构</span>

#### 原型对象
##### 定义
每一个JavaScript对象(null除外)在创建的时候就会<u>与之关联另一个对象</u>，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。

#### 原型链查找规则概述
- 当我们要获取一个对象的属性时,浏览器会先在对象自身中寻找
- 如果有则直接使用,如果没有则去对象的原型中寻找
- 找到了则使用,没有则去原型的原型里去寻找.以此类推, 直到找到Object的原型,如果依然没有找到则返回undefined
- Object的原型是所有对象的原型,它的原型没有原型

#### 原型链图例

![chian prototype](https://programmer.help/images/blog/d59acf5d5aca9dad1461354443dd7c17.jpg)








### 继承
#### **原型链继承**
> 子类原型 = 父类实例

缺点: 
 1.引用类型的属性被所有实例共享.(基本类型的值更改后不会被共享, 因为其他实例初始化后,)
 2.子类不能向父类中传参

#### **借用构造函数继承**
> 在子类构造函数中,通过call()/apply()调用父类构造函数

优点:
* 避免原型链继承中引用类型的属性被所有实例共享
* 可以在子类中向父类传参

缺点:
* 方法都在父类构造函数中定义,每次创建实例都会创建一遍方法
* 只能继承父类的实例属性和方法,不能继承其原型的属性/方法

#### 组合继承
> 原型继承 + 借用构造函数继承

优点: 融合原型链继承和构造函数的优点
缺点: 会调用两次父类的构造函数: 一次在子类的构造函数中call方法执行了一遍; 一次在在子类原型实例化为父类的实例时执行了一遍
```js
//方式一: 基于构造函数的继承: 原型链 + 借用构造函数的组合式继承
- 借用父类型构造函数: Person.call(this, name, age)
- 让子类的原型为父类的实例: Student.prototype = new Person()
- 让子类型原型的构造构造函数为子类型: Student.prototype.constructor = Student

// 父类型
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.fn = function () { console.log('aaa')}
Person.prototype.sayHello = function () {
  console.log(`我叫{this.name},年龄{this.$age}`);
}

// 子类型
function Student(name, age, price) {
  Person.call(this, name, age);
  this.price = price;
}
// 让子类原型为父类的实例
Student.prototype = new Person();
// 让原型对象的构造器为子类型
Student.prototype.constructor = Student;

Student.prototype.sayHello = function () {
  console.log(`名字${this.name},年龄${this.age},身价${this.price}`);
}

const s = new Student('tom', 12, 100)
s.sayHello();
s.fn();

//方式二: 基于class/类的继承
- 子类 extends 父类: class Teacher extends Person2
- 子类构造器中调用父类的构造: super(name, age)
 

class Teacher extends Person2 {
    constructor (name, age, course) {
      super(name, age)
      this.course = course
      Teacher.prototype.count++
    }
```



#### 原型式继承

> 将传入的对象赋值给临时构造函数的原型，然后返回这个临时构造函数的一个实例。
> 本质上，是对传入的对象执行了一次浅复制.

```javascript
function object(o) {
  function F()
  F.prototype = o
  return new F()
}
```

缺点:
跟原型链继承一样., 包含引用类型的属性值始终都会被所有实例共享

#### 寄生式继承

> 创建一个仅用于封装继承过程的函数,该函数在内部来增强对象(例如添加方法),最后返回对象
```javascript
function createObj(o) {
  let clone = Object.create(o)
  clone.sayName = function() {
    console.log('hi')
  }
  
  return clone;
}
```

缺点: 
跟借用构造函数模式一样,每次创建对象都会创建一遍方法


#### 寄生组合式继承

> 原型继承 + 借用父类构造函数 + 原型

组合式继承的最大缺点是会调用两次父构造函数. 一次是设置子类型实例的原型时;一次是创建子类实例时.
如何避免在子类构造函数中的重复调用呢?

```javascript
function Parent(name) {
  this.name = name;
  this.corlors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  console.log(this.name);
}

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

//关键步骤
function F() {}
F.prototype = Parent.prototype;
Child.prototype = new F();

let child1 = new Child('kevi', '18');
```

封装下这个方法
```javascript
function object(o) {
  function F() {};
  F.prototype = o;
  return new F();
}

function prototype(child, parent) {
  let prototype = object(parent.prototype);
  prototype.constructor = child;
  child.prototype = prototype;
}
```

> 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。


### 深拷贝与浅拷贝



### 面向对象的3特征
- 封装:
  - 将可复用的代码用一个结构包装起来, 后面可以反复使用
  - js的哪些语法体现了封装性: 函数 ==> 对象 ==> 模块 ==> 组件 ==> 库
  - 封装都要有个特点: 不需要外部看到的必须隐藏起来, 只向外部暴露想让外部使用的功能或数据
- 继承
  - 为什么要有继承? 复用代码, 从而减少编码
  - js中的继承都是基于原型的继承: ES6的类本质也是
  - 编码实现: 原型链+借用构造函数的组合 / ES6的类继承
- 多态: 多种形态
  - 理解
    - 声明时指定一个类型对象, 并调用其方法,
    - 实际使用时可以指定任意子类型对象, 运行的方法就是当前子类型对象的方法
  - JS中有多态:(去看class中的笔记)
    - 由于JS是弱类型语言, 在声明时都不用指定类型
    - 在使用时可以指定任意类型的数据 ==> 这已经就是多态的体现了





### 防抖节流原理及应用

#### 使用背景
如果是复杂的回调函数或是 ajax 请求呢? 假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。出现防抖和节流两种方案.

(高频操作导致一定时间内不能实现函数的全部功能,进而导致卡顿)

#### 应用场景
**防抖**
防抖是指在一定时间内，如果连续触发同一事件，只会执行一次事件处理函数，并且是在最后一次事件触发之后一段时间开始执行。比如下拉加载更多，在用户频繁快速滚动的情况下，只有在用户停止滚动操作，并且停留一段时间后（如300毫秒），才会请求新数据。
使用场景:
* 输入框输入并触发搜索功能时；
* 窗口大小调整，调整结束后才更新布局
* 按钮多次点击，仅仅触发一次事件。

**节流**
节流是指在一定时间内，只能触发一次事件处理函数。比如鼠标连续滚动页面时，如果不加以控制，会造成页面不停的滚动，甚至卡顿。通过节流函数控制，能够让滚动事件的触发变得更加平滑。在这种情况下，事件处理函数会在指定时间内定时执行，将事件的触发频率限制为每隔一定时间响应一次，保证页面滚动的流畅性和减轻浏览器资源消耗和溢出。
使用场景:
* 鼠标不停地拖拽某个元素时；
* 页面滚动加载数据的情况下，滚动时数据量过大；
* 拖动元素变形或改变位置等，触发过程操作不发生过为间隔性的很小的操作。


#### 防抖原理
* 在事件<span style="color:red">触发 n 秒后才执行</span>;
* 如果你在一个事件触发的 n 秒内又触发了这个事件，以新的事件的时间为准，n 秒后才执行.
```javascript
function debounce(fn, wait) {
  let timeId
  return function() {
    clearTimeout(timeId)
    timeId = setTimeout(fn, wait)
  }
}

//2 version  修复this 与 事件对象传递
function debounce2(fn, wait) {
  let timeId
  return function() {
    if (timeId) clearTimeout(timeId)
    let thisArg = this
    let args = arguments
    timeId = setTimeout(() => fn.apply(thisArg, args), wait)
  }
}

//3 version 立即执行  
function debounce3(fn, wait, immediate) {
  let timeId
  return function() {
    let thisArg = this, args = arguments
    
    if (timeId) clearTimeout(timeId)
   	
    if (immediate) {  //这个立方总是理解不好
      let callNow = !timeId
      timeId = setTimeout(() => {timeId = null} , wait)
      if (callNow) fn.apply(thisArg, args)
    } else {
      timeId = setTimeout(() => {fn.apply(thisArg, args)}, wait)
    }
  }
}


//其他
/* 
实现函数防抖的函数
*/
function debounce(callback, delay) {
  return function (event) {
    console.log('debounce 事件...')
    
    // 清除待执行的定时器任务
    if (callback.timeoutId) {
      clearTimeout(callback.timeoutId)
    }
    // 每隔delay的时间, 启动一个新的延迟定时器, 去准备调用callback
    callback.timeoutId = setTimeout(() => {
      callback.call(this, event)
      // 如果定时器回调执行了, 删除标记
      delete callback.timeoutId
    }, delay)
  }
}



//使用案例
<span>节流input表单:</span><input id="inputNode" />
    
let inputNode = document.getElementById('inputNode');
function ajax(content){console.log('ajax request'+content)};

function debounce(callback,delay){
    //n秒内又触发,则会重新计时
    if(callback.timeoutId){ 
        clearTimeout(callback.timeoutId)
    }
    callback.timeoutId = setTimeout(()=>{
        callback(event);
        //callback.call(this,event)
        delete callback.timeoutId;
    },delay);  
}

let debounceAjax = debounce(ajax, 3000);
inputNode.addEventListener('keyup',function(e){
    debounceAjax(e.target.value)
})
```



#### 节流原理
<span style="color:red">每隔一段时间只执行一次事件</span>。
节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。
```js
//时间戳
function throttle(fn, wait) {
  let ctx, args;
  let start = 0
  return function() {
    let now = +new Date()
    ctx = this
    args = arguments
    
    if (now - start > wait) {
      fn.apply(ctx, args)
      start = now
    }
  }
}
//定时器
function throttle(fn, wait) {
  let timeId, start = 0
  return function() {
    let thisArg = this
    let args = arguments
    
    if (!timeId) {
      timeId = setTimeout(() => {
        timeId = null
        fn.apply(thisArg, args)
      }, wait)
    }
  }
}

//比较两个方法：

//1. 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行
//2. 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件

//时间戳 + 定时器方案


/* 
实现函数节流的函数
*/

function throttle(callback, delay) {
  let start = 0 // 必须保存第一次点击立即调用
  return function (event) { // 事件回调函数
      // this是发生事件的dom元素
    console.log('throttle 事件')
    const current = Date.now()
    if (current - start > delay) { // 从第2次点击开始, 需要间隔时间超过delay
      callback.call(this, event)
      // 将当前时间指定为start, ==> 为后面的比较做准备
      start = current
    }
  }
}

<span>节流input表单:</span><input id="inputNode" />
    
let inputNode = document.getElementById('inputNode');
function ajax(content){console.log('ajax request'+content)}

function throttle(callback,delay){
    let start = 0;
    return function(event){
        let current = Date.now();
        if(current-start>delay){
            callback.call(this,event);  //用不用call, 不用
            start = current;
        }
    }
}

let throttleAjax = throttle(ajax,2000);
inputNode.addEventListener('keyup', function(e){
    throttleAjax(e.target.value)
})

```



### 白屏时间
白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。

Performance 接口可以获取到当前页面中与性能相关的信息,该类型的对象可以通过调用只读属性 Window.performance 来获得。

performance.timing.navigationStart: PerformanceTiming.navigationStart 是一个返回代表一个时刻的 unsigned long long 型只读属性，为紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。

所以将以下脚本放在 `</head>` 前面就能获取白屏时间。

```html
<script>
	new Date() - performance.timing.navigationStart
</script>
```



### 模块化

ES6模块的暴露和引入语法

暴露: 分别暴露, 暴露对象, 默认暴露

```javascript
// 分别暴露
export const a = 'a'
export const b = 'b'

//暴露对象
const c = 'c'
const d = 'd'
export {
	c,
  d as dd
}

//默认暴露
export default function foo() {}

```

引入: 通用引入; 解构赋值形式引入; 简便导入

```javascript
import * as m1from './m1'

//解构赋值形式引入
import {default as aaa} from 'xx.js'

//简便导入
import _ from 'lodash'
```







### 异步

#### 事件循环
>https://zhuanlan.zhihu.com/p/33058983
>https://juejin.cn/post/6992167223523541023

##### 背景
当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为==执行栈==。

当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。

从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。

以上的过程说的都是同步代码的执行。

那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——**事件队列（Task Queue）**。

#### 事件循环
* js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行**执行栈**中的其他任务。
* 当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为**事件队列**。
* 被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。
	* 如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入**执行栈**中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。(一种角度)
	* 当执行栈中所有任务处理完后，会先去微任务队列中检查事件是否存在，如果存在会依次执行微任务队列中事件对应的回调，直到为空。然后去宏任务队列中取出一个事件，把对应的回调加入当前执行栈，当执行栈中的所有任务都执行完后，检查微任务队列中是否有事件存在。无限重复.(另一种角度)
这就是这个过程被称为“事件循环（Event Loop）”的原因。

#### 延伸,微任务早于宏任务先执行
在JavaScript中，宏任务和微任务的执行时机不同，对应于不同类型的异步操作。

宏任务包括setTimeout、setInterval、I/O操作、UI交互事件等。当这些操作被触发后，我们编写的回调函数会被添加到宏任务队列中，等待JavaScript引擎从队列中取出并执行，这个过程中宏任务一般需要等待一个事件循环才能执行。

而微任务包括Promise的resolve和reject，MutationObserver等。这些操作会在当前任务执行完成后，立即执行它们的回调函数，也就是优先级比宏任务高，在同一个事件循环中，微任务的回调永远在下一个宏任务之前执行。

当事件循环进入一个新循环时，先执行所有可用的微任务，然后执行宏任务队列中的第一个任务。微任务可以直接执行，是因为它们是依次添加到单独的微任务队列中，而宏任务时添加到同一个宏任务队列中。事件循环按照微任务优先级先执行所有微任务，这样可以保证微任务的回调在宏任务之前被执行。然后在执行完所有的微任务后再取出宏任务队列中的第一个任务，将它的回调函数放到执行栈中执行。

![](https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_720w.webp)

图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。



#### 宏任务和微任务

##### 概述
* 宏任务和微任务是两种不同类型的异步任务
* 宏任务和微任务的执行顺序是：
	* 从宏队列中取出第一个宏任务（一般是script整体代码）执行，直到完成。
	* 检查微队列，如果有微任务，就依次执行所有的微任务，直到清空或者达到最大限制（浏览器不同）
	* 执行UI渲染，更新界面。
	* 重复以上步骤，从宏队列中取出下一个宏任务执行，然后再检查微队列，以此类推。
* 宏任务一般会在每次tick的开始或者结束时执行，而微任务一般会在每次tick中的同步代码执行完毕后立即执行。因此，微任务相比宏任务会更快地得到执行。


##### 分类
**宏任务**
script (整体代码)
setTimeout/setInterval
UI rendering/UI事件
postMessage，MessageChannel
setImmediate，I/O（Node.js 环境）

**微任务：**
`Promise.then/catch/finally`
async/await
MutationObserver
process.nextTick（Node.js 环境）

#### 实例
```js
setTimeout(() => {
    console.log("0")
  }, 0)
  new Promise((resolve,reject)=>{
    console.log("1")
    resolve()
  }).then(()=>{        
    console.log("2")
    new Promise((resolve,reject)=>{
      console.log("3")
      resolve()
    }).then(()=>{      
      console.log("4")
    }).then(()=>{       
      console.log("5")
    })
  }).then(()=>{  
    console.log("6")
  })

  new Promise((resolve,reject)=>{
    console.log("7")
    resolve()
  }).then(()=>{         
    console.log("8")
  })
```


#### 异步加载JS脚本的方法
>https://github.com/Easay/issuesSets/issues/122

**方法一：给script标签添加defer属性**
添加了defer属性，js脚本会异步加载，但会等到html解析完成后，在window.onload事件之前执行。
添加了defer属性的js文件执行的顺序和在文档中定义的顺序一样。
```html
<script src="../your_file.js" defer></script>
```
**方法二：给script标签添加async属性**
async属性会让js并行下载，但是js文件下载完成之后立刻执行无论html是否解析完毕
添加了async属性的js文件执行顺序不能保证
```js
<script src="../your_file.js" async></script>
```
**方法三：动态添加script标签**
和img标签不一样，设置了script的src属性并不会开始下载，而是要添加到文档中Js文件才会开始下载
```js
let script = document.createElement('script');
script.type = 'text/javascript';
script.src = 'your_file.js';
// 只有添加到html文件中才会开始下载
document.body.append(script);
```
问题⚠️：异步加载script的目的是不对html的渲染造成阻塞，如果脚本中有操作dom的行为，则不能进行。但动态添加script标签需要获取body，所以该script代码段放的位置不能在head标签中，至少要放到body标签内。

**方法四：使用xhr脚本注入**
会受到同源策略的限制
```js
let xhr = new XMLHttpRequest()
xhr.open('get', './01.extra.js', true)
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            let script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = './01.extra.js';
            script.text = xhr.responseText;
            console.log(xhr.responseText)
            // 只有添加到html文件中才会开始下载
            document.body.append(script);
        }
    }
}
xhr.send(null);

```


#### 限制并发数（异步并发控制）?
>https://github.com/Easay/issuesSets/issues/143

```js
/**
 *
 * @param { 并发限制 } poolLimit
 * @param { promise 数组 } array
 * @param { callback } iteratorFn
 */
function asyncPool(poolLimit, array, iteratorFn) {
    let i = 0
    const ret = []
    const executing = []
    const enqueue = function () {
        // ① 边界条件，array 为空或者 promise 都已达到 resolve 状态
        if (i === array.length) {
            return Promise.resolve()
        }
        const item = array[i++]

        // ② 生成一个 promise 实例，并在 then 方法中的 onFullfilled 函数里返回实际要执行的 promise，
        const p = Promise.resolve().then(() => iteratorFn(item, array))
        ret.push(p)

        // ④ 将执行完毕的 promise 移除
        const e = p.then(() => executing.splice(executing.indexOf(e), 1))
        // ③ 将正在执行的 promise 插入 executing 数组
        executing.push(e)
        // console.log(executing)
        let r = Promise.resolve()
        // ⑥ 如果正在执行的 promise 数量达到了并发限制，则通过 Promise.race 触发新的 promise 执行
        if (executing.length >= poolLimit) {
            r = Promise.race(executing)
            // console.log("r:")
            // console.log(r)
        }

        // ⑤ 递归执行 enqueue，直到满足 ①
        return r.then(() => enqueue())
    }
    return enqueue().then(() => Promise.all(ret))
}

const timeout = i => new Promise(resolve => setTimeout(() => {
    console.log(i)
    resolve(i)
}, i));
asyncPool(2,[1000,5000,3000,2000],timeout).then(results => {
    console.log(results)
})
```





### Promise

#### 概述

> Promise 是异步编程的一种解决方案，比传统的回调函数和事件更好。
> 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。类比为订阅演唱会的时间地址.

#### 状态
Promise有三种状态，分别是：Pending（进行中）， Fulfilled(Resolved已完成)，Rejected (已失败)。
Promise从Pending状态开始，如果成功就转到成功态，并执行resolve回调函数；如果失败就转到失败状态并执行reject回调函数。

#### 优点
- 指定回调函数的时机更加灵活: 在异步操作启动前或完成后, 指定回调函数得到异步结果
- promise链式调用解决嵌套回调的回调地狱问题 
```js
// 异步操作启动前执行操作
let promise = doSomething()
promise.then(successCallback, failureCallback)

// 异步操作完成后指定回调
let promise = doSomething()
setTimeout(() => {(promise.then(successCallback, failureCallback)), 3000)
```


#### promise.prototype.then()返回值
Promise.then()方法返回一个新的 Promise 对象，它的状态和值取决于 then 中的回调函数的执行结果。具体来说，有以下几种情况：
* 返回一个Promise,其值和状态决定了返回Promise的值和状态
* 返回一个错误, 返回一个失败的Promise,其值为返回的错误
* 其它值 返回一个成功的Promise,其值为其它值



#### Promise-API实现

| 静态方法                     | 作用                                                         | 其他 |
| ---------------------------- | ------------------------------------------------------------ | ---- |
| Promise.all(iterable)        | 传入一个可迭代对象,返回一个promise<br/>* 当所有promise都resolve的时候, 新的 promise 才会 resolve，并且其结果数组将成为新 promise 的结果。<br/>* 当其中一个promise被reject, 立即返回这个reject,忽略其他promise |      |
| Promise.allSettled(iterable) | 返回一个在所有给定的 promise 都已经`fulfilled`或`rejected`后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。<br/> 适用于多个彼此不依赖的异步任务settled时, 或想知道每个promise的结果时 |      |
| Promise.any()                | 接收一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)可迭代对象，只要其中的一个 `promise` 成功，就返回那个已经成功的 `promise` 。 |      |
| Promise.race                 | 返回一个Promise,一旦迭代器中的某个promise解决或拒绝,返回的promise就会解决或拒绝. |      |





##### Promise.all

##### 概述
all方法接受一个或多个promsie（以数组方式传递），返回一个新promise，该promise状态取决于传入的参数中的所有promsie的状态：
当所有promise都完成时，返回的promise完成，其最终值为由所有完成promsie的最终值组成的数组；
当某一promise被拒绝时，则返回的promise被拒绝，其拒绝原因为第一个被拒绝promise的拒绝原因；

##### 代码实现
```javascript
//20220724
Promise.prototype.all = function (promises) {
	return new Promise((resolve, reject) => {
		// 判断是否为可迭代对象
		if (!Array.isArray(promises)) {
			throw new TypeError('promises must be an iterable object')
		}

		let resultArr = []
		promises.forEach((promise, idx) => {
			promise.then(
				value => {
					resultArr[idx] = value
					idx === (promises.length - 1) && resolve(resultArr)
				 },
				error => { 
					reject(error)
				}
			)
		})
	})
}
```

##### 案例
```js
function p1(){
    var promise1 = new Promise(function(resolve,reject){
        console.log("p1的第一条输出语句");
        console.log("p1的第二条输出语句");
        resolve("p1完成");
    })
    return promise1;
}

function p2(){
    var promise2 = new Promise(function(resolve,reject){
        console.log("p2的第一条输出语句");
        setTimeout(()=>{console.log("p2的第二条输出语句");resolve("p2完成")},2000);

    })
    return promise2;
}

function p3(){
    var promise3 = new Promise(function(resolve,reject){
        console.log("p3的第一条输出语句");
        console.log("p3的第二条输出语句");
        resolve("p3完成")
    });
    return  promise3;
}

Promise.all([p1(),p2(),p3()]).then(function(data){
    console.log(data);
})


//输出结果
p1的第一条输出语句
p1的第二条输出语句
p2的第一条输出语句
p3的第一条输出语句
p3的第二条输出语句
p2的第二条输出语句
['p1完成','p2完成','p3完成']
```

##### Promise.allSettled

```javascript
function allSettled(promises) {
  if (promises.length === 0) return Promise.resolve([])
  
  const _promises = promises.map(
    item => item instanceof Promise ? item : Promise.resolve(item)
    )
  
  return new Promise((resolve, reject) => {
    const result = []
    let unSettledPromiseCount = _promises.length
    
    _promises.forEach((promise, index) => {
      promise.then((value) => {
        result[index] = {
          status: 'fulfilled',
          value
        }
        
        unSettledPromiseCount -= 1
        // resolve after all are settled
        if (unSettledPromiseCount === 0) {
          resolve(result)
        }
      }, (reason) => {
        result[index] = {
          status: 'rejected',
          reason
        }
        
        unSettledPromiseCount -= 1
        // resolve after all are settled
        if (unSettledPromiseCount === 0) {
          resolve(result)
        }
      })
    })
  })
}
```



##### Promise.any

```javascript
function any(promises) {
  // return a Promise, which resolves as soon as one promise resolves
  return new Promise((resolve, reject) => {
    let isFulfilled = false
    const errors = []
    let errorCount = 0
    promises.forEach((promise, index) => promise.then(
      (data) => {
      if (!isFulfilled) {
        resolve(data)
        isFulfilled = true
      }
    }, 
      (error) => {
      errors[index] = error
      errorCount += 1

      if (errorCount === promises.length) {
        reject(new AggregateError('none resolved', errors))
      }
    }))
  })
}

//https://github.com/azl397985856/fe-interview/issues/125
Promise.any = ps => new Promise((resolve, reject) => {
  ps.forEach((p, idx) => p.then(resolve)).catch(err => idx === (ps.length - 1) && reject(new Aggregate('none resolved')))
})
```



##### Promise.race

```javascript
Promise.race2 = function(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach(promise => Promise.resolve(promise).then(resolve, reject))
  })
}
```


#### Promise面试题
>https://github.com/Easay/issuesSets/issues/77


##### 如何改变Promise的状态

```js
//3种方法
1.resolve() 状态由pending变为fulfilled
2.reject()  状态由pending变为rejected
3.抛出异常   状态由pending变为rejected
```



##### Promise状态改变和指定回调函数(then)谁先谁后

```js
1.都有可能. 正常时先指定回调再改变状态
2.先改变状态再指定回调的方法//同步
 2.1 直接调用resolve()/reject()
 2.2 延迟更长时间才调用then()
    let p = new Promise((resolve, reject)=>{
        setTimeout(()=>{resolve('ok')},1000);
    })
    setTimeout(()=>{p.then(value=>{console.log(value)})},3000)
 
3.先指定回调(先调用then方法)再改变状态//执行器种直接异步调用resolve()/reject()
   let p = new Promise((resolve,reject) => {
        setTimeout(function(){
            resolve('ok')
        },1000)
     })
     p.then(value => {
         console.log(value);
     })

4.什么时候得到数据?
4.1 如果先指定的回调函数,当状态发生改变时,调用回调函数,得到数据
4.2 如果先改变的状态,在指定回调函数时,回调函数就会调用,得到数据
```



##### Promise.then()返回新的Promise的结果状态由什么决定

```js
//then方法的返回结果是一个promise对象
(1)	简单表达: 由then()指定的回调函数执行的结果决定(执行结果就是函数的返回值)
(2)	详细表达:                                    
①	如果抛出异常, 新promise变为rejected, reason为抛出的异常/throw抛出的值
②	如果返回的是非promise的任意值, 新promise变为fulfilled(resolved) 值为返回值
③	如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果,其值也会为then方法的返回值.
```



##### Promise异常穿透

```js
(1)	当使用promise的then链式调用时, 可以在最后指定失败的回调 
(2)	前面任何操作出了异常, 都会传到最后失败的回调中处理
```



##### Promise中断链条

```js
//返回一个pending状态的promise对象  return new Promise(()=>{})
//传一个错误的promise对象值,会被catch捕获,如果没有catch方法会报错
```


##### Promise.all如何将所有promise状态都保存下来
>https://github.com/Easay/issuesSets/issues/141

可以通过将所有primose状态都以resolved结束，即使内部请求挂掉被catch捕获到错误，但最后返回一个具体的值标识错误态即可。
```js
// ?
async function initAll() {
	const [
			loginComphasInited,
			activityConfig,
			styleData,
	] = await Promise.all([
			this.getLoginComp(),
			this.getActivityConfig(),
			this.getMarketingConfig(),
	])
	const { hasActivityConfig, hasEnded } = activityConfig
	if(!loginComphasInited || !hasActivityConfig) {
			this.handleError()
			return
	}
	if(hasEnded) {
			setPageSatus()
	}
}


async function activityConfig(){
	try{
		const { contracts, hasEnded } = await this.$apis.post()
		this.contracts = contracts || []
		return {
				hasActivityConfig: true,
				hasEnded,
		}
	}catch(err){
			return {
					hasActivityConfig: false,
			}
	}
}
```


##### 打印顺序
> https://juejin.cn/post/7055460626923012104
> https://juejin.cn/post/6945319439772434469


```js
setTimeout(() => {
    console.log("0")
  }, 0)
  
new Promise((resolve,reject)=>{
    console.log("1")
    resolve()
  }).then(()=>{        
    console.log("2")
    new Promise((resolve,reject)=>{
      console.log("3")
      resolve()
    }).then(()=>{      
      console.log("4")
    }).then(()=>{       
      console.log("5")
    })
  }).then(()=>{  
    console.log("6")
  })

new Promise((resolve,reject)=>{
    console.log("7")
    resolve()
  }).then(()=>{         
    console.log("8")
  })
```


##### 如果100个请求,使用Promise怎么控制并发  ??
>https://juejin.cn/post/7219961144584552504

题目
```js
// sendRequest(requestList:, limits, callback): void
sendRequest(
    [
        () => request('1'),
        () => request('2'),
        () => request('3'),
        () => request('4')
    ],
    3, // 并发数
    (res) => {
        console.log(res)
    }
)

// 其中 request 可以是：
function request(url, time = 1) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('请求结束：' + url);
            if (Math.random() > 0.5) {
                resolve('成功')
            } else {
                reject('错误')
            }
        }, time * 1e3)
    })
}
在格式化后的代码中，我们将每个参数放在新的一行，并使用适当的缩进来提高可读性。此外，我们还添加了注释来说明每个参数的作用。
```

概念
并发(Concurrency):同一时间段内多个任务都在进行,但不一定同时进行。每个任务会互相切换执行,由操作系统根据一定的调度算法决定哪个任务该执行。
并发控制: 意思是多个并发的任务，一旦有任务完成，就立刻开启下一个任务
切片控制: 将并发任务切片的分配出来，比如10个任务，切成2个片，每片有5个任务，当前一片的任务执行完毕，再开始下一个片的任务，这样明显效率没并发控制那么高了

并行(Parallelism):多个任务同时进行,真正意义上的同时进行。一般需要多核CPU才能实现并行。
```js
// 两个任务依次执行,互相切换
console.log('Start task 1');
setTimeout(() => console.log('Task 1 finished'), 1000);

console.log('Start task 2'); 
setTimeout(() => console.log('Task 2 finished'), 1000);
```
在多核CPU上,并行的例子可能输出:
```js
并发和并行是两个概念:

并发(Concurrency):同一时间段内多个任务都在进行,但不一定同时进行。每个任务会互相切换执行,由操作系统根据一定的调度算法决定哪个任务该执行。

并行(Parallelism):多个任务同时进行,真正意义上的同时进行。一般需要多核CPU才能实现并行。

例子:

并发(Concurrency)的例子:
```js
// 两个任务依次执行,互相切换
console.log('Start task 1');
setTimeout(() => console.log('Task 1 finished'), 1000);

console.log('Start task 2'); 
setTimeout(() => console.log('Task 2 finished'), 1000);
```

并行(Parallelism)的例子,需要在多核CPU上执行:
```js
// 两个任务同时执行
console.log('Start task 1');
setTimeout(() => console.log('Task 1 finished'), 1000);

console.log('Start task 2');
setTimeout(() => console.log('Task 2 finished'), 1000);
```

在单核CPU上,上面的两个例子的输出都是:

```
Start task 1 
Start task 2
Task 1 finished
Task 2 finished
```

但在多核CPU上,并行的例子可能输出:
```js
Start task 1 
Start task 2 
Task 1 finished
Task 2 finished 
```
或
```js
Start task 1
Task 1 finished
Start task 2
Task 2 finished
```

这是因为两个任务可以同时执行,不需要互相切换.

```text
首先执行能执行的并发任务，根据并发的概念，每个任务执行完毕后，捞起下一个要执行的任务。

将关键步骤拆分出合适的函数来组织代码

1.  循环去启动能执行的任务
    
2.  取出任务并且推到执行器执行
    
3.  执行器内更新当前的并发数，并且触发捞起任务
    
4.  捞起任务里面可以触发最终的回调函数和调起执行器继续执行任务
```

```js
function sendRequest(requestList, limits, callback) {
  const promises = requestList; // 取得请求list
  const concurrentNum = Math.min(limits, requestList.length); // 得到开始时，能执行的并发数
  let concurrentCount = 0; // 当前并发数 

  // 第一次先跑起可以并发的任务
  const runTaskNeeded = () => {
    let i = 0;
    while (i < concurrentNum) {
      i++;
      runTask();
    }
  };

  // 取出任务并且执行任务
  const runTask = () => {
    const task = promises.shift();
    task && runner(task);
  };

  // 执行器
  // 执行任务，同时更新当前并发数
  const runner = async (task) => {
    try {
      concurrentCount++;
      await task();
    } catch (error) {
    } finally {
      // 并发数--
      concurrentCount--;
      // 捞起下一个任务
      picker();
    }
  };

  // 捞起下一个任务
  const picker = () => {
    if (concurrentCount < limits && promises.length > 0) {
      // 任务队列里还有任务并且此时还有剩余并发数的时候 执行
      // 继续执行任务
      runTask();
      // 队列为空的时候，并且请求池清空了，就可以执行最后的回调函数了
    } else if (promises.length == 0 && concurrentCount == 0) {
      // 执行结束
      callback && callback();
    }
  };

  // 入口执行
  runTaskNeeded();
}
```

另一种实现
核心代码是判断是当你 【有任务执行完成】 ，再去判断是否有剩余还有任务可执行。可以先维护一个pool（代表当前执行的任务），利用await Promise.race这个pool，不就知道是否有任务执行完毕了吗？
```js
async function sendRequest(requestList, limits, callback) {
  // 维护一个promise队列
  const promises = [];
  // 当前的并发池,用Set结构方便删除
  const pool = new Set(); // set也是Iterable<any>[]类型，因此可以放入到race里

  // 开始并发执行所有的任务
  for (let request of requestList) {
    // 开始执行前，先await 判断 当前的并发任务是否超过限制
    if (pool.size >= limits) {
      // 这里因为没有try catch ，所以要捕获一下错误，不然影响下面微任务的执行
      await Promise.race(pool)
        .catch((err) => err);
    }

    const promise = request(); // 拿到promise
    // 删除请求结束后，从pool里面移除
    const cb = () => {
      pool.delete(promise);
    };
    // 注册下then的任务
    promise.then(cb, cb);
    pool.add(promise);
    promises.push(promise);
  }

  // 等待所有promise完成，调用回调函数
  Promise.allSettled(promises).then(callback, callback);
}
```



### async/await
#### 概述
* `async`用来描述`async`函数的.函数的返回值为promise对象.
* promise对象的结果和状态由`async`函数的返回值决定. 返回规则和then方法回调返回结果是一样的.
  * 如果返回结果是非promise类型的值,则返回值是成功的promise
  * 抛出一个错误, 函数的状态为失败状态rejected, 错误值为函数返回值.
  * 如果返回结果是promise类型的值, 则promise的状态和值决定了async这个promise的状态和返回
* await右侧的表达式一般为promise对象, 但也可以是其它的值
    * 如果表达式是promise对象, await返回的是promise成功的值.如果是失败的值,await会把promise的异常抛出, 我们可以使用try..catch捕获错误.
    * 如果表达式是其它值, 直接将此值作为await的返回值
* await...后面的代码相当于放到成功的回调中


#### async/await与promise的关系
- async/await是消灭异步回调的最终方法
- 简化promise对象的使用, 不用再使用then/catch来指定回调函数. 但和Promise并不互斥
- 执行async函数, 返回promise对象,  
  - await相当于promise的then
  - try...catch可捕获异常, 相当于promise的catch







### js的垃圾回收机制
>https://github.com/Easay/issuesSets/issues/91

#### 背景
JS引擎中对变量的存储主要有两种位置：栈内存和堆内存，栈内存存储基本数据类型以及引用数据的内存地址，堆内存储引用类型的数据。

#### 堆内存回收
V8的堆内存回收分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长。

**新生代内存回收机制**
新生代内存容量小，64位系统下仅有32M。新生代内存分为From、To两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From/To，等待下一次回收。
**老生代内存回收机制**
晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中；
标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象；
整理内存碎片：把对象挪到内存的一端




#### 常见的GC算法
引用计数
使用引用计数器，当引用数字为0时立即回收。优点是：发现垃圾立即回收；缺点是：无法回收循环引用的对象。

标记清除
遍历所有对象，标记活动对象；再次遍历所有对象，清除没有标记的对象。将回收的空间加到空闲链表中，方便后面的程序申请使用。

标记整理
在标记和清除之间，添加了内存空间的整理。通过移动对象位置使得空间连续。







#### 性能优化
* 避免使用全局变量
* 减少判断层级
* 减少数据读取次数
* 减少循环体中的活动
* 事件绑定优化
* 避开闭包陷阱

### 内存泄露和内存溢出比较

- 内存溢出
  - 运行程序需要分配的内存超过了系统能给你分配的最大剩余内存
  - 抛出内存溢出的错误，程序中断运行
  - 演示代码

    ```
    const arr = []
    for (let index = 0; index < 100000000; index++) {
    	arr[index] = new Array(1000)
    }
    ```

- 内存泄漏
  - 理解: 当程序中的某个内存数据不再需要使用， 而由于某种原因， 没有被释放
  - 常见情况:
  - 意外的全局变量
```
	function fn () {a = new Array(100000)}
	fn()
```

  - 没有及时清除的定时器
  this.intervalId = setInterval(() => {}, 1000) // clearInterval(this.intervalId) ```
  - 没有及时解绑的监听
  this.bus.bus.on('xxx', this.handle) // this.bus.bus.off('xxx')```
  - 没有及时释放的闭包


### 代码实现

#### 使用setTimeout实现setInterval
>https://github.com/Easay/issuesSets/issues/95
```js
function mySetInterval(fn, delay) {
	function interval() {
		setTimeout(interval, delay)
		fn()
	}
	setTimeout(interval, delay)
}

mySetInterval(() => console.log(1), 1000)


```
//实现clearInterval
```js
let id = 0
let timeMap = {}
const mySetInterval = (cb, time) => {
	let timeId = id;
	id++
	const fn = () => {
		cb()
		timeMap[timeId] = setTimeout(() => {fn()}, time)
	}
	timeMap[timeId] = setTimeout(fn, time)
	return timeId
}

function clearInterval(id) {
	clearTimeout(timeMap[id])
	delte timeMap[id]
}

let newId = mySetInterval(count, 1000)
setTimeout(() => clearInterval(newId), 3000)

function count() {
	console.log('a')
}
```


#### 实现一个准确的倒计时 ?
>https://github.com/Easay/issuesSets/issues/105










## DOM/BOM

### 事件(了解)

**事件是文档或者浏览器窗口中发生的，特定的交互瞬间。**

事件是用户或浏览器自身执行的某种动作，如click,load和mouseover都是事件的名字。

事件是javaScript和DOM之间交互的桥梁。

### 事件流

#### 概述

事件流描述的是从页面中接收事件的顺序

#### 两种事件流模型

事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流

**冒泡型事件流**：事件的传播是从**最特定**的**事件目标**到最不特定的**事件目标**。即从DOM树的叶子到根。**【推荐】**

**捕获型事件流**：事件的传播是从**最不特定**的**事件目标**到最特定的**事件目标**。即从DOM树的根到叶子。



#### DOM事件流

DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束

DOM标准规定事件流包括三个阶段：事件捕获阶段、处理目标阶段和事件冒泡阶段。
- 事件捕获阶段：**实际目标**（\<div>）在捕获阶段**不会接收事件**。也就是在捕获阶段，事件从document到\<html>再到\<body>就停止了。上图中为1~3.
- 处理目标阶段：事件在\<div>上发生并处理。**但是事件处理会被看成是冒泡阶段的一部分**。
- 冒泡阶段：事件又传播回文档。



### 事件绑定方式
- 嵌入dom
```js
<button onclick="func()">按钮</button>
```

- 直接绑定
```js
btn.onclick = function(){}
```

- 事件监听
```js
btn.addEventListener('click',function(){})
```


### 事件冒泡
事件在传递给目标元素后, 会由内向外传递给外层的元素处理

### 事件委托
* 事件委托利用了事件冒泡，不直接给多个子元素绑定多个事件监听, 而是给它们共同的父元素绑定一个监听
* 当操作任意子元素时, 事件会冒泡到父元素上处理
* 使用事件委托可以节省内存。
```javascript
<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>凤梨</li>
</ul>

// good
document.querySelector('ul').onclick = (event) => {
  let target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
  }
}

// bad
document.querySelectorAll('li').forEach((e) => {
  e.onclick = function() {
    console.log(this.innerHTML)
  }
})
```



### event.target/event.currentTarget
Event.target：返回触发事件的元素；
Event.currentTarget：返回绑定事件的元素。

当事件在DOM中传播时，event.target始终指向最初触发事件的元素，而event.currentTarget则随着事件的捕获或冒泡阶段而变化，指向当前处理事件的元素。

例如，如果你在一个ul元素上绑定了一个点击事件，并且点击了其中一个li子元素，那么event.target就是这个li元素，而event.currentTarget就是这个ul元素。

你可以利用event.target来实现事件委托，即通过在父元素上绑定一个事件处理函数来处理子元素的相同类型的事件。







### 事件冒泡与事件委托

#### 1) 事件冒泡的流程
- 基于DOM树形结构
- 事件在目标元素上处理后, 会由内向外(上)逐层传递
- 应用场景: 事件代理/委托/委派

#### 2) 事件委托
- 减少内存占用(事件监听回调从n变为1)
- 动态添加的内部元素也能响应
- 不直接给多个子元素绑定多个事件监听, 而是给它们共同的父元素绑定一个监听
- 当操作任意子元素时, 事件会冒泡到父元素上处理
- 在事件回调中通过event.target得到发生事件的目标元素, 并进行相关处理


### 封装一个绑定事件监听的函数

> [封装事件监听函数_巴拉巴拉小魔仙_的博客-CSDN博客](https://blog.csdn.net/m0_66637749/article/details/122708615)

```js
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
  </head>
  <body>
    <div>
      <button id="btn">按钮</button>
      <ul id="divBox">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
      </ul>
    </div>
    <script>
      function bindEvent(ele, type, selector, fn) {
        if (fn == null) {
          fn = selector
          selector = null
        }

        ele.addEventListener(type, event => {
          const target = event.target
          if (selector) {
            // 代理绑定
            if (target.matches(selector)) {
              fn.call(target, event)
            }
          } else {
            // 普通绑定
            fn.call(ele, event)
          }
        })
      }


      // 普通绑定
      const btn = document.getElementById('btn')
      bindEvent(btn, 'click', function(e) {
        e.preventDefault();
        console.log(this)
        alert(this.innerText)
      })

      // 代理绑定
      const div = document.getElementById('divBox')
      bindEvent(div, 'click', 'li', function(e) {
        e.preventDefault()
        alert(this.innerText)
      })
    </script>
  </body>
</html>

```


### DOM操作查找/添加/删除节点
* 查找节点
* 添加节点
* 删除节点

#### 查找节点
* document.getElementById('#box')
* document.getElementsByTagName('div')
* document.getElementsByClassName('.div')
* document.querySelector('选择器')
* document.querySelectorAll('选择器')

#### 添加节点
* document.createElement("div"); //创建元素节点
* document.createTextNode("我是文本节点");  //创建文本节点
* document.getElementById("test").cloneNode(true) //克隆节点
* node.insertBefore(newNode,refNode);//将一个新的节点newNode插入到node节点的子节点refNode之前，如果`refNode==null`, 则与appendChild类似
* node.replaceChild(newNode,refNode);//用一个新的节点newNode替换原有的node节点中的子节点refNode

#### 删除节点
* node.remove();//删除当前节点
* node.removeChild(refNode);//删除当前节点中指定的子节点，返回被移除的节点


### 前台数据存储

#### 存储方式
- cookie
- sessionStorage
- localStorage



#### localStoarge与sessionStorage比较
- 相同点:
  - 浏览器不能禁用, 请求时不会自动携带
  - 纯浏览器端存储, 
  - 只能保存文本, 如果是对象或数组, 需要转换为JSON
  - API相同:
    - setItem(key, value)
    - getItem(key, value)
    - removeitem(key, value)
- 不同点(关闭浏览器是否会被删除):
  - localStorage保存在本地文件中, 除非编码或手动删除, 否则一直存在
  - sessonStorage数据保存在当前会话内存中, 关闭浏览器则清除

#### sessionStorage同源跨窗口可以共享吗?
只有在本页面中以新页签或窗口打开的同源页面会‘临时复制’之前页面的sessionStorage。
a标签也是同样的效果



#### cookie与localStorage和sessionStorage比较
都是浏览器提供的用于存储数据的技术
* **存储大小不同**：cookie一般只能存储4KB左右的数据，而localStorage和sessionStorage可以存储更大的数据，一般为5MB或更多。
* **数据有效期不同**：cookie可以设置过期时间，如果没有设置，则在浏览器关闭时失效；localStorage始终有效，除非用户手动清除；sessionStorage只在当前浏览器窗口关闭前有效。
* **作用域不同**：cookie在所有同源窗口中都是共享的，并且会随着每次HTTP请求发送到服务器；localStorage也在所有同源窗口中共享，但不会发送到服务器；sessionStorage一般不在不同的浏览器窗口中共享。
* **数据安全性不同**：cookie相对较容易被篡改或窃取，因此不适合存储敏感信息；localStorage和sessionStorage相对较安全，但仍然可能受到XSS攻击

#### cookie与session比较
cookie和session都是用来记录客户状态的机制，但它们有以下几个区别：
* 存储位置不同：cookie数据存放在客户端浏览器中，session数据存放在服务器上。
* 安全性不同：cookie相对较容易被篡改或窃取，因此不适合存储敏感信息；session相对较安全，因为它只能通过特定的sessionID来访问。
* 服务器性能不同：session会占用服务器的内存资源，如果访问量过大，可能会影响服务器的性能；cookie则不会给服务器增加负担。
* 存储容量和有效期不同：单个cookie保存的数据一般不能超过4KB，而且一个站点最多只能保存20个cookie；session则没有明确的上限，但出于对服务器性能的考虑，应该尽量精简和及时删除无用的session。
* 有效期: cookie可以设置过期时间，如果没有设置，则在浏览器关闭时失效；session也有一定的有效期，一般为30分钟，如果超过这个时间没有活动，则会自动失效.




### 重排和重绘
> https://juejin.cn/post/6844904083212468238


#### 重绘重排区别
重绘和重排是浏览器渲染页面的两个过程，它们有以下区别：
* 重绘是指元素的外观发生改变，但不影响布局的情况，例如改变颜色、背景、边框等。
* 重排是指元素的几何属性发生改变，影响了布局的情况，例如改变位置、大小、内容等。
* 重排往往有重绘。因此，在优化页面性能时，应该尽量减少重排和重绘的次数和范围。

#### 哪些操作导致重排
回流主要计算节点的位置和几何信息，那么当页面布局和几何信息发生变化时，就需要回流。
* 浏览器一开始渲染的时候
- 元素位置和尺寸发生改变的时候
- 新增和删除可见的DOM元素
- 内容发生改变（文字数量或图片大小等等）
- 元素字体大小变化。
- 频繁查询布局信息的属性。比如说： offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight


#### 哪些操作会导致重绘
- 更新元素的颜色
- 文本方向
- 阴影

#### 重排优化

##### 1.减少重排范围
* 尽可能直接在目标元素上操作,而不用操作父元素/兄弟元素
* 不使用table布局,1个小改动会造成整个table重新布局

##### 2.减少重排次数
* 样式集中改变 class代替style
* 分离读写操作
* 将DOM元素离线操作
* 使用absolute或fixed脱离文档流
* 优化动画

**样式集中改变**

**分离读写操作**
读操作放在一起,写入操作放在一起

**将DOM离线** !!
* 使用 display:none
* documentFragment
* 复制节点,副本操作,然后替换

```js
//一般操作
const container = document.getElementById('container')
container.style.width = '100px'
container.style.height = '200px'
container.style.border = '10px solid red'
container.style.color = 'red'

//离线后操作
const container = document.getElementById('container')
container.style.width = '100px'
container.style.height = '200px'
container.style.border = '10px solid red'
container.style.color = 'red'
```

**优化动画**
* 动画效果应用position为absolute/fixed
* 启用GPU加速的属性: CSS转换, CSS33D变换transform webgl, 视频

## HTTP

### HTTP报文结构
> https://github.com/Easay/issuesSets/issues/64


1.**起始行(start line)**
* 请求的起始行：请求方法、请求 `Path` 和`HTTP` 版本号 
* 响应的起始行：`HTTP` 版本号、响应状态码以及状态文本描述

2.**请求头(HTTP Headers)**: 指明请求或描述消息正文

3.**空行(empty):** 指示所有关于请求的元数据已经发送完毕

4.**可选的正文(body)**: 包含请求或响应的相关数据, 正文大小由起始行HTTP头指定

起始行和HTTP消息中的HTTP头统称为请求头 而其有效负载被称为消息正文.

<img src="https://cdn.jsdelivr.net/gh/aotushi/image-hosting@master/documentation/HTTPMsgStructure2.6ek1f6fu5hw0.webp" alt="HTTPMsgStructure2" style="zoom: 200%;" />


### 输入网址后发生了什么

> [what-happens-when-zh_CN/README.rst at master · skyline75489/what-happens-when-zh_CN (github.com)](https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst?utm_medium=social&utm_source=wechat_session&from=timeline&isappinstalled=0)

* 合成URL
* DNS域名解析
  * 浏览器缓存--->本地hosts文件--->本地DNS解析器缓存--->本地DNS服务器--->根域名服务器-->顶级域名服务器(com, cn,...)-->权威域名服务器(顶级域名托管商)

* 建立TCP连接
  * 首先，判断是不是https的，如果是: 服务端和客户端的信息传输都会加密
  * 进行三次握手,建立TCP连接
    * 第一次握手：建立连接。客户端发送连接请求报文段
    * 第二次握手：服务器收到报文段。同时，自己还要发送请求信息给客户端
    * 第三次握手：客户端收到服务器的报文段。然后将向服务器发送报文段，客户端服务器更新状态,完成TCP三次握手。

* 客户端发送HTTP请求,服务器处理请求,返回响应结果

* 一方完成数据发送任务.关闭TCP连接,四次挥手
	* 客户端告诉服务器，我不需要再发送数据了。
	* 服务器告诉客户端，我知道你不需要再发送数据了。
	* 服务器告诉客户端，我也不需要再发送数据了。
	* 客户端告诉服务器，我知道你不需要再发送数据了。

* 浏览器渲染
  1.HTML 被 HTML 解析器解析成 DOM 树；
  2.CSS  被 CSS 解析器解析成 CSSOM 树；
  3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree,这一过程称为 Attachment)
  4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
  5.将布局绘制(paint)在屏幕上，显示出整个页面。


### 浏览器如何渲染页面的？

1、HTML被HTML解析器解析成DOM树。 
2、CSS被CSS解析器解析成CSS规则树。 
3、浏览器会将CSS规则树附着在DOM树上，并结合两者生成渲染树Render Tree。 
4、生成布局（flow），浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。 
5、将布局绘制（paint）在屏幕上，显示出整个页面

### GET和POST的区别
**作用**
GET: 用于获取资源。
POST: 用于提交资源。
**数据发送方式**
GET: 通过URL将数据传输到服务器。
POST: 通过HTTP协议body将数据传输到服务器。
**数据发送长度**
GET: 受限于浏览器和服务器的限制，通常最多为2048个字符。
POST: 通常没有大小限制。但是，很多服务器会对提交数据的大小设置一个上限。
**数据发送类型**
GET: 只能发送ASCII字符。
POST: 没有编码限制，可以传输二进制数据。
**处理速度**
GET: 数据通过URL传输，处理速度更快。
POST: 数据通过消息主体传输，处理速度略慢。
**数据缓存**
GET: 可以被缓存，结果可被缓存。
POST: 不能被缓存。
**安全性**
GET: 数据以明文形式出现在URL中，并且被浏览器保存在历史记录中。跨站点脚本利用（XSS）容易利用这种意味着敏感数据不应使用GET传输。
POST: 与GET相比，POST提供更好的安全性，因为数据不可见在URL中，且由于该方法请求的数据存储在HTTP协议的内部，所以不容易被网络上的其他用户获取。


### Accept和Content-Type

Accept请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。 服务器使用 Content-Type 应答头通知客户端它的选择。

```text
Accept: text/html
Accept: image/*
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

1.Accept属于请求头， Content-Type属于实体头。
Http报头分为通用报头，请求报头，响应报头和实体报头。
请求方的http报头结构：通用报头|请求报头|实体报头
响应方的http报头结构：通用报头|响应报头|实体报头

2.Accept代表发送端（客户端）希望接受的数据类型。
比如：Accept：text/xml;
代表客户端希望接受的数据类型是xml类型

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。
比如：Content-Type：text/html;
代表发送端发送的数据格式是html。

二者合起来，
Accept:text/xml；
Content-Type:text/html
即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。


### post常用的数据格式,form-data和json的区别
- application/json: json格式文本
- application/x-www-form-urlencoded: 形如query参数(name=tom&age=12)的文本
- multipart/form-data: 文件上传



### 状态码
| 状态码 | 类别                             | 描述                   |
| ------ | -------------------------------- | ---------------------- |
| 1xx    | Informational（信息状态码）      | 接受请求正在处理       |
| 2xx    | Success（成功状态码）            | 请求正常处理完毕       |
| 3xx    | Redirection（重定向状态码）      | 需要附加操作已完成请求 |
| 4xx    | Client Error（客户端错误状态码） | 服务器无法处理请求     |
| 5xx    | Server Error（服务器错误状态码） | 服务器处理请求出错     |


### Http与Https的区别
* url
* 端口
* 安全性/加密
* 证书: HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书


### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。

可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。

### HTTP连接优化
>https://github.com/Easay/issuesSets/issues/67





### Ajax
#### 概述
Ajax是一种用于创建异步Web应用的技术，它可以在不刷新整个网页的情况下，与服务器交换数据并更新部分网页内容，从而提高用户体验和性能。

Ajax的核心是XMLHttpRequest对象，它可以使用JavaScript向服务器发送请求，并接收服务器的响应。响应的数据格式可以是XML、JSON、文本或其他类型。然后，JavaScript可以使用DOM操作来修改网页内容




#### 使用Ajax的优缺点分别是什么
>https://www.frontendinterviewhandbook.com/javascript-questions#what-are-the-advantages-and-disadvantages-of-using-ajax

**优点**
- 交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。
- 减少与服务器的连接，因为脚本和样式只需要被请求一次。
- 状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。
- 基本上包括大部分 SPA 的优点。

**缺点**
- 动态网页很难收藏
	- URL可能不会随内容变化而更新导致收藏无法访问
	- 动态网页可能依赖临时会话信息/身份验证,收藏无法访问/显示错误
- 如果 JavaScript 已在浏览器中被禁用，则不起作用。
- 有些网络爬虫不执行JavaScript，也不会看到 JavaScript 加载的内容。
- 基本上包括大部分SPA的缺点


#### Ajax和Fetch区别
* 语言支持:ajax 是 XMLHttpRequest 的简写,依赖 XMLHttpRequest 对象,支持 IE5+。fetch 是 Fetch API 的一部分,使用 Promise,支持 IE10+。
* 接口:ajax 使用 XMLHttpRequest 对象,接口相对底层。fetch 使用 Fetch API,接口更简单。例如:
```js
// ajax
const xhr = new XMLHttpRequest()
xhr.open('GET', '/user/12345')
xhr.send()

// fetch
fetch('/user/12345')
```
* 响应格式:ajax 默认返回 XML 响应,需要手动解析。fetch 默认返回 JSON,可以直接使用 .json() 方法解析。
* 错误处理:ajax 使用 onerror 事件捕捉错误。fetch 使用 Promise 的 catch 方法捕捉错误。
* 超时处理:ajax 可以使用 timeout 属性设置超时时间。fetch 使用 Promise 的 catch 可以设置超时。
* 取消请求:ajax 可以使用 abort() 方法取消请求。fetch 的 Promise 对象没有 abort 方法,需要使用 cancelable Promise 实现取消。

```js
//超时
// ajax
const xhr = new XMLHttpRequest()
xhr.timeout = 1000 // 1秒超时
xhr.open('GET', '/user/12345')
xhr.ontimeout = () => {
  console.log('超时!')
}
xhr.send()

// fetch
fetch('/user/12345', {
  timeout: 1000 
})
.catch(err => {
  if (err.message === 'Timeout') {
    console.log('超时!')
  }
})


//取消
const xhr = new XMLHttpRequest()
xhr.open('GET', '/user/12345')
xhr.send()
xhr.abort() // 取消请求

// fetch
const controller = new AbortController()
fetch('/user/12345', { signal: controller.signal })
.then() // ...
controller.abort() // 取消fetch请求
```



#### 封装一个简易的ajax异步请求函数

##### 简洁版(必须)

```js
/* 
xhr + promise 封装一个异步ajax请求的通用函数  简洁版
*/
function ajax(url) {
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const xhr = new XMLHttpRequest()
    // 初始化一个异步请求(还没发请求)func
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function () {
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (xhr.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (xhr.status>=200 && xhr.status<300) {
        // 指定promise成功及结果值
        resolve(JSON.parse(xhr.responseText))
      } else { // 请求失败了
        // 指定promise失败及结果值
        reject(new Error('request error staus '+ request.status))
      }
    }
    xhr.send(null)
  })
}
```

##### 加强版(可选)

```js
/* 
xhr + promise 封装一个异步ajax请求的通用函数  加强版
  返回值: promise
  参数为配置对象
    url: 请求地址
    params: 包含所有query请求参数的对象
    data: 包含所有请求体参数数据的对象
    method: 为请求方式
*/
function axios({url, params={}, data={}, method='GET'}) {
  // 返回一个promise对象
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const request = new XMLHttpRequest()
    
    // 根据params拼接query参数
    let queryStr = Object.keys(params).reduce((pre, key) => {
      pre += `&${key}=${params[key]}`
      return pre
    }, '')
    if (queryStr.length>0) {
      queryStr = queryStr.substring(1)
      url += '?' + queryStr
    }
    // 请求方式转换为大写
    method = method.toUpperCase()
    
    // 初始化一个异步请求(还没发请求)
    request.open(method, url, true)
    // 绑定请求状态改变的监听
    request.onreadystatechange = function () {
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (request.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (request.status>=200 && request.status<300) {
        // 准备响应数据对象
        const responseData = {
          data: JSON.parse(request.response),
          status: request.status,
          statusText: request.statusText
        }
        // 指定promise成功及结果值
        resolve(responseData)
      } else { // 请求失败了
        // 指定promise失败及结果值
        const error = new Error('request error staus '+ request.status)
        reject(error)
      }
    }

    // 如果是post/put请求
    if (method==='POST' || method==='PUT' || method==='DELETE') {
      // 设置请求头: 使请求体参数以json形式传递
      request.setRequestHeader('Content-Type', 'application/json;charset=utf-8')
      // 包含所有请求参数的对象转换为json格式
      const dataJson = JSON.stringify(data)
      // 发送请求, 指定请求体数据
      request.send(dataJson)
    } else {// GET请求
      // 发送请求
      request.send(null)
    }
  })
}
```



### 跨域
#### 概述
跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这种资源一般是由浏览器的同源策略所禁止访问的。
跨域问题的出现是因为浏览器和服务器之间需要进行数据交互，而有些数据又不希望被其他来源的网站访问，所以需要有一种机制来限制或允许跨域请求。

#### 同源策略
同源策略是浏览器为了保护用户隐私和安全而实施的一种安全机制，它要求两个 URL 的协议、域名和端口都相同，才能认为是同源，否则就是跨域。

#### 跨域解决方法
- JSONP
- CORS
- 代理服务器


##### JSONP原理
是什么?
>利用 `<script>` 标签没有跨域限制的特点，通过动态创建 `<script>` 标签，发送带有回调函数名的 GET请求，服务器返回包含该回调函数的数据，浏览器执行该函数并获取数据。
>这种方法只能发送 GET 请求，并且需要服务器端配合


- 前台:
  - `<script src="目标url?callback=fn" />`
  - 声明函数 function fn (data) {}
- 后台
  - 处理请求, 产生需要返回的数据data
  - 读取callback请求参数得到前台处理响应数据的函数名fn
  - 返回执行函数fn的js代码: 'fn(data)'

- 不足
  - 只能处理GET请求
  - 每个请求在后台都要做处理, 麻烦
  ```js
  // 发送jsonp请求的函数
  function jsonp() {
      var script = document.createElement('script')
      script.type = 'text/javascript'
      // 传参并指定回调执行函数为backFn
      script.src = 'http://localhost:4000/getUserInfo?id=100&callback=cbFn'
      document.body.appendChild(script)
  }
  
  // 回调函数, 接收响应数据
  function cbFn(data) {
  	console.log(data)
  }
  ```

  

##### CORS原理

>即跨域资源共享，是一种 W3C 标准，它允许浏览器向跨源服务器发出 XMLHttpRequest 请求。它需要浏览器和服务器同时支持，并且在服务器端设置响应头 Access-Control-Allow-Origin 等字段来允许或拒绝跨域请求。
> 这种方法支持各种类型的请求，并且可以携带 Cookie 等信息。

```js
// 使用cors, 允许跨域, 且允许携带跨域cookie
app.use(function (req, res, next) {
  // console.log('----')
  // 允许跨域的地址
  res.header('Access-Control-Allow-Origin', 'http://localhost:5500')  // 不要是*
  // 允许携带凭证(也就是cookie)
  res.header('Access-Control-Allow-Credentials', 'true')
  // 允许跨域的请求头
  res.set("Access-Control-Allow-Headers", "Content-Type")
  // 放行
  next()
})
```


#### 代理服务器

- 开发环境: 利用webpack-dev-server中的http-proxy-middle  进行正向代理
  - vue脚手架项目: vue.config.js
  - react脚手架项目: package.json
- 生产环境: 利用nigix 进行反向代理





### axios二次封装

#### 第一种
1. 配置通用的基础路径和超时: 
	axios.create({baseURL, timeout})
2. 显示请求进度条
   显示: 准备发请求前显示, 在请求拦截器中执行NProgress.start()
   ​隐藏: 请求结束隐藏, 在响应拦截器成功/失败回调中NProgress.done()

3. 携带token数据
   ​在请求拦截器中, 将token添加到请求头中
4. 成功返回的数据不再是response, 而直接是响应体数据response.data
   ​响应拦截器成功的回调中: return response.data
5. 统一处理请求错误, 具体请求也可以选择处理或不处理
   ​在响应拦截器失败的回调中: alert提示错误信息, return Promise.reject(error)
```js
//
import axios from 'axios';
import Nprogress from 'nprogress';
import 'nprogress/nprogress.css'

const service = axios.create({
    baseURL:'/api',
    timeout:20000
})

service.interceptors.request.use(
  (config)=>{
    Nprogress.start();
    //临时数据标识  token
    let userTempId = store.state.user.userTempId;
    if(userTempId){
        config.headers.userTempId = userTempId;
    }
    let token = store.state.user.token;
    if(token){
        config.headers.token = token;
    }
    return config;
},
  
(error)=>{
    alert(error.message)
 }                                 
)

service.interceptors.response.use(
    (response)=>{
    Nprogress.done();
    return response.data;
	},
    (error)=>{
        Nprogress.done();
        //return new Promise(()=>{})
        return Promise.reject(new Error('请求失败'))
    }
)

export default service;
```


#### 第二种

```js
//axios封装 请求和响应拦截,错误统一处理
import axios from 'axios';
import {Toast} from 'vant';

const service = axios.create({
  baseURL: 'http://127.0.0.1:3000',
  timeout: 6000,
  withCredentials: false //设置跨域是否允许携带凭证(开发环境需要配置，因为要使用跨域；生产环境可能需要将其注释掉！)
});

// 设置post请求头
const contentTypeUTF8 = 'application/x-www-form-urlencoded;charset=UTF-8';
const contentTypeJSON = 'application/json';
service.defaults.headers.post['Content-Type'] = false ? contentTypeUTF8 : contentTypeJSON;

//请求拦截器
service.interceptors.request.use(
  (config) => {
  	Toast.loading({
    	overlay: true,
    	duration: 0,
    	forbidClidk: true,
    	message: '加载中''
  	});
  	return config;
	},
  (error) => {
    Toast.clear();
    Toast({
      message: '请求错误',
      duration: 1000,
      forbidClick: true
    })
    return Promise.reject(error);
  }                           
)

//响应拦截器
service.interceptors.response.use(
	(response) => {
    Toast.clear();
    return Promise.reject(response.data);
  },
  (error) => {
    Toast.clear();
    let {response, message} = error;
    
    //状态码404
    if (response?.status === 404) {
    	Toast({
      	message: '网络请求不存在',
        duration: 1000,
        forbidClick: true
      });
    	return error;
    }
  
  	//网络异常
  	if (!window.navigator.onLine) {
  		Toast({
        message: '请检查网络是否连接正常',
        duration: 1500,
        forbidClick: true
      })
  		return;
		}

		//请求超时
		if (message.includes('timeout')) {
      Toast({
        message: '请求超时',
        duration: 1500,
        forbidClick: true
      })
      return error
    }

		return error
  }
)



/**********************************************
 * get方法，对应get请求 
 * @param url     @type {String}  [请求的url地址] 
 * @param params  @type {Object}  [请求时携带的参数] 
 */
export const axiosGet = ({url, data}) => service.get(url, data);

/********************************************** 
 * post方法，对应post请求 
 * @param url     @type {String}  [请求的url地址] 
 * @param datas  @type {Object}  [请求时携带的参数] 
 */
export const axiosPost = ({url, data}) => service.post(url, data);



/********************************************** 
 * post方法，对应post请求 
 * @param url     @type {String}  [请求的url地址] 
 * @param datas  @type {Object}  [请求时携带的参数] 
 */
// export const post = (url, data) => service.post(url, datas);

// export const post = (url, params) => {
//     return new Promise((resolve, reject) => {
//       if(isAddPassword === 'true'){
      
//         // let authTokenUrl = sessionStorage.getItem("authTokenUrl") ? JSON.parse(sessionStorage.getItem("authTokenUrl")) : {};
//         // let obj = {auth_token: authTokenUrl.authToken ||  ENV.VUE_APP_TOKEN}
//         // params = {...params,...obj}
//         let paramsData = testencrypt(JSON.stringify(params)) 

//         service.post(url,paramsData).then(res => {
//             resolve(res);
//         })
//         .catch(err => {
//             reject(err)
//         })
//       } else {
        
//         service.post(url,params).then(res => {
//           resolve(res);
//         })
//         .catch(err => {
//             reject(err)
//         })
//       }
        
//     });
// }

/********************************************** 
 * put方法，对应put请求 
 * @param {String} url [请求的url地址] 
 * @param {Object} params [请求时携带的参数] 
 */
// export function put(url, params) {
//     return new Promise((resolve, reject) => {
//         service.put(url, JSON.stringify(params))
//             .then(res => {
//                 resolve(res);
//             })
//             .catch(err => {
//                 reject(err)
//             })
//     });
// }


/********************************************** 
 * delete方法，对应delete请求 
 * @param {String} url [请求的url地址] 
 * @param {Object} params [请求时携带的参数] 
 */
// export function del(url, params) {
//     return new Promise((resolve, reject) => {
//         service.delete(url, JSON.stringify(params))
//             .then(res => {
//                 resolve(res);
//             })
//             .catch(err => {
//                 reject(err)
//             })
//     });
// }
```





### RestlessAPI与RestfulAPI// ?
- Restless API  
  - 传统的API, 把每个url当作一个功能操作      /updateUser
  - 同一个url, 后台只进行CRUD的某一种操作
  - 请求方式不决定请求的CRUD操作
  - 一个请求路径只对应一个操作
  - 一般只有GET/POST

- Restful API 
  - 新式的API, 把每个url当作一个唯一资源   /user/2
  - 同一个url, 可以通过不同类型的请求对后台资源数据进行CRUD四种操作
  - 请求方式来决定了请求在后台进行CRUD的哪种操作
    - GET: 查询
    - POST: 添加
    - PUT: 更新
    - DELETE: 删除
  - 同一个请求路径可以进行多个操作
  - 请求方式会用到GET/POST/PUT/DELETE

- 测试: 可以使用json-server快速搭建模拟的rest api 接口


## 手写代码

### 深拷贝

#### 是什么
深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**。

浅拷贝: 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在==栈==中的地址，而不是堆中的数据。两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。

#### 浅拷贝
和深拷贝对应的浅拷贝,JS中的相关方法有:
* `[].slice(0)`
* `[].concat(arr)`
* 扩展运算符
* Object.assign(obj1,obj2)

#### 深拷贝实现方式
- JSON.parse(JSON.stringfy(obj)) 
  -  ===> 问题: 方法/函数会丢失(undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时)
  -  ===> 问题2: 循环引用会出错(死循环)
- 递归遍历
  - 如果是基本类型与函数直接返回, 函数就不会丢失也不会拷贝
  - 如果是对象/数组创建拷贝对象/数组
  - 问题: 循环引用会出错的问题(死循环)
- 使用Map缓存拷贝对象
  - 如果发现一个对象已经产生拷贝对象, 直接返回这人拷贝对象
  - 使用Map存储 ==> key为源对象, value是拷贝产生的对象  (不能用对象来存储, 因为对象的key为字符串)
- 库. lodash

```js
/* 
1). 大众乞丐版
    问题1: 函数属性会丢失   原因: json字符串数据是不存在函数, 函数属性就会丢失
    问题2: 循环引用会出错   原因: 转换为json字符串是会产生死循环查找, 报错
利用JSON转换成json字符串, 再解析回来
*/
deepClone1 (target) {
  if (target!==null && typeof target==='object' ) {
    return JSON.parse(JSON.stringify(target))
  } else {
    return target
  }
},
```


```javascript
//作者：神三元
//链接：https://juejin.cn/post/6844903986479251464
const getType = obj => Object.prototype.toString.call(obj);

const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

const canTraverse = {
  '[object Map]': true,
  '[object Set]': true,
  '[object Array]': true,
  '[object Object]': true,
  '[object Arguments]': true,
};
const mapTag = '[object Map]';
const setTag = '[object Set]';
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}

const handleNotTraverse = (target, tag) => {
  const Ctor = target.constructor;
  switch(tag) {
    case boolTag: //解决直接使用构造函数带来的问题
      return new Object(Boolean.prototype.valueOf.call(target));
    case numberTag:
      return new Object(Number.prototype.valueOf.call(target));
    case stringTag:
      return new Object(String.prototype.valueOf.call(target));
    case symbolTag: //es6不推荐使用new,Symbol无法使用;所以使用valueOf
      return new Object(Symbol.prototype.valueOf.call(target));
    case errorTag: 
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}

const deepClone = (target, map = new WeakMap()) => {
  if(!isObject(target)) 
    return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return handleNotTraverse(target, type);
  }else {
    // 这波操作相当关键，可以保证对象的原型不丢失！
    let ctor = target.constructor;
    cloneTarget = new ctor();
  }

  if(map.get(target)) 
    return target;
  map.set(target, true);

  if(type === mapTag) {
    //处理Map
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key, map), deepClone(item, map));
    })
  }
  
  if(type === setTag) {
    //处理Set
    target.forEach(item => {
      cloneTarget.add(deepClone(item, map));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop], map);
    }
  }
  return cloneTarget;
}
```



#### 复述一下深拷贝的操作流程:

* 定义函数,  参数(target, map=new WeakMap())
* 判断是否是对象(判断条件), 非对象直接返回
* 获取具体的对象类型
* 判断是否是 5种 可遍历的对象 (可遍历对象5个: Array/Object/Set/Map/Arguments)
  * 如果是不可遍历的对象, 声明外部函数`handleNotCanTraverse(target, type)`来处理
    * 一类: 调用原型上的`valueOf`方法获取原始值, 再使用`new Object()`生成包装类对象 (string / number / boolean /symbol )
    * 一类: 默认调用原型上的构造函数,生成新的对象 (date error)
    * 一类: 调用独立的方法来处理( 正则表达式, 函数)
  * 如果是可遍历的对象
    * 首先是:  通过`target.constructor`属性获取其构造函数, 调用构造函数生成相应的实例对象
    * 如果存在对象引用 , 会提前在函数的参数中添加`map = new WeakMap()` (这个地方不熟悉的话可以省略不说)
      * 存在对象引用: 直接返回这个对象; 
      * 当前对象不存在引用, 将当前对象添加进map集合中 `map.set(target, true)`
    * 如果是map类型
      * `cloneTarget.set(deepClone(key, map), deepClone(item, map))`
    * 如果是set类型
      * `cloneTarget.add(deepClone(item , map))`
    * 如果是对象 / 数组 类型, 使用`for...in`循环来处理
      * `cloneTarget[key] = deepClone(target[key], map)`



### 数组相关

#### 判断数据类型是否为数组的方案7种
* [] instanceof Array
* [].\_\_proto\_\_ === Array.prototype
* [].constructor === Array
* Array.prototype.isPrototypeOf([])
* Object.getPrototypeOf([]) === Array.prototype
* Object.prototype.toString.call([]).slice(8, -1)
* Array.isArray([])


#### 数组扁平化 7种
* toString + split
* flat
* JSON.stringify + replace + split / JSON.parse
* 递归
  * for ...of
  * reduce
* 扩展运算符 + some 
```javascript
//toString + split

arr.toString().split(',')

//flat
arr.flat(Infinity)

//JSON + replace+split
//JSON.stringify(arr.replace(/\[|\]/g, '')).split(',')
JSON.stringify(arr).replace(/\[|\]/g, '').split(',')``

//JSON + replace + JSON.parse
let res = JSON.stringify(arr).replace(/\[|\]/g, '')
let newArr = JSON.parse('[' + res + ']')

//递归+for/reduce
let res = []
function flat(arr) {
  for (let i=0; i<arr.length; i++) { 
    if (Array.isArray(arr)) {
    	flat(arr[i])
  	} else {
      res.push(arr[i])
    }
  }
}
//
function flat(arr) {
  return arr.reudce((pre, crt) => {
    return pre.concat(Array.isArray(crt) ? flat(crt) : crt
  }, [])
}
                    

//扩展运算符
while(arr.some(Array.isArray)) {
    arr = [].concat(...arr)  // arr = [].concat(arr) 加不加扩展运算符都一样的 多循环一次
  }
```



#### 实现flat
```javascript
//递归
// arguments.callee指向argumetns对象所在函数的指针, 实现函数名与逻辑的解耦
function flat(arr) {
  let res = []
  arr.forEach(item => {
    if (Array.isArray(item)) {
      res = res.concat(arguments.callee(item)) 
      // res.push(...arguments.callee(item))
    } else {
      res.push(item)
    }
  })
  
  return res
}

//reduce
const flat = arr => {
  return arr.reduce((acc, crt) => {}, [
    return acc.concat(Array.isArray(crt) ? flat(crt) : crt)
  ])
}

//其他方法
```







#### 数组去重 7 种
* for + for  + splice
* for + for+ 新数组
* for + indexOf / includes
* reduce + indexOf/includes
* filter + indexOf / sort()
  * indexOf存在的问题
  * sort排序的问题  sort()排序有漏洞, 并不适用于特殊类型的排序. !!!!???
* sort快慢指针
* 键值对 
	* object键值对+filter(存在的问题: 不能去重正则表达式)
	* map键值对+filter
* new Set()
```javascript
let arr = [1,2,3,1,1,4,3,2,5,6,7];
// for + for 

for (let i=0; i<arr.length; i++) {
  for (let j=i+1; j<arr.length; j++) {
	  if (arr[j] === arr[i]) {
		  arr.splice(j, 1)
	    j--
	  }
  }
}

//for + 新数组

let newArr = []
let j;

for (let i=0; i<arr.length; i++) {
  for (j=0; j<newArr.length; j++) {
    if (arr[i] === newArr[j]) {
      break
    }
  }
  if (j === newArr.length) {
    newArr.push(arr[i])
  }
}

let newArr = []
for (let i=0, len=arr.length; i<len; i++) {
  for (let j=0, len=newArr.length; j<len; j++) {   //这里如果不采用变量形式,会出现死循环
    if (arr[i] === newArr[j]) {
      break
    }
    
    if (j === newArr.length) {
      newArr.push(arr[i])
    }
  }
}
```



```javascript
//for + indexOf / includes

let res = []
for (let i=0; i<arr.length; i++) {
  if (res.indexOf(arr[i] === -1)) { // !res.includes(arr[i])
    res.push(arr[i])
  }
}
```



```javascript
// reduce + indexOf / includes

arr.reduce((pre, crt) => pre.includes(crt) ? pre : pre.concat(crt), [])
arr.reduce((pre, crt) => pre.indexOf(crt) === -1 ? pre.concat(crt) : pre, [])
```



```javascript
//filter + indexOf

arr.filter((item, idx, arr) => arr.indexOf(item) == idx)
//存在的问题
1.arr.indexOf(NaN)的结果是-1,所以会忽略NaN这个值.
2.对象不去重

arr.concat().sort().filter((item, idx, arr) => !idx || item !== arr[idx - 1])
```



```javascript
//sort快慢指针

//https://juejin.cn/post/6844904202162929671

function unique(arr) {
  arr.sort((a, b) => a - b);
  let left = 0,
      right = 1;
  
  while(right < arr.length) {
    if (arr[left] === arr[right]) {
      right++;
    } else {
      arr[left + 1] = arr[right];
      left++;
      right++;
    }
  }
  return arr.slice(0, left+1);
}

//https://juejin.cn/post/7033275515880341512
function unique2(arr) {
  arr.sort((a, b) => a - b);
  let slow = 1,
      fast = 1;
  
  while(fast < arr.length) {
    if (arr[fast - 1] !== arr[fast]) {
      arr[slow++] = arr[fast];
    }
    ++fast;
  }
  arr.length = slow;
  return arr;
}
```



```javascript
//object键值对

// 考虑到 `JSON.stringify` 任何一个正则表达式的结果都是 `{}`，所以这个方法并不适用于处理正则表达式去重。

let obj = {}
arr.filter( v => obj.hasOwnProerpty(v) ? false : (obj[typeof v + JSON.stringify(v)] = true))
```



```javascript
//map键值对

let map = new Map()
arr.fitler((item, idx, arr) => !map.has(item) && map.set(item, true))
```



```javascript
// set
let res = (arr) => [...new Set(arr)]
```

#### 数组去重存在的问题

重点关注下 对象 和NaN 的去重

| 方法                                                         | 结果                                                         | 说明                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------- |
| for循环(双for+新数组)                                        | [1, "1", null, undefined, String, String, /a/, /a/, NaN, NaN] | 对象和 NaN 不去重                       |
| indexOf(作者用的是新数组+for循环+indexOf方法)                | [1, "1", null, undefined, String, String, /a/, /a/, NaN, NaN] | 对象和 NaN 不去重                       |
| sort<br />结论是数字1不去重,没有勘误.不知道是哪个数字1,是包装类的吗? | [/a/, /a/, "1", 1, String, 1, String, NaN, NaN, null, undefined] | 对象和 NaN 不去重 <br />数字 1 也不去重 |
| filter+indexOf                                               | [1, "1", null, undefined, String, String, /a/, /a/]          | 对象不去重 NaN 会被忽略掉               |
| filter+sort                                                  | [/a/, /a/, "1", 1, String, 1, String, NaN, NaN, null, undefined] | 对象和 NaN 不去重 数字 1 不去重         |
| 优化后的键值对方法                                           | [1, "1", null, undefined, String, /a/, NaN]                  | 全部去重                                |
| Set                                                          | [1, "1", null, undefined, String, String, /a/, /a/, NaN]     | 对象不去重 NaN 去重                     |






#### 数组翻转

1. 使用原型中的reverse方法

   ```js
   let array = [1, 2, 3, 4, 5]
   array.reverse() 
   ```
   
2. 循环
* 临时变量(索引之和等于长度减1)
* unshift
   ```js
   for(var i = 0; i < arr.length; i++){
       var temp = arr[i];
       arr[i] = arr[arr.length - 1 - i]
       arr[arr.length - 1 - i] = temp;
   }

   ```

   


#### 排序算法
> https://github.com/Easay/issuesSets/issues/44

##### 简单排序: 冒泡 / 选择 / 插入

```js
/* 
冒泡排序的方法
*/
function bubbleSort (array) {
  // 1.获取数组的长度
  var length = array.length;

  // 2.反向循环, 因此次数越来越少
  for (var i = length - 1; i >= 0; i--) {
    // 3.根据i的次数, 比较循环到i位置
    for (var j = 0; j < i; j++) {
      // 4.如果j位置比j+1位置的数据大, 那么就交换
      if (array[j] > array[j + 1]) {
        // 交换
        // const temp = array[j+1]
        // array[j+1] = array[j]
        // array[j] = temp
        [array[j + 1], array[j]] = [array[j], array[j + 1]];
      }
    }
  }

  return arr;
}

/* 
选择排序的方法
*/
function selectSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 从0位置开始取出数据, 直到length-2位置
  for (var i = 0; i < length - 1; i++) {
    // 3.内层循环: 从i+1位置开始, 和后面的内容比较
    var min = i
    for (var j = min + 1; j < length; j++) {
      // 4.如果i位置的数据大于j位置的数据, 记录最小的位置
      if (array[min] > array[j]) {
        min = j
      }
    }
    if (min !== i) {
      // 交换
      [array[min], array[i]] = [array[i], array[min]];
    }
  }

  return arr;
}

/* 
插入排序的方法
*/
function insertSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后
  for (var i = 1; i < length; i++) {
    // 3.记录选出的元素, 放在变量temp中
    var j = i
    var temp = array[i]

    // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环
    while (j > 0 && array[j - 1] > temp) {
      array[j] = array[j - 1]
      j--
    }

    // 5.将选出的j位置, 放入temp元素
    array[j] = temp
  }

  return array
}
```



##### 快速排序(选择性)

```js
function quickSort(arr) {
  // 递归结束的条件
  if(arr.length < 2){
    return arr
  }
  // 获取中间值
  let flag = Math.floor(arr.length / 2);
  let flagValue = arr.splice(flag, 1)[0];
  
  let leftArr = [];
  let rightArr = [];
  for (var i = 0; i < arr.length; i++) {
    var arrItem = arr[i];
    
    if(arrItem > flagValue){
      rightArr.push(arrItem)
    }else {
      leftArr.push(arrItem)
    }
  }
  
  leftArr = quickSort(leftArr);
  rightArr = quickSort(rightArr);
  return [...leftArr, flagValue, ...rightArr]
}
```





### 函数相关

#### 函数的call() / apply() / bind()

```javascript

//call
Function.prototype.call2 = function(...items) {
  let obj = items.shift() || globalThis
  let tempFn = Symbol()
  obj[tempFn] = this
  
  let res = obj[tempFn](...items)
  delete obj[tempFn]
  
  return res
}

// 不建议使用arguments
Function.prototype.myCall = function() {
  let obj = [].shift.call(arguments) || globalThis;
  obj.tempFn = this
  
  let res = obj.tempFn(...[...arguments]);
  delete obj.tempFn;
  return res;
}



//apply
Function.prototype.apply2 = function(...items) {
  let obj = items.shift() || globalThis
  obj[tempFn] = this
  let res = obj[tempFn](items)
  delete obj[tempFn]
  
  return res
}

//bind

//1 version
Function.prototype.bind = function(cxt) {
  let fn = this
  let argsOut = [].slice.call(arguments)
  return function() {
    let argsInner = [].slice.call(arguments)
    fn.apply(cxt, argsOut.concat(argsInner))
  }
}

//

//2 version  避免实例通过原型链更改函数原型上的属性,使用空函数中转 + 可以使用new调用
Function.prototype.bind = function () {
	let fn = this
  let argsOut = [].slice.call(arguments, 1)
  let fNOP = function() {}
  let fbound = function () {
    let argsInner = [].slice.call(arguments)
    return fn.apply(this instanceof fNOP ? this : crt, argsOut.concat(argusInner))
  }
  
  fNOP.prototype = this.prototype
  fbound.prototype = new fNOP()
  return fbound
}
```



```js
/* 
自定义函数对象的call方法
*/
function call (fn, obj, ...args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
自定义函数对象的apply方法
*/
function apply (fn, obj, args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
  自定义函数对象的bind方法
  重要技术:
    高阶函数
    闭包
    call()
    三点运算符
*/
function bind (fn, obj, ...args) {
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  
  return function (...args2) {
    call(fn, obj, ...args, ...args2)
  }
}
```



### 字符串处理

```js
/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/

/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
*/
function reverseString(str) {
  // return str.split('').reverse().join('')
  // return [...str].reverse().join('')
  return Array.from(str).reverse().join('')
}

/* 
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
*/
function palindrome(str) {
  return str === reverseString(str)
}

/* 
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/
function truncate(str, num) {
  return str.length > num ? str.slice(0, num) + '...' : str
}
```



### instanceof内部原理和实现

instanceof运算符判断一个对象是否为另一个对象的实例

```javascript

function isntanceof2(case, Ctor) {
    //基本数据类型返回false
  //兼容一下函数对象
  if (typeof(Case) !== 'object' && typeof(Ctor) !== 'function' || Case === 'null') {
    return false;
  }
  
  let caseProto = Object.getPrototypeOf(case)
  while(true) {
    if (caseProto == null) return false
    //找到相同的原型
    if (caseProto === Ctor.prototype) return true
    caseProto = Object.getPrototypeOf(caseProto)
  }
}


```


### 函数柯里化
> https://github.com/Easay/issuesSets/issues/78


函数柯里化是一种将接收多个参数的函数转换为接收一个参数并返回另一个函数的技术。更加灵活地控制函数的功能和输入。

#### 案例
考虑一个接收两个参数的函数，它将它们相乘并返回结果：
```js
function multiply(a, b) {
  return a * b;
}

multiply(2, 3);  // 6
```

使用柯里化转换函数
```js
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

multiply(2)(3);  // 6
```



#### 实现代码
```js
function curryIt(fn){
    var args = [];
    return function() {
        // 类数组转数组方式1：
        var arg = [].slice.call(arguments);
        // 方式2：
        //var arg = Array.from(arguments);
        args = args.concat(arg);
        if(args.length < fn.length){
            return arguments.callee;
        }else{
            return fn.apply(null,args);
        }
    }   
}
```

## 浏览器和网络

### reflow repaint

#### Reflow

当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。

#### Repaint

当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。

#### 引起Repaint和Reflow的一些操作

- 调整窗口大小
- 字体大小
- 样式表变动
- 元素内容变化，尤其是输入控件
- CSS伪类激活，在用户交互过程中发生
- DOM操作，DOM元素增删、修改
- width, clientWidth, scrollTop等布局宽高的计算

#### Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：

- 避免逐条更改样式。建议集中修改样式，例如操作className。
- 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置display:none的元素上操作，最后显示出来。
- 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。
- 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流




## git操作

- git config --global credential.helper store (记住用户和密码)

- 分支操作
  ​	拉取远程新分支到本地
  ​	git pull (如果分支是在clone后创建的才需要执行)
  ​	git checkout -b dev origin/dev

- 版本注释一般规范
  feature 特性：新增功能
  docs 文档：新增文档
  fix 修复 Bug
- xiongjian分支到本地仓库xiongjian分支上
  git fetch origin xiongjian:xiongjian 拉取远程仓库

```bash
git checkout -b branchName

git add .

git commit -m 'xxx'

git checkout master

git merget branchName

git pull

git push
```





## webpack

#### 1. Webpack 基本概念

##### 1) entry 入口

- 以某个文件为入口开始打包
- 分类
  - 单入口 String 
    - 只会输出一个文件
  - 多入口 Array / Object
    - Array 只会输出一个文件
    - Object 会输出多个文件  ==> 多页应用(MPA)

##### 2) output 输出

- 打包后资源输出到哪里去
- 输出的文件名叫什么

##### 3) loader 加载器

- webpack 本身只能识别 json、js 模块，其他模块一旦加载就会报错
- 需要借助 loader 帮助 webpack 识别其它识别不了的模块

##### 4) plugins 插件

- loader 功能有限，要想做功能更加强大的工作交给插件
- 比如在页面中自动引入打包生成的js/css, 压缩css, 拷贝文件等

##### 5) mode

- 模式：开发环境（development）和生产环境（production）
- 提供一系列默认配置, 用于简化配置

#### 2. Webpack 基本配置

##### 1) 处理JS文件
- eslint-loader
  - 在package.json中配置eslintConfig来指示eslint-loader到底要干什么事
  - enfore: 'pre' 优先执行
- babel-loader
  - 在webpack配置中配置babel来指示babel-loader到底要干什么事
  - babel.config.js: 配置webpack的preset与plugin

##### 2) 处理Vue文件

- vue-loader

##### 3) 处理JSX文件 

- babel-loader
- presets: ['@babel/preset-react']

##### 4) 处理CSS文件

- 开发环境：创建style标签插入样式
  - style-loader
  - css-loader
  - postcss-loader
  - less-loader / sass-loader / stylus-loader
- 生产环境：提取单独css文件，将来通过link引入
  - MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）
  - css-loader
  - postcss-loader
  - less-loader / sass-loader / stylus-loader

##### 5) 处理HTML文件

- 目标: 自动引入打包生成的js/css
- html-webpack-plugin

##### 6. 处理图片/字体/音视频文件

- url-loader / file-loader
- limit: 10000 小于10kb一下的图片会被base64处理

#### 3. Webpack 优化手段

##### 1) 优化打包构建速度

##### HMR 热模块替换

- 为什么要用？
  - 默认情况下，一旦修改了代码，全部代码重新编译刷新，速度慢（全体刷新）
- 有什么作用？
  - 只更新修改的模块，其他模块不变（局部更新）  
- 怎么使用？
  - devServer: { hot: true }  
  - new webpack.HotModuleReplacementPlugin()  
- 注意：
  - 默认情况下只有样式文件有HMR功能（style-loader），JS是没有的
- 开启JS的HMR功能：
  - 手写JS代码 --> module.hot.accpet('模块路径', () => {})
  - 在Vue使用 --> vue-loader
  - 在React使用 --> react-hot-loader

#### 缓存

- eslint和babel两个任务处理JS文件，时间一般会比较长，为了让其重新构建速度更快, 可以使用缓存。
- eslint --> cache: true
- babel --> cacheDirectory: true
- cache-loader放置在要缓存loader的前面
- 注意：一般只针对耗时长的任务：eslint-loader/babel-loader/vue-loader

#### oneOf

- 作用：
  - 让模块只被一个loader处理，其他的就不看了(原本所有都会判断一下)
  - 能够提升打包速度
- 注意：
  - eslint-loader: 处理js, 需要先执行, 将其定义在oneOf的外面
  - babel-loader: 处理js, 后执行, 将其定义在oneOf的内部

#### 多进程打包

- 过去: happyPack
- 现在: thread-loader
- 用法和cache-loader差不多，放在要使用loader前面
- 作用：开启多进程处理前面的任务，提升打包速度
- 注意：每个进程开启和通信都有开销，一般只针对耗时长的任务：babel-loader

### 2) 优化打包代码体积和性能

#### 兼容性处理

- JS
  - ES6由二个部分
    - 新语法: const/let/箭头函数/解构赋值/对象简写 
    - 新API: Promise / 数组新方法/ 对象新方法
  - babel-loader presets: ['@babel/preset-env'] 问题就是只能编译语法, 不能处理新API
  - @babel/polyfill 做API兼容，问题是体积太大了
  - core-js3 在@babel/preset-env基础上，增加了useBuiltIns: 'usage'来实现按需加载
  - 指定浏览器版本或占有率配置, 进一步减小打包文件: 只打包使用了且浏览器没有实现的
- CSS  
  - postcss-loader 
  - 在package.json中指定browserslist来指示postcss-loader兼容性做到什么程度

#### tree shaking( 摇树)

- 去除没有使用的JS代码
- 必须使用ES6模块化（需要禁止@babel/preset-env转换ES6模块化语法 modules: false）
- 开启webpack的生产模式（内部启用TerserPlugin，用来压缩JS代码的插件，tree shaking功能就是这个插件完成的）
- 在package.json配置sideEffects来指定哪些文件需要进行tree shaking

#### code split 代码分割 / lazy loading 懒加载

- 作用：
  - 抽取公共代码 
  - 拆分多个文件，减少单个文件体积（避免单次请求时间过长）
- 配置：
  - 多入口 + optimization
    - 将node_modules抽取成单独模块
    - 将多入口的公共模块也抽取成单独模块
  - 单入口 + optimization + import
    - 将node_modules抽取成单独模块
    - 动态导入语法import就能将某些文件抽取成单独模块
  - import()动态引入模块
    - 原生 JS:  在需要的回调函数中动态加载模块, import(模块).then()
    - Vue: () => import('./Foo.vue'), 实现路由组件懒加载
    - React: Suspence +lazy(() => import('./SomeComponent')), 实现路由组件懒加载

#### preload 和 prefetch 预加载

- 作用：
  - 让资源提前加载
- 区别：
  - preload 让当前页面的要使用资源加载（延后加载）
  - prefetch 让后面要使用资源提前加载（当前不需要使用）
- 使用：
  - import(/*webpackChunkName: xxx webpackPrefetch: true */'./xxx')
  - import(/*webpackChunkName: xxx webpackPreload: true */'./xxx') // 没有效果
  - 问题：兼容性较差 
- 使用Chrome团队提供的一个工具包: preload-webpack-plugin
  - npm i -D preload-webpack-plugin@next  // 必须是最新的下一个版本
  - 对异步模块包使用: prefetch
  - 对同步模块包使用: preload

#### 浏览器cache/缓存

- hash 
  - webpack每次构建都会生成一个新的且唯一的hash
  - 问题：只要webpack重新构建，所有文件的hash都会发生变化，缓存就会失效

- chunkhash
  - 打包属于同一个chunk，就共享同一个hash
  - 问题：样式文件被css-loader打包js文件中，导致样式文件和js文件属于同一个chunk，共享同一个hash
  - 一旦样式文件发生变化，js文件也会变

- contenthash
  - 根据文件的内容来成hash，所以只要文件内容不一样，hash就不一样
  - 问题：
    - 比如A模块有一个依赖，是B模块，那么A模块内部就会保存B模块hash值，
    - 一旦B模块发生变化，B模块的hash值就会变，导致A模块内部保存B模块hash值也发生改变
    - 此时A模块文件内容发生变化，它的hash值也会变
  - 解决：
    - runtimechunk: true 将A模块保存的B模块hash值存到runtime文件中，这样A模块内部就没有B模块的hash值了，就不会因为B模块的修改而修改



### 基础

- entry 入口
  指示 webpack 从哪个文件开始打包

- output 输出
  指示 webpack 将打包后的文件输出到哪里去

- loader 加载器
  帮助 webpack 解析它解析不了的模块（将其他模块解析成 webpack 能识别的模块，这样才能打包）

  还有其他功能：多进程打包...

- plugin 插件
  能够功能更加强大的事
  将现有库包装成 webpack 能够识别的功能模块，从而加载使用

- mode 模式
  模式（development/production）
  区别：设置不同 NODE_ENV，启用不同的插件

### 其他配置

- resolve 解析：帮助 webpack 解析模块

  alias 配置路径别名

  extensions 配置自动补全文件扩展名

  modules 配置 引入 node_modules 库，node_modules 文件夹去哪找

- optimization 优化

- devServer 开发服务器

### 兼容性处理

- JS 兼容性处理 babel
- CSS 兼容性处理，使用 postcss-loader 做 css 兼容性处理

### 摇树（**tree shaking**）

- 摇树：去除无用的 JS 代码

- 配置

  必须使用 ES6 模块化

  开启 mode: production

### 缓存

- 客户端端缓存服务器请求的资源（js/css/图片...）

  - 强制缓存（不会重新访问服务器，直接读取缓存）

    问题：如果资源在缓存期间内，是没办法更新的~

  - 协商缓存（每次都会重新访问服务器，由服务器来决定要不要走缓存，304）

- hash webpack 打包生成的，所以资源共享 hash 值

  问题：如果改动一个资源，所有资源的 hash 都变~导致其他资源缓存失效

- chunkhash 属于同一个 chunk，hash 值一样，不同 chunk，hash 值不一样

  问题：单入口样式文件因为 css-loader，会把样式文件打包到 js 中，此时就会和 js 共享同一个 hash 值，一旦改动 js/css 文件，css/js 文件缓存失效

- contenthash 根据文件内容来生成 hash，不同文件 hash 值不同

  新问题：如果 A 文件采用 import 进行代码分割文件 B，分割文件 B 一旦变化，那么 A 文件缓存失效

  原因是：A 文件保存 B 文件的 hash 值，一旦 B 文件变化，A 文件的 hash 值也要更新，从而导致 A 文件也变了

  解决：需要将 A 文件保存 B 文件的 hash 值单独提取出来，成单独文件，这样就不会影响 A 文件了

  ```js
  runtimeChunk: {
    name: (entry) => `runtime-${entry.name}.js`;
  }
  ```

### 关闭map(vue项目生产环境)

productionSourceMap: false, // 关闭map映射文件



### 实际使用
#### require.context
```javascript
//store/index.js

const moduleFIles = require.context('./modules', true, /\.js$/)
const modules = moduleFiles.keys().reduce((modules, modulePath) => {
  let moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
  //处理多层文件
  if (moduleName.includes('/')) {
    let moduleNameParts = moduleName.split('/')
    for (let idx=1,len=moduleNameParts.length; idx<len; idx++) {
      const item = moduleNameParts[idx]
      moduleNameParts[idx] = item.slice(0, 1).toUpperCase() + item.slice(1)
    }
    moduleName = moduleNamePargs.join('')
  }
  const value = modulesFiles(modulePath)
  modules[moduleName] = value.default
  return modules
}, {})
```



## Vue基础


### 怎么实现vm

1.需要利用Object.defineProperty，将要观察的对象，转化成getter/setter，以便拦截对象赋值与取值操作.也就是<u>数据观察者</u><span style="color:blue">Observer</span>；

2.将DOM解析，提取其中的指令与占位符，并赋与不同的操作. 也就是<u>指令解析器</u><span style="color:blue">Compile</span>

3.需要将Compile的解析结果，与Observer所观察的对象连接起来，在Observer观察到对象数据变化时，接收通知，同时更新DOM. 也就是<u>订阅者</u><span style="color:blue">Watcher</span>，它是Observer和Compile之间通信的桥梁；

4.最后，需要一个公共入口对象，接收配置，协调上述三者，称为vm，也就是Vue;

### Vue响应式原理(如何实现数据双向绑定)
> https://github.com/Easay/issuesSets/issues/41

Vue采用**数据劫持**结合**发布-订阅 + 观察者模式**的方法，通过Object.defineProperty()来劫持各个属性的setter,getter属性，在数据变动时，发布消息通知订阅者，触发更新回调函数，重新渲染视图.


### Vue的渲染过程
>https://github.com/Easay/issuesSets/issues/49

#### 整体流程：
通过编译，将模板编译成渲染函数，执行渲染函数后生成虚拟节点vnode，将虚拟节点渲染到页面上。

#### 模板编译过程
```md
模板 ——>模板编译(compile)——>渲染函数
```

分为三个步骤：
* 将模板解析成AST（抽象语法树）；（解析器）
* 遍历AST标记静态节点；（优化器）
* 使用AST生成渲染函数。（代码生成器）


### 虚拟DOM//?
>https://github.com/Easay/issuesSets/issues/48

虚拟DOM本质上是一个普通对象，是从VNode类实例化的对象。vnode可以理解成节点描述对象，描述了应该怎样去创建真实的DOM节点。

当状态发生变化时，更新与之关联的DOM节点，虚拟DOM是解决这一问题的方式之一。

通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前会使用新生成的虚拟节点树和之前的虚拟节点树进行对比，只渲染不同的部分。

vue2.0中，将组件级别作为一个watcher实例，即使一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。当变化发生后，通知到组件，组件内再通过虚拟DOM进行比对与渲染。

#### 渲染过程
在Vue.js中使用模板来描述状态与DOM之间的映射关系。
* 模板编译成渲染函数
* 执行渲染函数得到虚拟节点树
* 与上一次得到的虚拟节点树进行对比（diff算法）
* 找出要更新的节点进行DOM操作
* 渲染视图


#### 虚拟 DOM 实现原理？
虚拟 DOM 的实现原理主要包括以下 3 部分：

用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
diff 算法 — 比较两棵虚拟 DOM 树的差异；
pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589#heading-14)》




#### 虚拟DOM优缺点
优点：
**保证性能下限**： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
**无需手动操作DOM**： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
**跨平台**： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

缺点:
**无法进行极致优化**： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。



### Vue数据流
1. Vue也是一个单向数据流的框架
2. Vue通过指令实现了双向数据绑定： v-model
3. v-model都做了哪些事情; `<input v-model='msg' />`
   1. 将指定变量的数据赋值给input的value
   2. 给当前的表单项自动绑定一个input事件，监听View层表单项数据发生改变获取最新value的同时更新Model的数据

### Vue单向数据流
* 父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
* 每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

**两种常见的更改Prop的情况**
* prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：
```vue
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```
* 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性
```vue
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```


### Vue中的异步更新队列
>https://github.com/Easay/issuesSets/issues/53

Vue在观察数据变化时并不是直接更新DOM,而是开启一个队列，然后缓冲在同一个时间下发生的所有的数据改变，同时去重，只有在下一个事件循环中，VUE才会刷新队列，执行新的内容

**什么时候DOM会更新完成呢？**
$neckTick执行时就是DOM更新完成后
所以我们对数据变化的DOM对象做处理时，应该在$nextTick函数中做处理

### $nextTick作用及原理
>https://github.com/Easay/issuesSets/issues/52

#### 是什么
nextTick方法接收一个回调函数，作用是将回调延迟到下一次DOM更新周期后执行，与全局nextTick方法一样，不同的回调的this会自动绑定到调用它的vm实例上。如果没有回调，则返回Promise。

#### 使用场景
更新数据后，需要对新DOM做一些操作，但此时我们还无法获得更新后的DOM，因为还没有重新渲染。这时需要用到nextTick方法。
```js
new Vue({
	methods: {
		example:function(){
			//修改数据
			this.message = 'change',
			// DOM还未更新
			this.$nextTick(function(){
					// DOM现在更新了
					// this绑定到更新后的当前vm实例
					this.doSomethingElse();
			})
		}
	}
})
```

当状态发生变化时，watcher会得到通知，然后触发虚拟DOM的渲染流程。而watcher触发渲染这个操作并不是同步的，而是异步的。Vue.js中有个队列，每次需要渲染时，就将watcher推入这个队列，在下一次事件循环中再让watcher触发渲染的流程。

#### 异步更新队列的原因
//待补充



### 组件间通信的方式


### Vue组件间多种通信方式

#### 1) 组件间通信方式列表

```
1) props
2) vue自定义事件
3) 全局事件总线
4) v-model
5) .sync 
6) $attrs与$listeners
7) $refs, $children与$parent
8) provide与inject
9) Vuex
10) 插槽 ==> 作用域插槽
```

#### 2) 通信方式的选择

#### 根据通信的2个组件间的关系来选择一种通信方式

```
父子
	props
	vue自定义事件
	v-model
	.sync
	$refs, $children与$parent
	插槽 ==> 作用域插槽
祖孙
	$attrs与$listeners
	provide与inject
兄弟或其它/任意
	全局事件总线
	Vuex
```



#### 方式1: props 

```
1). 实现父向子通信: 属性值是非函数
2). 实现子向父通信: 属性值是函数
应用: 最基本, 用得最多的方式
```

#### 方式2: vue自定义事件
```
1). 用来实现子组件向父组件通信
2). 相关语法:
    父组件中给子组件绑定自定义事件监听:
      <Child @eventName="callback">
    子组件中分发事件
      this.$emit('eventName', data)
应用: elment-ui的组件的事件监听语法都用的是自定义事件
      我们项目中的组件也用了不少自定义事件
```



#### 方式3: 全局事件总线   ===> 消息订阅与发布

```
实现任意组件间通信
编码:
	将入口js中的vm作为全局事件总线对象: 
			beforeCreate() {
					Vue.prototype.$bus = this
			}
	分发事件/传递数据的组件: this.$bus.$emit('eventName', data)
	处理事件/接收数据的组件: this.$bus.$on('eventName', (data) => {})
    
应用: 前台项目中使用全局事件总线
```

#### 方式4: v-model
* 实现父子之间相互通信/同步
* 组件标签上的v-model的本质: 自定义input监听来接收子组件分发$emit的数据更新父组件数据
父组件: 
```vue
	<CustomInput v-model="name"/>
	<!-- 等价于 -->
	<CustomInput :value="name" @input="name=$event"/>
```

子组件: 
子组件需要使用`$emit`来触发v-model绑定的事件
```vue
<input type="text" :value="value" @input="$emit('input', $event.target.value)">

props: ['value']
```

应用: element-ui中的表单项相关组件都用了v-model: Input / Select / Checkbox / Radio

#### 方式5: .sync
实现父子之间相互通信/同步(在原本父向子的基础上增加子向父)
组件标签的属性上使用.sync的本质: 事件监听来接收子组件分发$emit过来的数据并更新父组件的数据
父组件:
```vue
<child :money.sync="total"/>
<!-- 等价于 -->
<Child :money="total" @update:money="total=$event"/>

data () {
	return {
		total: 1000
	}
},
```
子组件:
```vue
<button @click="$emit('update:money', money-100)">花钱</button>
props: ['money']
```
应用:  
element-ui在有显示隐藏的组件上: Dialog / Drawer

#### 方式6: `$attrs`与$listeners
**$attrs**
//实现当前组件的父组件向当前组件的子组件通信
父组件传递给子组件的属性,除了props已经声明接收的属性及父组件的style,class属性.
它是包含所有父组件传入的标签属性(排除props声明, class与style的属性)的对象
使用: 通过 v-bind="$attrs" 将父组件传入的n个属性数据传递给当前组件的子组件


**$listeners**
实现当前组件的子组件向当前组件的父组件通信
$listeners是包含所有父组件传入的自定义事件监听名与对应回调函数的对象
使用: 通过v-on="$listeners" 将父组件绑定给当前组件的事件监听绑定给当前组件的子组件
应用: 利用它封装了一个自定义的带hover文本提示的el-button

#### 方式7: `$refs & $children & $parent`
$refs
  实现父组件向指定子组件通信
  $refs是包含所有有ref属性的标签对象或组件对象的容器对象
  使用: 通过 this.$refs.child 得到子组件对象, 从而可以直接更新其数据或调用其方法更新数据
$children
实现父组件向多个子组件通信
$children是所有直接子组件对象的数组
使用: 通过this.$children 遍历子组件对象, 从而可以更新多个子组件的数据
$parent
  实现子组件向父组件通信
  $parent是当前组件的父组件对象
  使用: 通过this.$parent 得到父组件对象, 从而可以更新父组件的数据
应用: 在后台管理项目中使用了$refs

#### 方式8: provide与inject

```js
//provide于inject案例
export default{
    //
    provide(){
        return { //声明向所有后代提供2个数据
            content1:this.content1,
            content2:this.content2,
            updateContent:this.updateContent
        }
    }
}

export default{
    //
    inject:['content1', 'content2', 'updateContent'] //声明注入的属性会成为组件对象的属性
}

```

实现祖孙组件间直接通信
使用
在祖组件中通过provide配置向后代组件提供数据
在后代组件中通过inject配置来声明接收数据
注意:
不太建议在应用开发中使用, 一般用来封装vue插件
provide提供的数据本身不是响应式的 ==> 父组件更新了数据, 后代组件不会变化
provide提供的数据对象内部是响应式的 ==> 父组件更新了数据, 后代组件也会变化
应用: element-ui中的Form组件中使用了provide和inject



#### 方式9: vuex

- vuex用来统一管理多个组件共享的状态数据

- 任意要进行通信的2个组件利用vuex就可以实现

  A组件触发action或mutation调用, 将数据保存到vuex的状态中

  B组件读取vuex中的state或getters数据, 得到最新保存的数据进行显示
  
- 面试题

  1. mutation负责同步修改状态数据的，能不能异步修改

     可以异步修改

     如果异步修改的话会导致Vuex的调试工具失效，无法检测异步修改数据

  2. 设计的时候为什么建议mutation同步修改状态数据，而新增action负责异步

     Vuex的作用是给多个组件共享数据

     如果支持mutation异步修改数据，又因为异步的特性，会导致store对象中state数据发生错乱甚至是报错

     为了数据的安全

  3. Vuex刷新页面，数据丢失问题
```md
 //数据丢失原因
1.	Vuex数据保存在运行内存中，vue实例初始化的时候为其分配内存
2.	当刷新页面的时候重新初始化Vue实例，所以重新为Vuex分配内存导致之前保存的数据丢失

   //如何解决?
1.	Vuex的数据都是每次组件加载时候动态请求获取数据保存
a)	优点： 保证数据不会丢失
b)	缺点: 性能差，因为网络问题可能有网络延迟

2.	将Vuex中的数据每次同步更新保存到sessionStorage中
a)	优点: 每次页面刷新后从sessionStorage中获取保存的数据，不会丢失
b)	缺点: state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差

3.	在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取
a)	优点: 减少动态更新sessionStorage的次数，性能好
b)	重点: 给window绑定beforeupload事件监听

4.插件
使用持久化插件：可以使用Vuex持久化插件如vuex-persistedstate或vuex-along来将Vuex存储在浏览器的localStorage或cookie中，以便在刷新页面时保留数据状态。
```


```js
//绑定事件监听: 在页面卸载(关闭)或刷新时候保存当前数据
// beforeunload 页面即将刷新之前调用
window.addEventListener('beforeupload', () => {
    sessionStorage.setItem('test2', JSON.stringify(this.personArr))
})
// 读取sessionStorage中是否有之前缓存的数据
let personArr = sessionStorage.getItem('test2')
// 如果有： 更新Vuex中状态数据
personArr && this.changePersonArrMutation(JSON.parse(personArr))
```



#### 方式10:  插槽/作用域插槽slot-scope
实现父组件向子组件传递标签内容
  什么情况下使用作用域插槽?
  父组件需要向子组件传递标签结构内容,但决定父组件传递怎样标签结构的数据在子组件中
编码:
子组件:
```vue
<slot :row="item" :$index="index">  <!-- slot的属性会自动传递给父组件 -->
</slot>
```
父组件:
```vue
<template slot-scope="{row, $index}">
		<span>{{$index+1}}</span> &nbsp;&nbsp;
		<span :style="{color: $index%2===1 ? 'blue' : 'green'}" >{{row.text}}</span>
</template>
```            
应用: element-ui中的Table组件


### computed与method和watch的区别

- **computed** 
  1. 支持缓存，多次读取, 只会执行一次计算, 只有依赖数据发生改变，才会重新进行计算 
  2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
  3. 底层用到的是对象set和get方法: 简写为函数形式,就是get方法;完整写法为对象,get+set方法;
     1. setter和getter中的this上下文自动绑定为Vue实例;如果使用箭头函数形式, 可以将实例作为第一个参数
  4. 执行时机: 初始化时; 当依赖数据发生变化时;

- **method**
  - 没有缓存, 多次读取, 必须多次调用

- **watch**
  1. watch支持异步；
  2. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
  3. 当一个属性发生变化时，需要执行对应的操作；一对多；
  4. 监听数据必须是一个响应式数据(data/props/computed)
	  1. immediate：组件加载立即触发回调函数执行，
	  2. deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变
  5. 执行时机: 初始化, mounted后执行(mounted 钩子函数会在 watch 中的 handler 函数之前执行，因为 mounted 是在组件渲染完毕后执行的，而 watch 监听的数据变化需要等到组件渲染完毕后才能触发。)



### Vue 列表为什么加 key？
因为Vue在进行列表渲染时的优化策略涉及到了Virtual DOM，而在渲染Virtual DOM时，需要对比新旧节点的变化，如果没有唯一的key属性，Vue无法准确地追踪每个节点的变化情况。

通过给每个列表项加上唯一的key属性，Vue能够更加高效地渲染视图，提高渲染性能。同时，在使用列表组件时，key属性也可以用于优化过渡动画效果，确保在列表项被添加或删除时，动画效果能够正确地触发。

### Class 与 Style 如何动态绑定？
Class 可以通过对象语法和数组语法进行动态绑定：

对象语法：
```vue
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
data: {
  isActive: true,
  hasError: false
}
```
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>

数组语法：
```vue
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>


data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```


Style也可以通过对象语法和数组语法进行动态绑定：

对象语法：
```vue
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>


data: {
  activeColor: 'red',
  fontSize: 30
}
```
数组语法：
```vue
<div v-bind:style="[styleColor, styleSize]"></div>

data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}
```




### 直接给一个数组项赋值，Vue 能检测到变化吗？
由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：
* 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
* 当你修改数组的长度时，例如：`vm.items.length = newLength`

为了解决第一个问题，Vue 提供了以下操作方法：
```js
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```
为了解决第二个问题，Vue 提供了以下操作方法：
```js
// Array.prototype.splice
vm.items.splice(newLength)
```


### vfor与vif同时使用的问题?

> 在官方文档中明确指出**v-for和v-if不建议一起使用**。 原因：v-for比v-if优先级高，所以使用的话，每次v-for都会执行v-if,造成不必要的计算，影响性能，尤其是当之需要渲染很小一部分的时候。

`v-for` 和 `v-if` 同时使用有 3 种情景：

1. 部分遍历（内/外部条件）：一个 `list` 中某个属性值符合条件的遍历出来；
2. 全部遍历（外部条件）：某外部条件符合条件时遍历全部。
3. 全部遍历（内部条件）：根据某内部条件渲染出不同的内容。

#### 解决方案:

##### 使用计算属性

> 在计算属性中先用内/外部条件处理数据，再遍历处理后的数据

```javascript
<!-- 遍历list，条件是值小于100 方案：使用计算属性activeList首先筛选出符合条件的值再直接遍历 -->
<ul>
  <li v-for="item in activeList" :key="item"></li>
</ul>

export default {
  data() {
    return {
      list: [78, 90, 20, 45, 66, 120, 136]
    }
  },
  computed: {
    activeList() {
      return this.list.filter((item) => item < 100)
    }
  }
}
```



##### 条件放于父元素(外部条件)

> 解决方案：外部条件放到遍历的父级元素上，没有父级可以使用`<template></template>`。

```html
<ul v-if="isActive">
  <li v-for="item in list" :key="item"></li>
</ul>
<!-- or -->
<div>
  <template v-if="isActive">
    <span v-for="item in list" :key="item"></span>
  </template>
  <p>Hello,My name is Lillian!</p>
</div>

<script>
export default {
  data() {
    return {
      isActive: true,
      list: [78, 90, 20, 45, 66, 120, 136]
    }
  }
}
</script>
```



##### 遍历`template`(内部条件)

> 根据某内部条件，显示不同内容。注意 `key` 不能放 `template` 标签上

```html
<div>
  <template v-for="item in list">
    <span v-if="item.type===0" :key="item.id">文字+图标</span>
    <span v-if="item.type===1" :key="item.id">文字+文字</span>
    <span v-else :key="item.id">其他</span>
  </template>
</div>
```

`vue` 中会优先执行 `v-for`, 当 `v-for` 把所有内容全部遍历之后 , `v-if` 再对已经遍历的元素进行删除 , 造成了加载的浪费 , 所以应该尽量在执行 `v-for` 之前优先执行 `v-if` , 可以减少加载的压力。







### 为什么组件中的data必须是函数形式？

- Vue解析组件标签时，会创建一个新的组件实例对象
- 每个组件实例对象, 都需要有自己的data数据对象
- 如果data配置是对象, 就会导致同个组件的多个实例共享一个data对象
- 如果data是函数, 组件的多个实例的data对象是各自的, 是多份



### 如何理解vue的渐进式

![](https://img-blog.csdn.net/201806191038393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6dW5rdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



所谓的渐进式框架,就是把框架分层.

最核心的部分是视图层渲染,然后往外是组件机制,在这个基础上再加入路由机制,再加入状态管理,最外层是构建工具.

所谓分层,就是说你既可以只用最核心的视图层渲染功能来快速开发一些需求,也可以使用一整套全家桶来开发大型应用.




### Vue实例的生命周期

#### 是什么

> 每个 Vue 实例在被创建时都要经过一系列的初始化过程, 这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同阶段添加自己的代码的机会


#### Vue生命周期说明

* 有什么
* 三个阶段
  * 挂载阶段=>beforeCreate、created、beforeMounted、mounted
  * 更新阶段=>beforeUpdate、updated
  * 销毁阶段 beforeDestroy、destroyed
* 每个阶段适合干什么
  * created：实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求
  * 页面的初始化 beforeMount 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 
  * mounted：实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求
  * beforeupdate：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 
  * updated：虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作避免在这个钩子函数中操作数据，可能陷入死循环 
  * beforeDestroy：实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例，常用于销毁定时器、解绑全局事件、销毁插件对象等操作

| 生命周期钩子    | 说明                                                         | 对应上述步骤   |
| --------------- | ------------------------------------------------------------ | -------------- |
| `beforeCreate`  | 初始化实例前，`data`、`methods`等不可获取                    | 1 之后，2 之前 |
| `created`       | 实例初始化完成，此时可获取`data`里数据和`methods`事件，无法获取 DOM | 2 之后，3 之前 |
| `beforeMount`   | 虚拟 DOM 创建完成，此时未挂载到页面中，`vm.$el`可获取未挂载模板 | 3 之后，4 之前 |
| `mounted`       | 数据绑定完成，真实 DOM 已挂载到页面，`vm.$el`可获取真实 DOM  | 4 之后         |
| `beforeUpdate`  | 数据更新，DOM Diff 得到差异，未更新到页面                    | 5 之后，6 之前 |
| `updated`       | 数据更新，页面也已更新                                       | 6 之后         |
| `beforeDestroy` | 实例销毁前                                                   | 7 之前         |
| `destroyed`     | 实例销毁完成                                                 | 7 之后         |



#### 重要生命周期函数（开发中常用） 

- **created / mounted** 

  发送AJAX请求、设置定时器等一次性任务

  created速度更快

- **beforeDestroy** 

  做一些收尾工作：取消AJAX请求，清除定时器等

#### 周期函数补充

- 动态组件

  `<component :is="comName"></component>`  is属性来切换不同的组件

  正常传入props数据就可以接受到

- 缓存组件

  ```vue
  <keep-alive :include="['a','b']>
    <component :is="view"></component>
  </keep-alive>
  ```

- **errorCaptured(errObj, errVM, errMsg)**

  捕获一个来自子孙组件的错误时被调用

  return false // 阻止错误继续向上传播，并且不会在浏览器控制台抛出错误

  参数：错误对象，抛出错误的实例，错误信息



动态`<component>`案例

```vue
// src/comopnents/baseComponents/baseForm/index.vue

<template>
	<div @clik.stop>
    <component
    	:is="componentId"
      v-bind="$attrs"
      @click="(param) => this.$emit('click', param)"
    ></component>
  </div>
</template>


<script>
	import baseInput from "./baseInput"
  import baseSelect from "./baseSelectCustom"; // 定制版
  import baseTime from "./baseTime";
  import baseCheck from "./baseCheck";
  import baseJudge from "./baseJudge";
  import baseupload from "./baseupload";
  import baseSelectQuery from "./baseSelectQuery";
  import baseSelectQuery_two from "./baseFromMask_two";
  import baseSearchShll from "./baseSearchShll";
  import baseCheckTwo from "./basecheckTwo";
  import baseTime_two from "./baseTime_two";
  import baseCheckthree from "./baseCheckthree";
  import baseInputTwo from "./baseInputTwo";
  import baseuploadMetering from "./baseuploadMetering";
  import baseInputSelects from "./baseInputSelects";
  import basejudeFlag from "./basejudeFlag"
  import basePopup from "./baseInputpopup";
  import baseInforSearchShll from "./baseInforSearchShll";
  import baseTimeashdas from "./baseTimeashdas";
  import baseJudges from "./baseJudges";
  import baseJudgetb from "./baseJudgetb";
  
  export default {
    name: 'baseFrom',
    components: {
      baseInput,
      baseSelect,
      baseTime,
      baseCheck,
      baseJudge,
      baseupload,
      baseSelectQuery,
      baseSelectQuery_two,
      baseSearchShll,
      baseCheckTwo,
      baseTime_two,
      baseCheckthree,
      baseInputTwo, 
      baseuploadMetering,
      baseInputSelects,
      basejudeFlag,
      basePopup,
      baseInforSearchShll,
      baseTimeashdas,
      baseJudges,
      baseJudgetb,
    },
    props: {
      type: {type:String, default: '1'}
    },
    computed: {
      componentId() {
        return [
          "baseInput",//ok
          "baseSelect",//ok
          "baseTime",//ok
          "baseCheck",//ok
          "baseJudge",//ok
          "baseupload",//该组件默认不可修改
          "baseSelectQuery",//ok
          "baseSelectQuery_two",//
          "baseSearchShll",//9
          "baseCheckTwo",//ok
          "baseTime_two",//ok
          "baseCheckthree",//ok
          "baseInputTwo", //13ok
          "baseuploadMetering", // 14
          "baseInputSelects",//15
          "basejudeFlag",//16
          "basePopup",
          'baseInforSearchShll',//18ok
          'baseTimeashdas',//19ok
          'baseJudges',//20ok
          'baseJudgetb',//21ok
        ][this.type - 1];
      }
    }
  }
</script>
```



```vue
// 其他组件调用baseForm

<!-- 发电用户普查 -->
<article class="publicData" v-show="powerUsers">
  <template v-for="(item, index) in publicEntryList">
	<baseFrom
          v-if="[19].indexOf(index) != -1"
          :key="index"
          v-bind="item"
          v-model="publicEntryList[index]"
          @click="entryList($event, item, index)"
          />
  </template>
</article>
```



##### 在缓存组件的基础上存在的声明周期

- **activated()**

  每次缓存组件被激活时就会调用

- **deactivated()**

  缓存的组件停用时调用，可替代destroyed



#### 父子组件生命周期

加载渲染过程

父 beforeCreate -> 父 created -> <span style="color:blue">父 beforeMount -></span><span style="color:red"> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted </span>-> <span style="color:blue">父 mounted</span>

子组件更新过程

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

父组件更新过程

父 beforeUpdate -> 父 updated

销毁过程

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed


#### 父组件可以监听到子组件的生命周期吗？
比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：
```ts
// Parent.vue
<Child @mounted="doSomething"/>
    
// Child.vue
mounted() {
  this.$emit("mounted");
}
```

以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：
```ts
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...  
```
当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。



### keep-alive
keep-alive是vue的内置组件，能在组件切换过程中将状态保留在内存中，相当于缓存，防止DOM的重复渲染；
* keep-alive有三个属性：include（只有名字匹配的才会被缓存）、exclude（任何名字匹配的都不会被缓存）、max（最多可以缓存多少个组件）。
* 一般结合路由和动态组件一起使用，用于缓存组件；
* 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
* 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。

#### 钩子顺序
得出结论
初始进入和离开 created ---> mounted ---> activated --> deactivated
后续进入和离开 activated --> deactivated

### v-model 的原理？
我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
* text 和 textarea 元素使用 value 属性和 input 事件；
* checkbox 和 radio 使用 checked 属性和 change 事件；
* select 字段将 value 作为 prop 并将 change 作为事件。
以 input 表单元素为例：
```vue
<input v-model='something'>
    
//相当于
<input v-bind:value="something" v-on:input="something = $event.target.value">
```
如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：
```js
父组件：
<ModelChild v-model="message"></ModelChild>

子组件：
<div>{{value}}</div>

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
}
```

但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于[不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value)。<span style="color:blue;">**`model` 选项**可以用来声明v-model传递的属性和事件名称</span>,仍需要在组件的props选项中声明这个属性.

```html

<script>
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean  //props中需要接收绑定传递的v-model属性
  },
  template: `
  	<input
  		type="checkbox"
  		v-bind:checked="checked"
  		v-on:change="$emit('change', $event.target.value)"
  `
})
</script>  


<base-checkbox v-model="test"></base-checkbox>
```





### Vue.use
1. 自定义Vue插件需要向外暴露对象或者是函数
2. 如果向外暴露对象的话，对象中必须有install方法
3. 如果向外暴露的是函数的话，那么该函数本身就是install方法
4. 当Vue.use()的时候，会自动调用install方法，并且将Vue对象作为实参传入到install方法中

```js

//main.js
import Directives from './directives'
Vue.use(Directives)


//directives/index.js
import copy from "./copy";
import longpress from "./longpress";
import debounce from "./debounce";
import emoji from "./emoji";
import lazyLoad from "./lazyLoad";
import permission from "./permission";
import waterMarker from "./waterMaker";
import draggable from "./draggable";

  

const directives = {
	copy,
	longpress,
	debounce,
	emoji,
	lazyLoad,
	permission,
	waterMarker,
	draggable
};

export default {
	install(Vue) {
		Object.keys(directives).forEach((key) => {
			Vue.directive(key, directives[key]);
		});
	}
};
```






### 父子组件的生命周期

```js
子组件初始化: 在父组件beforeMount-->mounted之间 执行beforeCreated->mounted4个钩子
子组件更新: 在父组件beforeUpdate->updated之间 执行2个钩子
子组件死亡: 在父组件beforeDestroy->destroyed之间 执行2个钩子
```

- 初始化:
  - beforeCreate
  - created
  - beforeMount
  - *--child beforeCreate*
  - *--child created*
  - *--child beforeMount*
  - *--child mounted*
  - mounted
- 更新:
  - beforeUpdate
  - *--child beforeUpdate*
  - *--child updated*
  - updated
- 死亡:
  - beforeDestroy
  - *-- child beforeDestroy*
  - *-- child destroyed*
  - destroyed

### 带缓存的路由组件生命周期keep-alive

```js
路由组件添加<keep-alive></keep-alive>之后,在mounted之后会出现activated
总结:路由组件生命钩子activated是在挂在mounted之后.离开的路由组件生命周期钩子deactivated是在进入的路由组件生命钩子mounted之前调用

(路由组件,activated是在自身mounted之后;deactivated是在进入其他路由组件mounted之前调用)
当前组件激活总是最后一个

 同级路由组件:离开一个进入一个 ++表示进入的路由组件,没有加的表示离开的路由组件
++beforeCreate
++created
++beforeMount
 deactivated
++mounted
++activated
```



- 初始化:
  - ...
  - mounted
  - *--Child activated*
  - activated
- 路由离开
  - *--Child deactivated*
  - deactivated
- 路由回来
  - *--Child activated*
  - activated

### 捕获子组件错误的勾子

- 子组件执行抛出错误
  - errorCaptured

```js
父组件中调用这个钩子:
errorCaptured(err,child,info){
    console.log('errorCaptured')
    console.log(err,child,info)  //打印的错误是灰色的
    return false;//不再向外传递,说明当前已经处理了错误
}
```



### 各个生命周期勾子说明

![vue组件生命周期详图.png](https://i.loli.net/2021/04/03/t4AIhPlnpNe8i9d.png)

(1) beforeCreate(): 在实例初始化之后调用, data和methods都还没有初始化完成, 通过this不能访问

初始化data与methods/computed

(2) created(): 此时data和methods都已初始化完成, 可以通过this去操作, 可以在此发ajax请求

编译模板

(3) beforeMount(): 模板已经在内存中编译, 但还没有挂载到页面上, 不能通过ref找到对应的标签对象

插入到界面上显示

(4) mounted(): 页面已经初始显示, 可以通过ref找到对应的标签, 也可以选择此时发ajax请求



n次更新数据

(5) beforeUpdate(): 在数据更新之后, 界面更新前调用, 只能访问到原有的界面

更新界面

(6) updated(): 在界面更新之后调用, 此时可以访问最新的界面



**销毁组件/ v-if隐藏/离开不缓存的路由组件**
(7) beforeDestroy(): 实例销毁之前调用, 此时实例仍然可以正常工作
(8) destroyed(): Vue 实例销毁后调用, 实例已经无法正常工作了
(9) deactivated():组件失活, 但没有死亡
(10) activated(): 组件激活, 被复用
(11) errorCaptured(): 用于捕获子组件的错误,return false可以阻止错误向上冒泡(传递)



### Vue的响应式
- **组件的data为什么只能是函数不能是对象?**
- 同一个组件的多个组件实例的data必须是不同的对象(内容初始数据可以相同)
  - 如果是data是对象, 组件的多个实例共用一个data对象
  - 如果是函数, 组件对象通过调用函数得到的一个新的data对象
- **响应式数据与非响应式数据?**
  - 响应式: data / props / computed/ vuex的state与getters
  - 非响应式:　仅仅存在于组件对象上的属性数据
    - 给组件对象添加一个新属性: this.xxx = value 
    - 直接给一个响应式对象添加一个新属性: this.product.xxx = 'abc'  ==> this.$set(this.product, 'xxx', 3)
- **对象的响应式与数组的响应式有什么区别?**
  - 对象: 通过Object.defineProperty()添加setter方法来监视属性数据的改变 + 订阅-发布
  - 数组: 重写数组一系列的更新数组元素的方法 + 订阅-发布(pop/push/shift/unshift/splice/sort/reverse)

```js
//vue种数组实现响应式为什么不用object.defineProperty
1.如果使用defineProperty,数组作为对象形式,只能通过下标属性来修改属性
2.假设数组元素过多,就需要为每一个元素添加这个属性, 使用方法效率高于此种方式.

重写数组方法的限制: 只能通过7个方法来更新数据.
```




#### 3) Vue双向数据绑定

- 通过v-model来实现双向数据绑定
- v-model的本质
  - 将动态的data数据通过value属性传给input显示  ==> data到view的绑定
  - 给input标签绑定input监听, 一旦输入改变读取最新的值保存到data对应的属性上 ==> view到data的绑定
- 双向数据绑定是在单向数据绑定(data-->view)的基础, 加入input事件监听(view ==> data)



#### 4) 响应式原理面试交流总结

```js
dev是依赖对象,是中间人
watcher 监视器
```

- 初始化
  - 实现数据代理
    - 通过defineproperty给vm定义与data中属性对应的带getter/setter的属性
    - 在getter中, 读取data中对应的属性值返回      ==> 读取this.msg ==> 读取的是data中msg属性值
    - 在setter中, 将最新值保存到data对应的属性上   ==> this.msg = 'abc'   ==> 'abc'会保存到data的msg上
  - 创建observer
    - 目标: 对data中所有层次的属性进行监视/劫持
    - 通过defineproperty给data中所有层次属性, 都重新定义, 加上getter与setter
      - getter: 用来建立dep与watcher的关系   
      - setter: 用来当data数据发生改变去更新界面
    - 为data中所有层次的属性创建一个对应的dep   ==> 用来将来更新界面的
  - 创建compile
    - 目标1: 实现界面的初始化显示
    - 目标2: 为将更新做准备
      - 为模板中每个包含表达式(事件表达式除外)的节点创建一个对应的watcher
      - 给watcher绑定用于更新对应节点的回调函数
      - 将watcher添加到n个对应的dep中 

- 更新
  - this.msg = 'abc'
  - 由于有数据代理 ==> data的msg更新为了'abc'
  - 由于有数据劫持 ==> data中msg的setter调用了
  - 在setter中, 通过对应的dep去通知所对应的watcher去更新对应的节点     ==> 使用了订阅发布模式


#### 问题: Vue.use()内部做了什么?

- 对象插件: 调用插件对象的install方法(传入Vue)来安装插件(执行定义新语法的代码)
- 函数插件: 直接将其作为install方法来调用(传入Vue)来安装插件(执行定义新语法的代码)


## Vue面试题
> https://gitee.com/zxfjd3g/wh221017_vue2-study


### 面试题资源
> https://vue3js.cn/interview/
> https://juejin.cn/post/6844903918753808398
> https://www.cnblogs.com/wenshaochang123/p/14888494.html


### 什么是MVVM,与MVC的区别
#### 是什么
是一种用于设计用户界面的软件架构模式，它是一种将应用程序 UI 与后端数据及逻辑分离的模式。
Model代表数据模型，定义数据操作的业务逻辑，
View代表视图层，负责将数据模型渲染到页面上，
ViewModel通过双向绑定将View和Model进行同步交互，不需要手动操作DOM的一种设计思想。
#### 区别
mvc是单向的，而mvvm是双向的，并且是自动的，也就是数据发生变化自动同步视图，视图发生变化自动同步数据，同时解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。



### 说说你对 SPA 单页面的理解，它的优缺点分别是什么？
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
**优点：**
* 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
* 基于上面一点，SPA 相对对服务器压力小；
* 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**
* 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
* 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
* SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。





### 为什么data要写成一个函数

### vue的常见指令有哪些(8个以上)?

v-model v-on v-bind v-for v-if/else/else-if  v-show v-slot

v-pre v-cloak v-once

### vue动态绑定样式有哪些方式

1. 三元表达式

```html
<div :class="ifShow ? 'new-class' : 'old-class' "> </div>
data: { ifShow: true },
<style>
.new-class {}
.old-class {}
</style>
```

2. 设置一个对象的方式

```html
<div :class=" {'new-class': isShowNew, 'old-class': isShowOld}"> </div>
data: { isShowNew: true, isShowOld: old },
<style>
.new-class {}
.old-class {}
</style>
```

3. 设置一个数组的方式

```html
<div :class="['class1', 'class2']"></div>
<style>
.class1 {}
.class2 {}
</style>
```

### v-model的本质?

v-model的使用场景是在表单元素中，它实现了双向绑定。v-bind是单向绑定，只能将vue中的数据同步到页面，而v-model不只能将vue中的数据同步到页面，还可以将用户数据的数据赋值给vue中的属性

input事件+value属性实现双向数据绑定



### v-model有哪些修饰符

v-model指令有以下内置的修饰符：`.lazy`、`.number`、`.trim`。

`.lazy`修饰符. 在默认情况下，v-model指令会在input事件中同步输入框中的数据，而使用`.lazy`修饰符后，v-model指令会在change事件后进行同步.
`.number`修饰符表示将用户输入的值转换为数字类型
`.trim`修饰符表示自动过滤用户输入的首尾空格

如果需要自定义修饰符，可以使用Vue.directive()方法来定义一个全局的自定义指令

### v-on在事件函数中如何获取event事件对象

vue中事件分成原生事件和自定义事件,它们对应的传参方式也不相同.

添加`.native`修饰符后是原生事件, 事件方法中的参数是事件对象event

自定义组件/非原生dom事件中,使用$event来表示事件对象









### v-on的事件修饰符与按键修饰符

#### 事件修饰符

方法只有纯粹的数据逻辑，而不是去处理DOM事件细节。为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**。之前提过，修饰符是由点开头的指令后缀来表示的。

事件修饰符有:
* stop  阻止事件冒泡
* prevent 阻止默认事件
* capture 使用事件捕获
* self 只当在 event.target 是当前元素自身时触发处理函数
* once 只会触发一次
* passive 滚动事件默认行为立即触发


#### 按键修饰符

在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：

可以直接将 [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) 暴露的任意有效按键名转换为 kebab-case 来作为修饰符. 例如enter,page-down等

**按键码**

`keyCode` 的事件用法[已经被废弃了](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode)并可能不会被最新的浏览器支持。







### v-if和v-show的区别

v-if和v-show都可以控制元素的显示或隐藏，但是它们的实现方式不同。v-show是通过改变元素的display样式属性来控制元素的显示或隐藏，而v-if是通过动态地向DOM树内添加或删除DOM元素来实现的

这意味着，当使用v-show时，无论初始条件是什么，元素总是会被渲染；而当使用v-if时，只有当条件为真时才会渲染元素。因此，v-if有更高的切换消耗，而v-show有更高的初始渲染消耗

[如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则使用v-if较好









### 比较computed与watch和method

methods是用来定义函数的，它需要手动调用才能执行。相比于watch和computed，methods不处理数据逻辑关系，只提供可调用的函数。

computed是计算属性，它的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用。

watch是一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作。可以看作是computed和methods的结合体。

总之，methods是用来定义函数的；computed是计算属性，它会根据依赖关系进行缓存计算；而watch则是监听数据变化并执行相应操作。



### vue中对象响应式处理和数组响应式处理的区别

#### 对象

对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 `Vue.set(object, propertyName, value)` 方法或 `vm.$set`实例方法, 向嵌套对象添加响应式 property

需要为已有对象赋值多个新 property，比如使用 `Object.assign()` 或 `_.extend()`

#### 数组

Vue 不能检测以下数组的变动：

1. 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
2. 当你修改数组的长度时，例如：`vm.items.length = newLength`

为了解决第一类问题，以下两种方式:

```
// Vue.set  vm.$set
Vue.set(vm.items, indexOfItem, newValue)
vm.$set(vm.items, indexOfItem, newValue)

// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```



为了解决第二类问题，你可以使用 `splice`：

vm.items.splice(newLength)









### Vue.set和Vue.delete的基本原理



#### 背景

Vue.set和Vue.delete是Vue提供的两个API，用于向响应式对象添加或删除属性。

由于Vue在初始化实例时会对property执行getter/setter转换，所以property必须在data对象上存在才能让Vue将它转换为响应式的。这意味着，对于已经创建的实例，Vue不允许动态添加根级响应式属性。但是，可以使用Vue.set方法向嵌套对象添加响应式属性。此外，还可以使用vm.$set实例方法，这也是全局Vue.set方法的别名。

同理，Vue.delete方法用于删除对象的属性。如果该属性是响应式的，则删除后视图也会更新。此外，还可以使用vm.$delete实例方法，这也是全局Vue.delete方法的别名。



#### 语法

Vue.set

Vue.set(obj, key, val) 的作用是在对象 obj 中添加属性 key 并将其值设置为 val 。如果 obj 是响应式的，当添加了新属性后，新属性也将是响应式的，并触发视图重新渲染。

例如：

```
Vue.set(vm.obj, 'newKey', 'newValue');
```

Vue.delete

Vue.delete(obj, key) 的作用是删除对象 obj 中的属性 key。如果 obj 是响应式的，则删除后也会立即触发视图重新渲染。

例如：

```
Vue.delete(vm.obj, 'keyToDelete');
```



#### 原理

Vue.set 和 Vue.delete 的基本原理是**通过调用 Observer 对象上的 defineReactive 方法来实现的**。当给响应式对象添加或删除属性时，Observer 会监听到对象的变化并通知 Dep 对象，Dep 再通知 Watcher 更新视图。

总之，Vue.set 和 Vue.delete 提供了一种方便且安全地修改 Vue 实例中响应式数据的方式。



### 描述Vue2的生命周期

### vue2中new Vue之后做了什么事情?

在Vue2中，当我们使用new Vue()创建一个Vue实例时，会发生以下事情：

1. 初始化：Vue实例的_init方法会被调用。这个方法会合并配置，初始化生命周期，初始化事件，初始化渲染，初始化data、props、computed、watcher等。
2. 挂载：如果创建实例时传入了el选项，实例将立即进入挂载阶段。否则，需要手动调用vm.$mount方法才能触发挂载。在挂载阶段，Vue会将模板编译成渲染函数，并生成虚拟DOM，最终更新DOM。
3. 渲染更新：当实例中的响应式数据发生变化时，会触发重新渲染和更新DOM。

总之，在Vue2中，new Vue()会创建一个Vue实例，并执行初始化和挂载操作。





### 说说Vue与组件间之间的关系

在Vue中，组件是可复用的Vue实例，它们与新创建的Vue实例有着类似的选项，例如data、computed、watch、methods以及生命周期钩子等。

组件可以分为全局组件和局部组件。全局组件可以在任何新创建的Vue根实例的模板中使用，而局部组件则只能在注册它们的实例的模板中使用。

Vue通过组件化的方式实现了正交性（Orthogonality），即组件只关心自己的内部状态和行为，不依赖于其他组件的状态和行为。这种设计方式使得我们可以更加方便地维护和重用组件，同时也提高了应用的可读性和可测试性。

总之，组件是Vue中的核心概念，它们是构建用户界面的基本单元。组件可以嵌套、复用和传递数据，使得我们可以更加方便地构建复杂的应用程序。









### scoped样式的作用和原理

当 `<style>` 标签有 `scoped` 属性时，它的 CSS 只作用于当前组件中的元素。



使用 `scoped` 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。





**原理**

在编译阶段，Vue会为每个组件生成一个唯一的属性（例如data-v-xxxxx），并将其添加到组件模板中的所有元素上。同时，Vue还会修改组件中的CSS选择器，在每个选择器后面添加一个对应的属性选择器（例如[data-v-xxxxx]）。这样，组件中的样式就只能作用于拥有对应属性的元素上。



### 深度作用域选择器的作用和原理

当我们使用scoped样式时，有时候我们需要为子组件中的元素定义样式。但是由于scoped样式的限制，我们不能直接在父组件中为子组件中的元素定义样式。这时候，我们就可以使用深度作用域选择器。

深度作用域选择器有两种形式：>>>和/deep/(`::v-deep`)。它们的作用是一样的，都是用来穿透scoped样式的限制，为子组件中的元素定义样式。









### vue中的组件通信方式和特点

### 过滤器是什么？如何定义？如何使用?

#### 是什么

Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。

过滤器可以用在两个地方：**双花括号插值和 `v-bind` 表达式** 。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示



#### 使用

```vue
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```



你可以在一个组件的选项中定义本地的过滤器; 或者在创建 Vue 实例之前全局定义过滤器

```vue
//本地
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
//全局
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```

过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。





### 自定义指令用来做什么？如何定义？如何使用?

在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然**需要对普通 DOM 元素进行底层操作**，这时候就会用到自定义指令。例如页面加载完成后输入框获得焦点.



**如何定义**

* 全局自定义指令
* 局部自定义指令

```vue
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
```

```vue
//局部自定义指令
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
```



**钩子函数**

- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。

- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
- `unbind`：只调用一次，指令与元素解绑时调用。

**钩子函数参数**
- `el`：指令所绑定的元素，可以用来直接操作 DOM。
- `binding`: 一个对象，包含以下 property：
  - `name`：指令名，不包括 `v-` 前缀。
  - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`。
  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。
  - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。
  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。
- `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://cn.vuejs.org/v2/api/#VNode-接口) 来了解更多详情。
- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用

除了 `el` 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 [`dataset`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset) 来进行。




#### 自定义指令案例
> [面试官：你有写过自定义指令吗？自定义指令的应用场景有哪些？ | web前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/vue/directive.html#%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
> 


一键copy功能

```js
const copy = {
	bind(el, { value }) {
		el.$value = value;

		el.handler = () => {
			if (!el.$value) {
				//值为空的时候,给出提示
				console.log("没有复制内容");
				return;
			}

			// 创建动态textarea标签
			const textarea = document.createElement("textarea"); 
			// 将textarea设为readonly, 放置iOS下自动唤起键盘,同时将textarea移除可视区域
			textarea.readOnly = "readonly";
			textarea.style.position = "absolute";
			textarea.style.left = "-9999px"; // 将要copy的值赋给textaread标签value属性
			textarea.value = el.$value; // 将textarea插入到body中
			document.body.appendChild(textarea); // 选中值并复制
			textarea.select();
			const result = document.execCommand("Copy");
			if (result) {
				console.log("copy success");
			}
			document.body.removeChild(textarea);
		}; // 绑定点击事件,就是一键copy

		el.addEventListener("click", el.handler);
	}, // 当传进来的值更新时触发

	componentUpdate(el, { value }) {
		el.$value = value;
	}, // 指令与元素解绑的时候,移除事件绑定

	unbind(el) {
		el.removeEventListener("click", el.handler);
	},
};

export default copy;
```



### vue的插件是什么，如何定义？如何使用？

Vue的插件是一个可以扩展Vue功能的功能模块。它们允许您在全局或组件级别注册新的全局功能、指令、过滤器或自定义组件，以及为现有Vue实例添加属性或方法。

插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

1. 添加全局方法或者 property。如：[vue-custom-element](https://github.com/karol-f/vue-custom-element)
2. 添加全局资源：指令/过滤器/过渡等。如 [vue-touch](https://github.com/vuejs/vue-touch)
3. 通过全局混入来添加一些组件选项。如 [vue-router](https://github.com/vuejs/vue-router)
4. 添加 Vue 实例方法，通过把它们添加到 `Vue.prototype` 上实现。
5. 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 [vue-router](https://github.com/vuejs/vue-router)



#### 使用插件

通过全局方法 `Vue.use()` 使用插件。它需要在你调用 `new Vue()` 启动应用之前完成：

```vue
// 调用 `MyPlugin.install(Vue)`
Vue.use(MyPlugin)

new Vue({
  // ...组件选项
})

```

也可以传入一个可选的选项对象：

```vue
Vue.use(MyPlugin, { someOption: true })
```







### 混入是什么? 如何定义?如何使用?

一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用。

数据对象data在内部会进行递归合并，并在发生冲突时以组件数据优先

值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。



使用

```vue
var mixin = {
  data: function () {
    return {
      message: 'hello',
      foo: 'abc'
    }
  }
}

new Vue({
  mixins: [mixin],
  data: function () {
    return {
      message: 'goodbye',
      bar: 'def'
    }
  },
  created: function () {
    console.log(this.$data)
    // => { message: "goodbye", foo: "abc", bar: "def" }
  }
})
```







### 说说Vue插槽的理解和分类

#### 概述

插槽就是子组件中的提供给父组件使用的一个占位符，用slot /slot 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的slot /slot标签。

为`<slot>`元素设定了内容，那么该内容会在组件没有接收到内容时被当作默认内容使用。

可以简单理解为更复杂的prop属性



#### 分类

* 具名插槽
* 作用域插槽

注意 **`v-slot` 只能添加在 `<template>` 上** (只有[一种例外情况](https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95))，这一点和已经废弃的 [`slot` attribute](https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95) 不同。

**具名插槽**

具名插槽具有一个`name='xxx'`名称，它允许你在同一个组件中拥有多个插槽。

在模板中引用这个组件时，可以使用`v-slot='xxx'`属性来指定某个元素应该被插入名为`xxx`的插槽

```vue
//父组件
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>


//子组件
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```





**作用域插槽**

插槽内容能访问子组件中的数据

1. 绑定在 `<slot>` 元素上的 attribute 被称为**插槽 prop**。
2. 在父级作用域中，我们可以使用带值的 `v-slot` 来定义我们提供的插槽 prop 的名字

```vue
//子组件
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>


//父组件
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>
```





### vuex的流程结构图

### vuex的模块化如何书写？如果读取模块化中的数据或者方法

当应用程序变得越来越复杂时，我们可能需要将Vuex的状态分割成多个模块，以便更好地管理和维护。Vuex允许我们将store分割成模块，每个模块都拥有自己的state、mutation、action、getter和嵌套子模块。

**要读取模块中的状态或调用模块中的方法，我们需要在访问路径前加上模块的名称**。例如，在上面的例子中，如果我们想要读取myModule模块中的count状态，可以这样写：

```javascript
store.state.myModule.count
```

同样，如果我们想要调用myModule模块中的increment方法，可以这样写：

**要读取模块中的状态或调用模块中的方法，需要在访问路径前加上模块的名称**。

```javascript
store.dispatch('myModule/increment')
```





### vuex的数据持久化是什么？可以解决什么问题

Vuex是一个专为Vue.js应用程序开发的状态管理模式。它可以集中管理应用程序中所有组件的状态，并以一种可预测的方式进行状态变更。

然而，Vuex的状态存储是响应式的，当页面刷新或关闭时，Vuex的状态将会丢失。这就意味着，如果我们希望在页面刷新或关闭后仍然保留Vuex的状态，就需要进行数据持久化。

数据持久化指的是将Vuex的状态保存到客户端，例如localStorage、sessionStorage或cookie等，以便在页面刷新或关闭后仍然能够访问这些状态。

数据持久化可以解决Vuex状态丢失的问题。例如，我们可以在用户登录后将用户信息保存到Vuex中，并进行数据持久化。这样，即使用户刷新页面或关闭浏览器，我们仍然能够访问用户信息。

总之，Vuex的数据持久化指的是将Vuex的状态保存到客户端，以便在页面刷新或关闭后仍然能够访问这些状态。它可以解决Vuex状态丢失的问题。







### 区别路由中history模式和hash模式

* url格式不同
* 兼容性不同 history模式只能兼容到IE10,hash可兼容到IE8
* 实现原理不同
  * hash模式: 通过window.onhashchange监听hash的改变，借此实现无刷新跳转的功能。
  * history模式: 利用了HTML5 History Interface中新增的pushState()和replaceState()方法
* 网络请求/服务器配置
  * hash模式: 地址改变时通过 hashchange 事件，只会读取哈希符号后的内容，并不会发起任何网络请求。
  * history模式: 每访问一个页面都要发起网络请求，每个请求都需要服务器进行路由匹配、数据库查询、生成HTML文档后再发送响应给浏览器
  * history模式,重新刷新需要服务端配置否则出现404页面
* seo优化

### 如何配置默认路由和默认子路由

在 Vue Router 中，可以通过 `redirect` 属性来配置默认路由。`redirect` 属性可以接受一个路由的路径或一个对象，这个对象包含 `path` 属性和 `query` 属性。

下面是一个使用 `redirect` 属性来配置默认路由的例子：

```js
import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from './views/Home.vue';
import About from './views/About.vue';

Vue.use(VueRouter);

const routes = [
  { path: '/', redirect: '/home' },
  { path: '/home', component: Home },
  { path: '/about', component: About }
];

const router = new VueRouter({
  routes
});

export default router;
```

在 Vue Router 中，可以通过 `children` 属性来配置子路由。如果一个路由配置对象中包含 `children` 属性，则说明这是一个父级路由对象，它下面可以包含多个子路由。在父级路由对象中使用 `redirect` 属性可以配置默认子路由。

下面是一个使用 `children` 属性来配置默认子路由的例子：

```js
import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from './views/Home.vue';
import About from './views/About.vue';
import Contact from './views/Contact.vue';

Vue.use(VueRouter);

const routes = [
  { path: '/', redirect: '/home' },
  { path: '/home', 
   component:    Home, 
   children: [
      { path: '/', redirect: 'contact' },
      { path: 'about', component: About },
      { path: 'contact', component: Contact }
    ]
  }
];

const router = new VueRouter({
  routes
});

export default router;
```













### Router对象和Route对象的区别



### 编程式路由导航和声明式路由导航区别？

- 编程式路由导航：通过代码进行路由的跳转，在组件内部通过 `$router` 对象来操作路由，使用 `$router.push`、`$router.replace` 和 `$router.go` 等方法来实现路由的切换，主要适用于需要在某些场景下进行特定路由跳转的情况。
- 声明式路由导航：在模板中使用 Vue Router 提供的组件（如 `<router-link>`）来实现路由的跳转，通过设置 `to` 属性来指定目标路由地址，当用户点击这些组件时，路由会自动进行跳转，非常适用于需要在页面间进行切换的场景。



### 编程式路由导航重复导航报错？

### 缓存式路由组件？

- 当离开时, 路由组件会自动销毁, 再跳转回来, 需要重新创建
- 目标: 能不能让路由组件离开时不销毁, 再回来时, 直接复用
- 解决: 使用`<keep-alive>来包含<router-view>`, 就能让对应的路由组件离开时不销毁
- 作用: 能复活组件对象, 包含它的所有状态相关数据



### 路由懒加载

### 路由组件间通信方式

### 路由的props如何指定?

### 组件内如果监听动态路由的数据改变

* 监听 `$route` 对象的变化

* 监听 `$route.params` 对象内的变化
* beforeRouteUpdate(to,from,next)



### 缓存组件的生命周期函数？

### 理解路由的导航守卫？

### 路由导航守卫的各个钩子函数

### 手写数据代理

### 手写数据劫持

### 手写Methods的初始化




## Vuex

### 概述下Vuex
Vue应用的状态管理模式.每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
* Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
* 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

主要包括以下几个模块：
State： 定义了应用状态的数据结构，可以在这里设置默认的初始状态。
Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。




### vuex多模块编程
- vuex的多模块编程的必要性
  - vuex单模块问题: 
    - 需要的管理状态数据比较多, 那对应的mutations/actions模块就会变得比较大
    - 如果添加新的数据管理, 需要修改现在文件(不断向其添加内容) 
  - vuex多模块编程: 对各个功能模块的数据分别进行管理, 这样更加具有扩展性

- 什么时候需要用vuex多模块编程? 需要vuex管理的数据比较多时使用
- 多模块编程的总state结构:

```js
{
	home: {
        categoryList: [],
        xxx: {}
    },
    user: {
        userInfo: {}
    }
}
```

### 问答题

#### vuex中的mutation可以执行异步操作吗?

- 可以 ==> 异步更新数据后界面确实会自动更新
- 问题 ==> vuex的调用工具监视不到mutation中的异步更新, 工具记录还是更新前的数据(不对)
- 扩展: 工具如何记录数据变化? ==> 每次mutation函数执行完后, 立即记录当前的数据   ==> 在mutation中同步更新state, 才能被记录到



#### vuex中的状态数据的响应式的原理?

1. 创建了一个vue实例(vm)对象

2. state中的数据都是实例的data数据(是响应式的)

3. 组件中读取的state数据本质读取的就是data中的数据

4. 一旦更新了state中的数据, 所有用到这个数据的组件就会自动更新



#### vuex数据刷新丢失的问题

```js
//数据丢失原因
1.	Vuex数据保存在运行内存中，vue实例初始化的时候为其分配内存
2.	当刷新页面的时候重新初始化Vue实例，所以重新为Vuex分配内存导致之前保存的数据丢失


//如何解决?
1.	Vuex的数据都是每次组件加载时候动态请求获取数据保存
a)	优点： 保证数据不会丢失
b)	缺点: 性能差，因为网络问题可能有网络延迟

2.	将Vuex中的数据每次同步更新保存到sessionStorage中
a)	优点: 每次页面刷新后从sessionStorage中获取保存的数据，不会丢失
b)	缺点: state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差

3.	在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取
a)	优点: 减少动态更新sessionStorage的次数，性能好
b)	重点: 给window绑定beforeupload事件监听

```

- 绑定事件监听: 在页面卸载(关闭)或刷新时候保存当前数据

```js
beforeCreate(){
    window.addEventListener('beforeunload', () => {
	sessionStorage.setItem('CART_LIST_KEY', 
		JSON.stringify(this.$store.state.shopCart.cartList))
	})
}
```

- 在初始时读取保存数据作为状态的初始值. 解决页面刷新数据丢失的问题

```js
//state中初始化属性值
cartList: JSON.parse(sessionStorage.getItem('CART_LIST_KEY')) || [],
```


#### vuex原理,组件传参方式
 构建一个vm,state中的数据都是实例的data属性
 组件传参方式? 先需要确认是否是组件和vuex传递数据
 组件->vuex dispatch commit
 vuex->组件: mapState,mapGetters

```js

```
#### 监听vuex自身数据
 两种方式获取vuex的state数据:  $store.state与mapState
 定义返回state数据的计算属性->通过watch监视这个计算属性->state变化,计算属性值,监视的回调

#### vuex理解
 - vuex是vue中集中式状态管理的一个插件,可以对组件共享状态进行集中式管理(管理:读写)
 - vuex是组件间通信的一种方式,可实现任意组件间通信.
 - 什么时候使用? 多个组件依赖同一状态,不同组件的行为要变更为同一状态: 购物车页面要根据登录状态来访问



#### vuex如何外部改变内部的值
 是组件更新了state中的数据:dispatch, commit
 模块化编程下,内部模块改变外部模块的值:
 
 
#### 对vuex的理解一些使用场景
 多个组件共享数据或者是跨组件传递数据时
 购物车的数据共享, 登录注册






## vue-router

### 声明式路由导航和编程式路由导航区别
- 跳转/导航路由的2种基本方式
  - 声明式路由: `\<router-link :to="{path: '/xxx'}" replace>xxx</router-link/>`
  - 编程式路由: `this.$router.push/replace(location)`

* 编程式路由导航：通过代码进行路由的跳转，在组件内部通过 `$router` 对象来操作路由，使用 `$router.push、$router.replace` 和 `$router.go` 等方法来实现路由的切换，主要适用于需要在某些场景下进行特定路由跳转的情况。

* 声明式路由导航：在模板中使用 Vue Router 提供的组件（如 `<router-link>`）来实现路由的跳转，通过设置 to 属性来指定目标路由地址，当用户点击这些组件时，路由会自动进行跳转，非常适用于需要在页面间进行切换的场景



#### 编程路由导航
>https://v3.router.vuejs.org/zh/guide/essentials/navigation.html


**参数:**
* 字符串
* path对象
* 命名路由对象
* 带查询参数的path对象

```js
// 字符串
router.push('home')

// 对象
router.push({ path: 'home' })

// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})

// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})
```

**注意**:
* 如果提供了 path，params 会被忽略
```js
const userId = '123'
router.push({ name: 'user', params: { userId }}) // -> /user/123
router.push({ path: `/user/${userId}` }) // -> /user/123

// 这里的 params 不生效
router.push({ path: '/user', params: { userId }}) // -> /user
```



### 跳转路由携带参数(数据)的方式
#### params参数
传参方式:
* 注册路由的时候需要声明占位符，{path: '路由路径/:name/:age'}  //name,age是占位符

跳转时指定参数值:
- /xxx/abc/12
* {name: 'xxx', params: {name: 'abc', age: 12}}

#### query参数
传参方式:
* 注册的路由的时候不需要做任何事情
* 请求时url路径中以?开始以&连接key=value的字符形式,例如`path?key=value&key2=value2`
* params和query同时使用,params参数要放在query前面.

获取
* query参数无需声明即可接收,接收通过计算属性 `this.$route.query`


#### props
> https://v3.router.vuejs.org/zh/guide/essentials/passing-props.html#布尔模式

传参方式:
* 布尔值(只能搭配params参数使用)
	* props: true, // 只能同名映射params参数
* 对象(用于自定义参数)
	* props: {a: 1, b: 'abc'}, // 只能映射非params/query参数
* 函数(自定义参数 + 路由信息)
    - props: route => ({keyword3: route.params.keyword, keyword4: route.query.keyword2, xxx: 12}), //可以指定任何数据都可以

//布尔模式
如果 props 被设置为 true，route.params 将会被设置为组件属性。
```js

const User = {
  props: ['id'],
  template: '<div>User {{ id }}</div>'
}


const router = new VueRouter({
  routes: [
    { path: '/user/:id', component: User, props: true },

    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
    {
      path: '/user/:id',
      components: { default: User, sidebar: Sidebar },
      props: { default: true, sidebar: false }
    }
  ]
})
```

//对象模式
如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。
```js
const router = new VueRouter({
  routes: [
    {
      path: '/promotion/from-newsletter',
      component: Promotion,
      props: { newsletterPopup: false }
    }
  ]
})
```


//函数模式
你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。
```js
const router = new VueRouter({
  routes: [
    {
      path: '/search',
      component: SearchUser,
      props: route => ({ query: route.query.q })
    }
  ]
})
```
URL /search?q=vue 会将 {query: 'vue'} 作为属性传递给 SearchUser 组件。



#### meta
传参方式:
* 注册的时候通过meta字段进行参数设置,指定包含n个数据的对象

获取数据
* `this.$route.meta.xxx`





#### `$router` VS `$route`的区别
* **$router**
路由器对象
用来控制路由的跳转，包含相关方法: push()/replace()/back()/addRoutes()
* **$route**
路由信息对象
包含当前路由的所有信息(path, query, params, meta)




### 路由模式
> https://juejin.cn/post/7116336664540086286


#### vue router实现原理
> vue-router  在实现单页面路由时，提供了两种方式：Hash  模式和  History  模式；vue2是 根据  mode  参数来决定采用哪种方式，默认是  Hash  模式，手动设置为  History  模式。更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有以下两种方式：


#### 3种路由模式
可以通过mode选项修改路由的模式。
* hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；
* history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；
* abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.


#### 特点
**hash**
hash，原本用来结合锚点控制页面视窗的位置，具有以下特点：
* 可以改变URL，但不会触发页面重新加载（hash的改变会记录在window.hisotry中）因此并不算是一次http请求，所以这种模式不利于SEO优化
* 只能修改#后面的部分，因此只能跳转与当前URL同文档的URL
* 只能通过字符串改变URL
* 通过window.onhashchange监听hash的改变，借此实现无刷新跳转的功能。

**history**
* history  是路由的另一种模式，在相应的  router  配置时将  mode  设置为  history  即可。
* history  模式是通过调用  window.history  对象上的一系列方法来实现页面的无刷新跳转。
* 利用了 HTML5 History Interface  中新增的   pushState()  和  replaceState()  方法。
* 这两个方法应用于浏览器的历史记录栈，在当前已有的  back、forward、go  的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会向后端发送请求。
* 新的URL可以是与当前URL同源的任意 URL，也可以与当前URL一样，但是这样会把重复的一次操作记录到栈中

#### hash和history的区别
* url格式不同
* 兼容性不同 history模式只能兼容到IE10,hash可兼容到IE8
* 实现原理不同
	* hash模式: 通过window.onhashchange监听hash的改变，借此实现无刷新跳转的功能。
	* history模式: 利用了HTML5 History Interface中新增的pushState()和replaceState()方法
* 网络请求/服务器配置
	* hash模式: 地址改变时通过 hashchange 事件，只会读取哈希符号后的内容，并不会发起任何网络请求。
	* history模式: 每访问一个页面都要发起网络请求，每个请求都需要服务器进行路由匹配、数据库查询、生成HTML文档后再发送响应给浏览器
	* history模式,重新刷新需要服务端配置否则出现404页面
* seo优化



#### 路由模式实现原理
**hash 模式的实现原理**
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：
```awk
https://www.word.com#search
```

**history 模式的实现原理**
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
```js
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
```

如何做到修改url参数页面不刷新

HTML5引入了 `history.pushState()` 和 `history.replaceState()` 方法，它们分别可以添加和修改历史记录条目。
```js
let stateObj = {
    foo: "bar",
};

history.pushState(stateObj, "page 2", "bar.html");
```

假设当前页面为 `foo.html`，执行上述代码后会变为 `bar.html`，点击浏览器后退，会变为 `foo.html`，但浏览器并不会刷新。



### 路由(导航)守卫
#### 是什么
导航守卫是vue-router提供的下面2个方面的功能
- 监视路由跳转  -->回调函数
- 控制路由跳转  -->  放行/不放行/强制跳转到指定位置    next()

#### 使用场景
- 在跳转到界面前, 进行用户权限检查限制(如是否已登陆/是否有访问路由权限)
- 在跳转到登陆界面前, 判断用户没有登陆才显示

#### 全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // 使用场景： 验证用户身份，判断用户是否登录
  if(isLogin){ // 如果登录，正常跳转至home
    next()
  }else { // 如果未登录就跳转至登录界面
    if(to.path === '/login'){
      next()
    }else {
      next('/login')
    }
  }
})
```

#### 全局解析守卫
- 这和 `router.beforeEach` 类似，区别是在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后**，解析守卫就被调用。
```js
router.beforeResolve((to, from, next) => {
  // 负责解析路由地址，加载对应的路由组件
})
```

#### 全局后置钩子
```js
router.afterEach((to, from) => {
  // 路由完全跳转后执行
})
```

#### 路由独享守卫
```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

#### 组件内的守卫
* beforeRouteEnter
* beforeRouteUpdate
* beforeRouteLeave
```js
beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
    // 因为当守卫执行前，组件实例还没被创建
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
},
beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
},
beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
}
```



### 完整导航解析流程

1. 导航被触发。
2. 在失活的组件里调用组件后置守卫 `beforeRouteLeave` 。
3. 调用全局前置守卫 `beforeEach` 。
4. 在重用的组件里调用 组件解析守卫`beforeRouteUpdate`  (2.2+)。
5. 在路由配置里调用路由前置守卫 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用组件前置守卫 `beforeRouteEnter`。
8. 调用全局解析守卫 `beforeResolve` (2.5+)。
9. 导航被确认。
10. 调用全局后置守卫 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用组件前置守卫 `beforeRouteEnter` 中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。



#### 触发钩子的完整顺序

> https://www.yuque.com/cuggz/interview/hswu8g#2c3f563ad7506984575f1a323937c5c0

路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件

- beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。
- beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。
- beforeEnter：路由独享守卫
- beforeRouteEnter：路由组件的组件进入路由前钩子。
- beforeResolve：路由全局解析守卫
- <u>afterEach：路由全局后置钩子</u>
- beforeCreate：组件生命周期，不能访问this。
- created;组件生命周期，可以访问this，不能访问dom。
- beforeMount：组件生命周期
- <u>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</u>
- mounted：访问/操作dom。
- <u>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</u>
- 执行beforeRouteEnter回调函数next。


### 问题

#### 路由懒加载
懒加载/异步加载: 请求对应的路径时才请求获取对应的打包文件
import动态引入的特点:
  单独打包(code split  代码分割): 被引入的模块会被单独打包
  单独打包是懒加载的前提
包含动态引入的函数: () => import('@/views/Home')
  开始不执行, 请求对应的路径时才会执行
  执行函数进才会请求加载对应的打包文件 

import静态引入:
  import xxx from '模块'
  会打包在一起

为什么要这么做: 主要为了提高首页的访问检验(更快), 访问首页时, 需要加载的打包文件更小了

**懒加载的缺点**: 访问其它路由更慢了 => 需要发请求加载对应的打包文件
解决: 预加载    提前加载后面需要其它的打包文件


#### 缓存路由组件
- 当离开时, 路由组件会自动销毁, 再跳转回来, 需要重新创建
- 目标: 能不能让路由组件离开时不销毁, 再回来时, 直接复用
- 解决: 使用`<keep-alive>来包含<router-view>`, 就能让对应的路由组件离开时不销毁
- 作用: 能复活组件对象, 包含它的所有状态相关数据




#### 如果指定name与params配置, 但params中数据是一个"", 无法跳转
* 解决1: 不指定params
* 解决2: 指定params参数值为undefined

#### 路由组件能不能传递props数据?
* 可以: 可以将query或且params参数映射成props传递给路由组件对象

```js
//在routes中配置
props: route=>({keyword1:route.params.keyword, keyword2: route.query.keyword })
```

#### 编程式路由航重复导航报错？
>跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误

##### 说明情况:
当编程式跳转到当前路由且参数数据不变, 就会出警告错误:
错误: `Avoided redundant navigation to current location` ==> 重复跳转当前路由
原因: 
vue-router在3.1.0版本(2019.8)引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise
说明文档: https://github.com/vuejs/vue-router/releases?after=v3.3.1

##### 解决方案
办法1: 在每次push时指定回调函数或catch错误
```js
push('/xxx', () => {})   ===> 声明式路由跳转本质就是这样执行的
push('/xxx').catch()
```

办法2: 重写VueRouter原型上的push方法 (比较好)
* 如果没有指定回调函数, 需要调用原本的push()后catch()来处理错误的promise
* 如果传入了回调函数, 本身就没问题, 直接调用原本的push()就可以
    ```js
    const originPush = VueRouter.prototype.push
    VueRouter.prototype.push = function (location, onComplete, onAbort) {
      console.log('push()', onComplete, onAbort)
      // 判断如果没有指定回调函数, 通过call调用源函数并使用catch来处理错误
      if (onComplete===undefined && onAbort===undefined) {
        return originPush.call(this, location).catch(() => {})
      } else { // 如果有指定任意回调函数, 通过call调用源push函数处理
        return originPush.call(this, location, onComplete, onAbort)
      }
    }
    
    ```

说明:
声明式路由跳转之所有没有问题, 是因为默认传入了成功的空回调函数

   ```js
   // 缓存原型上的push方法
   const originPush = VueRouter.prototype.push
   VueRouter.prototype.push = function (location, onComplete, onAbort) {
     console.log('push()', location, onComplete, onAbort)
     // this是路由器对象 $router
     // 如果调用push, 传递了成功或者失败的回调函数
     if (onComplete || onAbort) {
       // 让原来的push方法进行处理
       originPush.call(this, location, onComplete, onAbort) // 不用返回, 因为执行的结果返回是undfined
     } else { // 如果调用push, 没传递了成功或者失败的回调函数, 可能会抛出失败的promise, 需要catch一下
       return originPush.call(this, location).catch(() => {
         console.log('catch error')
       })   // 必须返回产生的promise对象
     }
   }
   ```


#### params与path配置能不能同时使用
不可以: router.push({path: '/xx', params: {name: 'tom'}})
params只能与name配合: router.push({name: 'xx', params: {name: 'tom'}})   

#### 如何配置params参数可传可不传?
path: '/search/:keyword?',    
注意: 一旦声明可以不传, 不能传入一个空串的param参数

#### 跳转携带的参数, 刷新就丢失了
如果注册没有指定/:xxx的点位, 而跳转时通过params配置携带的参数数据, 刷新时就会丢失
因为url中没有携带的参数数据路径
this.$router.push({name: 'Info', params: {a: 1, b: 2}})
this.$route.params.a
/info/1/2

#### 路由组件能不能传递props参数?
可以, 但只是将params/query映射成props传入路由组件的

路由配置中props属性的作用
- 组件中使用$route会使对应的组件形成耦合,这些组件只能在相应的url上使用,限制灵活性
- 通过props传递,简化了以往需要计算属性获取params,query参数.可以直接在组件的props属性上声明接收.



#### 如何让路由跳转后, 滚动条自动停留到起始位置?

```js
new VueRouter({ // 配置对象
  // ...
  scrollBehavior (to, from, savedPosition) {
    // 指定路由跳转后滚条的坐标
    return { x: 0, y: 0 }
  }
})


//返回上个页面定位到底上次访问的位置
scrollBehavior(to,from,savedPosition){
    if(savedPosition){
        return savedPosition;
    }else{
        return {x:0, y:0}
    } 
}

//完善 上面的代码.不是每个页面都有这个需求 搭配使用meta属性
scrollBehaviour(to,from,savedPosition){
    if(savedPosition && to.meta===true){
        return savedPosition
    }else{
        return {x:0,y:0}
    }
}
```

#### 如何实现登陆后, 自动跳转到前面要访问的路由界面

在全局前置守卫中, 强制跳转到登陆页面时携带目标路径的redirect参数

```js
if (userInfo.name) {
  next()
} else {
  // 如果还没有登陆, 强制跳转到login
  next('/login?redirect='+to.path)  // 携带目标路径的参数数据
}
```

在登陆成功后, 跳转到redirect参数的路由路径上

```js
await this.$store.dispatch('login', {mobile, password})
// 成功了, 跳转到redirect路由 或 首页
const redirect = this.$route.query.redirect
this.$router.replace(redirect || '/')
```



#### 重载组件,页面没有变化的解决方法
当从 C 组件切换到 C 组件（只更新参数的时候），C 组件并不会被重新创建或卸载，而是复用之前 C 组件，这样会导致只有路由变化，页面没有发生变化
<span style="color:red;">解决方案</span> 3种
* watch
* beforeRouteUpate
* router key

##### watch
​使用watch进行监视，因为每次更新时，$route都会创建一个新对象 ，而不是原对象，所以所有数据都是新的，可以监视
```js
//项目中使用
search页面改变参数，无法重复发请求的问题
watch: {
    $route(newVal, oldval) {
      this.handlerSearchParams();
      this.getSearchInfo();
    },
  },
```


##### beforeRouteUpdate
```javascript
beforeRouteUpdate(to, from, next) {
  
}
```


##### router key
> https://mp.weixin.qq.com/s/0Yekkc08ozbNxuquHVGveg

```html
<router-view v-bind:key="$route.fullpath"></router-view>
```


#### 命名路由的时候params和query分别可以和什么搭配使用

query + name

query + path

params + name  (怎么记忆, 都有am)


#### 如何监听路由变化 //?
>https://juejin.cn/post/6875198510221197319
>https://github.com/Easay/issuesSets/issues/142


**vue-router实现原理** //概述
```js
// ...
this._router = this.$options.router
// ...
Vue.util.defineReactive(this, '_route', this._router.history.current)
```

* `this.$options.router`就是VueRouter的实例
* `this._router.history.current`是当前路由，在每次你`this.$router.push/this.$router.replace`的时候，current都会更新。
* 响应式属性`_route`。当响应式属性更新时，依赖这个属性的组件都会更新。
* RouterView就依赖了这个属性`_route`。它会根据`_route`的改变而更新组件渲染内容(重新执行render函数)。
* `_route`又会对应有当前路由匹配的组件，这些匹配的组件就是RouterView要渲染的内容。


##### 如何监听
使用Proxy方法
```js
history.pushState = new Proxy(history.pushState, {
  apply: function (target, thisBinding, args) {
    console.log('就这？');
    return target.apply(thisBinding, args);
  },
});


```


## Vue 前台项目问题


### 测试调用接口请求函数（跨域问题）
1. 出404的错误
axios请求配置的地址: /api/product/getBaseCategoryList'
当前发请求所在的地址:　http://localhost:8080/
最终ajax请求的地址: http://localhost:8080/api/product/getBaseCategoryList (没人处理)

2. 解决办法1
配置baseURL: http://182.92.128.115/api   ==> 成功的前提是后台允许ajax跨域

3. 使用代理服务器转发到目标接口地址 (使用代理解决ajax跨域)
配置baseURL: /api
配置代理: vue.config.js中
```js
devServer: {
 proxy: {
	 // 配置代理
	 "/api": {
		 // 只处理以/api开头的请求
		 target: "http://182.92.128.115", // 转发的目标地址
		 changeOrigin: true, // 支持跨域
	 }
 }
}
```

#### vuex的基本使用
- store对象: state, mutations, actions, getters配置store对象: 在vm中配置

#### vuex多模块编程

- 当vuex管理的数据个数很多时使用
- 好处: 每个功能模块的数据单独管理, 更方便, 更有扩展性

#### vuex多模块编程的总state结构
- 要根据具体分出的模块进行调用
```js
{
	user: {
			userInfo: {}
	},
	home: {
			baseCategoryList: []
	}
}
```

#### vuex与api交互
- 异步action: 调用api接口请求函数 ==> 成功之后commit ==> 调用mutation ==> 更新状态数据

### 利用lodash进行函数节流处理

**问题: mouseenter事件频繁触发会导致分类列表更新卡的现象**

- 解决: 使用lodash的throttle函数进行节流处理, 限制更新的次数

#### 优化减小打包文件: 对lodash库实现按需引入 

```js
import _ from 'lodash'  // 引入整体lodash  ==> 打包了没用的工具函数, 打包文件变大
import throttle from 'lodash/throttle'  // 只引入我需要的工具函数   打包文件减少1.4M
```

#### 解决快速移出后可能显示第一个分类的子分类列表的bug
原因：在最后一个mouseenter事件延迟0.3m才执行更新的回调函数
在这个0.3s之内可能已经移出去了
解决: 给currentIndex设计了3个值:
    -2: 在整个大div外面   
    -1: 进入了包含所有分类的大div上
    >=0: 在某个分类上
在准备更新currentIndex之前, 需要判断currentIndex当前不能为-2


### 3级分类列表卡顿及解决

商品分类鼠标快速移入移出, 浏览器出现卡顿现象. 使用防抖和节流处理.  使用库lodash

lodash是已经存在的依赖包, 可以通过`search_modules`搜索确认

使用lodash时, 只引入所需的函数/功能



#### 函数防抖/节流

##### 函数防抖的应用场景:

连续的事件,只需触发一次的回调的场景有:

* 搜索框搜索输入.只需要用户最后一次输入完,再发请求
* 手机号,邮箱验证码输入监测
* 窗口大小Resize. 只需要窗口调整完成后,计算窗口大小.防止重复渲染

##### 函数节流的应用场景:

间隔一段时间执行一次回调的场景有:
* 滚动加载,加载更多或滚动到底部监听
* 谷歌搜索框,搜索联想功能
* 高频点击提交,表单重复提交.



#### throttle

两种引入形式. 及参数的具体含义

按需引入lodash减少打包体积

解决使用lodash节流后，快速移出后，可能还会显示某个子项
	{ 'trailing': true,leading:false}

'trailing': 是否在时间间隔之后执行函数
leading： 是否在时间间隔之前执行函数

```js
import _ from 'lodash'

methods: {
  moveInItem: _.throttle(function(index) {
    this.currentIndex = index
    console.log(index)
  }, 20, { 'trailing': false})
}

// 
import throttle from 'lodash/throttle'

methods: {
  moveInItem: throttle(function(index) {
    this.currentIndex = index
    console.log(index)
  }, 20, { 'trailing': false})
}
```





### 页面跳转实现的3种方式及选择

#### 实现

页面三级分类列表 和搜索框 跳转, 通过3种方式来跳转

* 每个a标签链接更改为`router-link`
* 将`router-link`改为编程式导航`$router.push({name:'search', query:{}})`
* 使用事件委托 + 自定义属性 来代替多个`$router.push`



#### 存在的问题

当`<a>`标签改为`<router-link>`后, 会出现卡顿现象

##### 原因

渲染组件标签时候, 其本质是通过和标签名绑定好的构造函数,实例化了一个对象, 称作是组件对象.

多层vfor循环中多个\<router-link>标签产生了多个组件, 内存占用大, 卡顿

#### 解决1-编程式导航代替声明式导航

使用编程式导航代替声明式导航

```html
<div
							class="item"
							:class="{ item_on: currentIndex === index }"
							v-for="(c1, index) in categoryListSumIs15"
							v-bind:key="c1.cat_id"
							@mouseenter="moveInItem(index)"
						>
							<h3>
								<!-- <a href="">{{ c1.cat_name }}</a> -->
								<!-- <router-link
									:to="{
										name: 'search',
										query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
									}"
									>{{ c1.cat_name }}</router-link
								> -->

								<a
									href="javascript:;"
									@click="
										$router.push({
											name: 'search',
											query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
										})
									"
									>{{ c1.cat_name }}</a
								>
							</h3>
```





#### 解决2 - 事件委托

每个a标签都添加了点击事件, 内存中会定义很多个函数,内存占用也是比较大,效率虽然比声明式导航大,但是不够好. 使用<u>事件委托</u>来代替



每个分类项都添加事件，事件的回调函数很多，效率也不好
在共同的祖先级元素添加事件监听
		问题：怎么知道点击的是不是a标签
		问题：假设你点击的就是a标签，怎么知道点击的是一级还是二级还是三级
		问题：参数怎么携带，要携带携带哪些个的参数



利用在a标签中添加自定义属性来解决以上问题

##### 自定义属性(data-)

```js
//为html标签添加自定义属性,结构是data-xxx="..."
标签的data-开头的属性，叫做自定义属性,通过它我们可以给标签添加上自定义的属性.
获取:通过事件属性 event.target.dataset来获取这个属性.

注意:Vue会把自定义属性的大写变为小写.

```









### Mock接口数据

    1.新建文件夹 src/mock 准备数据新建文件xxx.json  floor.json banner.json
    2.安装mock模块 yarn add mockjs
    3.创建src/mock/mockServer.js
    	Mock.mock('/mock/banner',{code:200,data:banner}) //第一个参数，代表我们以后请求的路径，第二个参数代表返回的数据
    4.在main.js中引入 import '@/mock/mockServer'
    5.ajax文件中,新建mockAjax.js文件, 复制ajax.js中的内容, 但是基础路径改为/mock  // 不会向后台发送数据

### 使用swiper

- 创建并配置swiper对象: 必须在列表显示显示之后创建 ===> 在mounted()中创建

#### 解决多个swiper效果冲突的问题

​	问题: 针对某个swiper界面创建一个swiper对象, 它会影响了其它界面的swiper界面

​	原因: new Swiper ('.swiper-container'), 类名选择器匹配了页面中所有的swiper界面, 都产生了效果

​	解决: 使用ref技术: 通过ref标识swiper的根div, new Swiper (this.$refs.swiper)

#### 解决swiper动态页面轮播的bug

​	问题: 异步动态获取数据 + 直接在mounted中创建Swiper对象 ===> 没有轮播效果

​	原因: swiper对象创建得太早

​	解决: 使swiper对象在列表数据显示之后创建

​			**办法1**: 使用延迟定时器延迟一定的时间才创建 ==> 不合适, 因为请求获取的时间是不定的

​			**办法2**: watch + $nextTick()

​					通过watch能知道banners有数据了(变化了)

​					通过 $nextTick(callback)知道界面也更新了，那我们就可以在callback中创建swiper对象

**理解nextTick()**

- nextTick()需要在数据更新之后界面更新前我们调用

- 指定的回调函数在这次数据更新导致的界面更新完成后立即执行

#### 解决Floor组件中轮播有问题的bug

问题: banners的轮播可以, 但2个Floor的轮播都没有效果

原因: (在v-for以后轮播组件已经有数据了，不是从空数组变为有数据，所以watch不调用)

​	 	基础理解: 给组件标签传入的属性值是空数组/undefined, 组件对象会创建，如果是通过v-for遍历一个空数组或undefined来产生多个标签, 组件对象不会创建

​		watch默认: 初始创建显示不会执行, 只有在数据变化后才会执行

解决:

​		**办法1**: mounted() + watch回调

​					mounted()中: 判断如果已经有数据了, 立即创建swiper对象

​					watch回调: 判断如果有数据, 延迟创建swiper对象

​		**办法2**: watch

​					给watch指定2个配置

​					handler: 判断如果有数据, 延迟创建swiper对象

​					immediate: 指定为true, 表示在初始显示之前就会调用一次









### 响应式数据对象

#### **添加新属性**

错误方式: 

​		直接添加: this.options.trademark = 'xxx'  ==> 不会自动更新界面

原因: 

​		vue内部没有对添加的属性进行劫持操作(没有对应的setter监视)

正确方式:

​		vm.$set( target, key, value )

​		Vue.set( target, key, value )

​		为响应式对象添加一个属性，确保新属性也是响应式的，并且能够触发视图更新

#### 删除属性

错误方式: 

​		直接添加: delete this.options.trademark  ==> 不会自动更新界面

原因: 

​		vue内部给响应式属性添加的setter, 只能监视属性值的改变, 不能监视属性的删除

正确方式:

​		vm.$delete( target, key )

​		Vue.delete( target, key )

​		删除属性, 同时更新界面

### 自定义分页组件: Pagination

**自定义通用型/复用型组件的基本步骤**

- 实现静态组件: 模板/样式写好

- 设计从外部接收的数据: props

- 设计内部包含的数据: data

- 设计基于props和data的计算属性数据: computed

- 根据props和data数据和computed进行动态显示

  **v-for的优先级高于v-if: 先执行v-for的遍历, 每遍历一个再进行v-if的判断 面试题**

- 更新数据, 更新界面

  用户操作组件界面元素时, 更新当前组件的data数据

  子组件更新data数据的同时, 可能需要通知父组件做一些更新父组件数据的操作(可能异步/同步)

  父组件更新data数据的同时, 可能也要去更新子组件的数据



### 可说性强的点



### 1) 三级分类列表

- 使用编程式导航代替声明式导航

- router-link太多 ==> 创建很多组件对象 ==> 占用内存大, 效率低

  ```js
  1.使用声明式导航 产生的组件过多,内存中组件对象多,卡顿
  2.使用编程式导航代替声明式 click事件. 每个a标签上都添加了点击事件,内存中有很多函数,内存占用大.
  3.使用事件委托
   -如何获取发生事件的元素和属性:event.target 自定义属性和元素的dataset属性
  4.对mouseEnter事件的高频进行节流处理: lodash的节流函数throttle函数+按需引入
  
  import _ from 'lodash'
  import throttle from 'lodash/throttle'
  ```

  

- 优化事件处理效率

  - 利用事件委托: event.target
  - 理解事件委托与事件冒泡

- 如何携带点击的分类的数据?

  - event.target得到a标签  获取发生事件的元素
  - 利用自定义的data标签属性来保存分类信息

- 对mouseEnter高频事件进行节流处理

  - 使用lodash的throttle进行节流处理
  - 对lodash库实现按需引入



```html
<div class="all-sort-list2" @click="toSearch">
  <div
       class="item"
       :class="{ item_on: currentIndex === index }"
       v-for="(c1, index) in categoryListSumIs15"
       v-bind:key="c1.cat_id"
       @mouseenter="moveInItem(index)"
       >
    <h3>
      <a
         href="javascript:;"
         :data-c1Id="c1.cat_id"
         :data-cName="c1.cat_name"
         >{{ c1.cat_name }}</a
        >
      <!-- <router-link
:to="{
name: 'search',
query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
}"
>{{ c1.cat_name }}</router-link
> -->

      <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
})
"
>{{ c1.cat_name }}</a
> -->
    </h3>
    <div class="item-list clearfix">
      <div class="subitem">
        <dl
            class="fore"
            v-for="(c2, index) in c1.children"
            :key="c2.cat_id"
            >
          <dt>
            <a
               href="javascript:;"
               :data-c2Id="c2.cat_id"
               :data-cName="c2.cat_name"
               >{{ c2.cat_name }}</a
              >
            <!-- <router-link
:to="{
name: 'search',
query: { c2Id: c2.cat_id, c2Name: c2.cat_name },
}"
>{{ c2.cat_name }}</router-link
> -->

            <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c2Id: c2.cat_id, c2Name: c2.cat_name },
})
"
>{{ c2.cat_name }}
</a> -->
          </dt>
          <dd>
            <em v-for="(c3, index) in c2.children" :key="c3.cat_id">
              <a
                 href="javascript:;"
                 :data-c3Id="c3.cat_id"
                 :data-cName="c3.cat_name"
                 >{{ c3.cat_name }}</a
                >
              <!-- <router-link
:to="{
name: 'search',
query: { c3Id: c3.cat_id, c3Name: c3.cat_name },
}"
>{{ c3.cat_name }}</router-link
> -->
              <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c3Id: c3.cat_id, c3Name: c3.cat_name },
})
"
>{{ c3.cat_name }}</a
> -->
            </em>
          </dd>
        </dl>
      </div>
    </div>
  </div>
</div>
```



```javascript
		// 事件委派 函数
		toSearch(event) {
			// event是什么 每一次触发事件时,系统(浏览器内核)都会把这一次触发事件相关的所有信息,封装为一个对象. 在浏览器调用回调函数的时候, 自动传递给回调函数的第一个形参
			// 回调函数 自己定义 自己没调用 最后执行了.  所以toSearch在html中可以不用括号 vue中的回调参数顺序可以改变,但原生的不能改
			// event 是浏览器调用函数传递过来的时间对象, 代表你传递的$event, 只能在模板里出现

			let targetNode = event.target; // 获取目标元素
			let data = targetNode.dataset;
			console.log("data", data);
			let { c1id, c2id, c3id, cname } = data;

			if (cname) {
				// cname存在, 证明点击的就是a标签
				let location = {
					name: "search",
				};
				let query = {
					cName: cname,
				};

				// 确定是几级的ID
				if (c1id) {
					query.c1Id = c1id;
				} else if (c2id) {
					query.c2Id = c2id;
				} else {
					query.c3Id = c3id;
				}

				location.query = query;
				// 跳转之前, 要合并原来过来时的params参数
				if (this.$route.params) {
					location.params = this.$route.params
				}

				// 如果是从home页跳search页, 就push
				// 如果是从search页 跳 search 页, 就replace
				if (this.$route.path !== '/home') {
					this.$route.replace(location)
				} else {
					this.$router.push(location);
				}
				
			}
		},

```





### 2) 商品搜索列表

- 准备各种搜索条件
  - category1Id: '', // 一级分类ID
  - category2Id: '', // 二级分类ID
  - category3Id: '', // 三级分类ID
  - categoryName: '', // 分类名称
  - keyword: '', // 关键字
  - trademark: '', // 品牌  "ID:品牌名称"
  - props: [], // 商品属性的数组: ["属性ID:属性值:属性名"] 示例: ["2:6.0～6.24英寸:屏幕尺寸"]
  - order: '1:desc', // 排序方式  1: 综合,2: 价格 asc: 升序,desc: 降序  示例: "1:desc"
  - pageNo: 1, // 当前页码
  - pageSize: 10, // 每页数量
- 添加搜索条件
- 删除搜索条件
  - 删除分类或关键字条件后, 地址栏还有条件参数?
  - 删除关键字条件, 输入框中的关键字没有同步删除?
- 排序处理
  - 根据综合/价格/销量/评价排序
  - 升序/降序
  - 搞清条件数据结构
    - orderFlag:orderType
    - orderFlag: 1: 综合,2: 价格, 3: 销量, 4: 评价
    - orderType:  asc: 升序,desc: 降序

```js
//准备各种搜索条件
1.初始化搜索条件: data中的数据:搜索条件对象, dispatch只能接收一个参数
2.获取条件对象中的各个数据:
 获取对象数据: 从路由对象$route中获取query参数(点击的分类名称及id)和params参数(输入的关键字)
2.1优化条件对象-删除空属性: 对条件对象使用扩展运算符,更新.对象循环遍历Object.keys(obj),删除空属性
2.2处理对象的声明周期, 请求数据的声明周期: beforeMounte, mounted

//删除分类或关键字条件后, 地址栏还有条件参数
1.在搜索页重新输入关键字或者点击类别不会再发送请求，因为mounted只会执行一次，需要监视路由变化
2.解决: 使用watch监视$route,更新参数,重新发请求.

//删除关键字条件, 输入框中的关键字没有同步删除
1.使用自定义事件通知header组件清空关键字
2.重新发送请求this.searchParams.pageNo = 1  this.$router.replace({name:'search', query:this.$roue.query})

//商品排序处理(order:'2:desc')
0.data中初始化数据: order:'2:desc'
1.判断用户点击的是否是原来的排序标志sortFlag是否和原来一样,一样就更改排序类型sortType(asc,desc). 不一样就更改排序标志,排序类型默认.
2.更新页码,重新发送请求(this.getSearchInfo())
3.其他:阿里图标字体库的使用 ;计算属性的引入获取排序标志和类型
```







### 详情页

```js
//图片实现放大镜效果
组件结构:详情页组件, 缩略图组件imgList, zoom大图组件

//缩略图组件imgList
1.引入swiper轮播图组件
2.处理思路: 使用watch监视props属性图片数组imgList,一旦有变化,实例化swiper.但是没有效果,因为页面还没有完全形成,所以需要等页面完全形成后再去实例化swiper,使用$nextTick(最近一次页面更新之后调用)
watch:{
    imgList:{
        immediate:true,
        handler(newValue,oldValue){
            this.$nextTick(()=>{
                new Swiper(this.$refs.imgSwiper,{
                    slidesPerView:4, //一个视图放几张
                    slidePerGroup:4, //切换一组,几张图片
                    navigation:{
                        nextEl:".swiper-button-next",
                        prevEl:".swiper-button-prev"
                    }
                })
            })
        }
    }
}
3.点击的当前图片添加边框
动态类判断当前索引和点击索引是否相同,初始化index数据0,点击后将当前图片索引赋值给初始index. 
4.其他: 缩略图列表和展示图列表同步,使用全局事件总线传递当前图片的index值 this.$bus.$emit('changeDefaultIndex',index)

//右侧大图组件
1.缩略图组件给大图组件传递的index,在mounted中指定全局事件总线接收 //全局事件总线接收,$on后是方法
mounted(){this.$bus.$on('changeDefaultIndex',this.changeDefaultIndex)}
methods:{changeDefaultIndex(index){this.defaultIndex=index}}
1.1 beforeDestroy解绑全局事件总线

2.图片展现问题
使用<img :src="imgList[0].imgUrl"/> 报错:can't read property of undefined
使用<img :src="defaultImg.imgUrl"/> 通过计算属性得到return this.imgList[this.defaultIndex]||[] 来解决


3.蒙版+右侧大图
<div class="spec-preview">
    <img :src="default.imgUrl"/>
    <div class="event" @mousemove="move"></div>
    <div class="big">
        <img :src="defaultImg.imgUrl" ref="bigImg">
    </div>
    <div class="mask" ref="mask"></div>
</div>

move(event){
    //鼠标动,蒙版动,转化为根据鼠标位置求蒙版位置
    //event.clientX 视口 event.pageX页面 event.offsetX元素
    let mask = this.$refs.mask;
    let bigImg = this.$refs.bigImg;
    
    //获取鼠标坐标
    let mouseX = event.offsetX;
    let mouseY = event.offsetY;
    //根据鼠标位置和蒙版宽度计算蒙版位置
    let maskX = mouseX - mask.offsetWidth/2;
    let maskY = mouseY - mask.offsetHeight/2; //offsetWidth: 目标元素的宽度(加边框) 
    
    //设置蒙版位置前需要边界限定
    if(maskX<0){
        maskX=0;
    }else if(maskX>mask.offsetWidth){//因为整体宽度是蒙版的两倍
        maskX = mask.offsetWidth;
    } 
    if(maskY<0){
        maskY=0;
    }else if(maskY>mask.offsetHeight){
        maskY = mask.offsetHeight;
    }
    
    //设置蒙版的位置让蒙版活动
    mask.style.left = maskX + 'px';
    mask.style.top = maskY + 'px';
    
    //蒙版动,大图动  大图是蒙版移动反方向的2倍
    bigImg.style.left = -2*maskX+'px';
    bigImg.style.top = -2*maskY+'px';   
}

//点击切换销售属性值的选中状态
1.排它实现: 第一步,让所有成员变为同一种状态;第二步,让当前点击的这个成员变为另一种状态

//购买数量输入框
1.blur失去焦点还是选择change事件,change事件:触发条件时当前数据和原来的数据不一样
2.使用三元表达式处理负数,非数值等. //这里需要使用大于等于,否则会失效
<input v-model="skuNum" @change="$event.target.value>=1?(skuNum=$event.target.value*1):(skuNum=1)"/>

//加入购物车按钮-需要发请求    
.加入购物车 需要发请求给后台让后台存储信息,请求成功后返回信息,根据这个信息再去跳转.否则,如果添加失败,而又跳转到下个页面,救出问题.
async addShopCart(){
    try{
        await this.$store.dispatch('addOrUpdateShopCart',{skuId:this.skuId,skuNum:this.skuNum});
        alert('添加购物车信息成功');
        sessionStorage.setItem('SKUINFO_KEY',JSON.stringify(this.skuInfo));
        this.$router.poush('/addcartsuccess?skuNum='+this.skuNum)
    }catch(error){
        alert(error.message)
    }
}

```



### 购物车成功页面

```js
//请求需要携带用户临时身份标识,才能获取到数据

//用户临时标识
1.创建保存
 浏览器端创建,每次请求需要携带;
 应用一打开就创建保存在localStorage
 在state中也去保存一份,可以更快获取
2.使用
 请求拦截器每个请求都带上
3.做法
 工具函数去创建保存uuid
 在state中调用这个函数
 ajax发送请求,所有请求头中携带这个标识

//utils/userabout.js
import{v4 as uuid} from 'uuid';
export function getUserTempId(){
    let userTempId = localStorage.getItem('USERTEMPID_KEY');
    if(!userTempId){
        userTempId = uuidv4();
        localStorage.setItem('USERTEMPID_KEY', userTempId)
    }
    return userTempId;
}

//store/user.js
import{getUserTempId} from '@/utils/userabout';



//数据存储到data,方便后期使用

beforeMount(){
    this.skuNum = this.$route.query.skuNum;
    this.skuInfo = JSON.parse(sessionStorage.getItem('SKUINFO_KEY'))
}



```



### 购物车页面

```js
修改数量,修改选中状态,删除商品都需要发请求,请求成功后再请求更新页面数据

//修改购物车数量
<input autocomplete="off" type="text" :value="cart.skuNum" minnum='1' @change="changeCartNum(cart,$event.target.value*1, false)"
@click="changeCartNum(cart,-1,true)"
@click="changeCartNum(cart,1,true)"
async changeCartNum(cart,disNum,flag){
    //获取本身的数量
    let originNum = cart.skuNum;
    if(flag){
        if(originNum+disNum<1){disNum = 1-originNum}
    }else{
        if(disNum<1){
            disNum=1-originNum;  //disNum是变化的值
        }else{
            disNum = disNum - originNum;
        }
    }
    try{
        //发请求修改数量
    	await this.$store.dispatch('addOrUpdateShopCart',{skuId:cart.skuId,skuNum:disNum});
        alert('更改成功');
        //发请求重新获取购物车列表数据
        this.getshopCartInfo();
    }catch(error){
        alert(error.message);
    }
}

//修改购物车的全选状态
利用input标签:checked属性选中与否来决定配置属性isChecked是0还是1

  //使用计算属性读取和更新全选状态
  isCheckAll:{
      get(){
          return this.cartInfoList.every((item)=>{item.isChecked})
      },
      async set(val){
          try{
              const result = await this.$store.dispatch('updateCartIscheckAll', val?1:0);
              alert('修改成功')
              this.getshopCartInfo();
          }catch(error){
              alert(error.message)
          }
      }
  }

//vuex中全选 使用promise.all处理
async updateCartIscheckAll({commit,dispatch,getters}, isChecked){
    let promises=[];
    getters.cartInfo.cartInfoList.forEach(item=>{
        if(item.isChecked===isChecked) return;
        let promise = dispatch('updateCartIscheck', {skuId:item.skuId, isChecked})
        promises.push(promise);
    })
    return Promise.all(promises)
}

//页面数据计算

//统计已选的数量
computed:{
    checkNum(){
        return this.cartInfoList.reduce((prev,item)=>{
            if(item.isChecked){
                prev += item.skuNum;
            }
            return prev;
        },0)
    },
    
    //统计总价
    allMoney(){
        return this.cartInfoList.reduce((prev,item)=>{
            if(item.isChecked){
                prev += item.skuNum*item.skuPrice;
            }
            return prev;
        },0)
    }
}

//删除购物车数据

```



### 注册页面

```js
//点击注册按钮的逻辑
根据请求成功还是失败有后续操作（所以action里面函数要有return，来让vue当中判断成功和失败）
如果请求验证码成功，我们需要把验证码自动添加到页面上，修改data的code为state里面获取的
如果请求验证码失败，提示
async register(){
    //点击完成注册首先对所有的表单项做整体验证，验证通过返回的true,没通过返回的false
    const success = await this.$validator.validateAll();
    if(success){
        //发请求把收集的数据，作为参数传递给后台存储数据库
        let {phone, password, code} = this;
        try{
            await this.$store.dispatch('userRegister',{phone,password,code});
            alert('注册成功');
            this.$router.push('/login')
        }catch(error){
            alert(error.message)
        }
    }
}

main.js中  import '@/utils/validate'  //引入vee-validate相关配置

utils/validate.js
import Vue from 'vue'
import VeeValidate from 'vee-validate'
import zh_CN from 'vee-validate/dist/locale/zh_CN' // 引入中文message
Vue.use(VeeValidate)
```





### 登录页面

```js
//登录按钮回调

登录跳转前,进入到全局路由前置守卫中进行判断.
先判断是否又token:
有->访问的依然是login页面->跳转到首页
有->访问其他页面->再判断是否已经获取用户信息
用户信息有->放行
用户信息没有->dispatch一下请求,获取用户信息(保存到vuex中)


methods:{
    aysnc login(){
        let{phone,password}=this;
        if(phone&password){
            try{
                await this.$store.dispatch('userLogin',{phone,password});
                //登录成功后,跳转到之前前往的页面
                let targetPath = this.$route.query.redirect||'/';
                this.$route.push(targetPath);
            }catch(error){
                alert('登录失败')
            }
        }
    }
}



//路由器对象中配置全局路由守卫
const router = new VueRouter({
    routes,
    scrollBehavior(to,from,savedPosition){
        return {x:0,y:0}
    }
})
//注册全局前置导航守卫，用来对token校验（根据token获取用户信息）
router.beforeEach(async(to,from,next)=>{
    //第一步：守卫拦截住，先去获取用户的token和用户的信息
    let token = store.state.user.token;
    let userInfo = store.state.user.userInfo.name;
    
    if(token){
        //如果token存在,代表用户登录过
        if(to.path==='/login'){
            next('/')
        }else{
            //如果用户已经登录,但跳转的不再是登录页,需要查看用户信息获取了没有
            if(userInfo){
                //如果已经获取
                next()
            }else{
                //用户已经登录,但还没获取用户信息,需要请求用户信息
                try{
                    await store.dispath('getUserInfo') //用户根据token获取信息
                    next();
                }catch(error){
                    //根据token获取用户信息失败，代表token可能过期
          			//把用户的过期token给清理掉，重新跳转到登录页
                    store.dispatch('clearToekn');
                    next('/login')
                }
            }
        }
    }else{
        //用户没有登录,如果用户访问的是 交易相关  支付相关 个人中心相关，那么跳转到登录页面
        let accessPath=['/trade','/center','/pay'];
        let targetPaht = to.path;
        let result = accessPath.some((item)=>{item === targetPath})
        if(result){
            next('/login?redirect='+targetPath)
        }else{
            next();
        }
    }
})


//vuex中 user.js
const actions={
    //请求登录
    async userLogin({commit}, userInfo){
        const reuslt = await reqUserLogin(userInfo);
        if(result.code === 200){
            commit('RECEIVE_TOKEN', result.data.token);
            //自动登录就是需要保存token到localStorage
      	    //保证第一次登录完成，后期的登录都可以免了
            locationStorage.setItem('TOKEN_KEY',result.data.token)
            return 'ok';
        }else{
            return Promise.reject(new Error('failded'))
        }
    }
}

//ajax.js
//登录成功后，需要把token添加到请求头当中，从今往后所有的请求当中都要带上这个token
let token = store.state.user.token;
if(token){
    config.headers.token = token;
}

//用户临时标识和token区别
userTempId  未登录状态下的用户身份识别标识
token       登录状态下的用户身份识别标识 
如果没登陆，请求头当中只带了临时标识，添加的购物车信息是和临时身份标识对应的信息
如果登录了，那么我们同时在请求头添加临时标识和登录后标识，
那么此时后台会把临时标识对应的数据，转移到真正登录的标识数据里面，而临时标识对应的数据就不见了
两个标识都存在的话，后台会合并临时id对应的信息到token对应的信息上 token是老大
```







### 支付界面

```js
//支付流程
1.结算按钮 提交订单信息(push页面的时候,query参数传递订单编号)
2.根据接收的订单编号请求商品信息(支付url,金额)
3.支付1: 根据支付url生成支付二维码,引入qrcode
4.支付2: 扫码支付
5.支付3:使用定时器setInterval轮询请求支付状态
 5.1 支付成功: 存储支付状态->消息提示->关闭定时器(clearInterval,null)->跳转页面




//点击提交订单的逻辑
1.根据订单id获取支付信息 awati this.$API.reqPayInfo(this.orderNum)
2.可以根据支付信息获取支付url和金额
3.支付
3.1 根据支付url生成支付二维码图片显示 使用插件qrcode
3.2 扫码支付
3.3 轮询请求获取订单状态


async pay(){
    try{
        //第一步：根据支付信息当中codeUrl生成二维码进行弹框展示
    let imgUrl = await QRCode.toDataURL(this.payInfo.codeUrl);
    //生成的二维码图片链接进行展示
    this.$alert(`<img src="${imgUrl}" />`, '请使用微信扫码支付',{
        dangerouslyUseHTMLString:true,
        showClose:false,
        showCancelButton:true,
        cancelButtonText:'支付遇到问题',
        confirmButtonText:'我已支付成功',
        center:true,
        beforeClose:(action,instance,done)=>{
            //action代表用户点击的是哪个按钮 'confirm确定按钮', 'cancel取消'或'close关闭'；
            if(action==='confirm'){
                //判断如果没有支付
                if(!this.payStatus){
                    this.$message.info('请确保支付成功,成功后自动跳转支付页面')
                }
            }else if(action==="cancel"){
                //1.提示
                this.$message.warning('支付遇到问题请练习客服');
                //2.清除定时器
                clearInterval(this.timer);
                this.timer = null;
                //3.关闭消息盒子
                done();
            }
        }
    }).then(()=>{}).catch(()=>{});
     //.then() 是对应点击确定按钮之后的操作 .catch();是对应点击取消按钮之后的操作
     //如果采用这两个去操作，都会强制关闭我们的弹出框msgBox,而我们现在并不是要直接关闭，是需要判断用户是不是支付了，才决定关闭不关闭
    
    //轮询 隔2秒发一个请求， 为了让后台给我返回这个订单的支付状态
    //用以判断用户到底是支付了还是没支付
    if(!this.timer){
        this.timer = setInterval(async()=>{
            const result = await this.$API.reqPayStatus(this.orderNum);
            if(result.code === 200){
                //1、把成功的标志存储起来用于用户点击按钮的时候进行判断
                this.payStatus = 200;
                //2、提示支付成功
                this.$message.success('支付成功');
                //3、把定时器清除
                clearInterval(this.timer);
                this.timer = null;
                //4,自动跳转到支付成功页面
                this.$msgbox.close(); //强制关闭弹出框
                this.$router.push('/paysuccess');
                
            }
        },2000)
    }
    }catch(error){
        //生成二维码图片失败 提示
        this.$message.error(error.message)
    }
}

```





### 个人中心页面

```js
//路由权限控制
全局路由守卫: 隐私页面(个人中心,交易及支付相关页面)没登录情况下需要先登录,之后会自动跳转到个人中心页面
```



### 路由守卫在项目中使用

```js
//只有从购物车页面才能跳转到交易页面

//只有从交易页面才能跳转到支付页面

//只有从支付页面才能跳转到支付成功页面, 且需要携带必要的参数订单号,商品信息
```





### 补充

```js
//代码优化
1.图片懒加载:在图片界面没有进入到可视范围前不加载, 在没有得到图片前先显示loading图片
import  lazyload from 'vue-lazyload';
import loading from '@/assets/images/loading.gif'
Vue.use(VueLazyload, { // 内部自定义了一个指令lazy
  loading,  // 指定未加载得到图片之前的loading图片
})

<img v-lazy="goods.defaultImg" />
    
//2.路由懒加载
通常路由组件使用import..from..方式同步将所有路由组件一次性打包在一个文件中.(体积大,加载效率低).
路由懒加载是使用动态import分别打包文件,浏览器请求哪个组件再去加载哪个组件(效率高)

形式: const Home = ()=>import('@/pages/home');
{
    name:'Home',
    component:()=>import('@/pages/home')
}
//3.第三方插件按需引入
element-ui  lodash

//4.大数组优化: 冻结列表+虚拟列表

//5.事件销毁
全局事件总线在beforeDestroy(){this.$bus.$off('eventname')}

//webpack优化

```





### 3) 下单支付流程

- 去结算 ==> 获取订单交易数据
- 提交订单 ==>提交下单请求, 得到订单ID
- 根据订单ID获取支付信息
  - 金额
  - 支付url
- 支付
  - 根支付Url生成支付二维码图片显示, 使用qrcode
  - 扫码支付
  - 轮询请求获取订单状态
- 分页显示订单列表

### 4) 注册流程

- 前台: 输入注册需要的相关信息(用户名/密码/...), 进行前台表单校验, 如果不通过, 提示错误
- 前台: 发送注册的ajax请求(post), 携带注册接口需要的相关数据(用户名/密码/...)

- 后台: 获取到注册请求携带的参数, 去数据库中判断是否已经存在
  - 如果已经存在, 返回提示此用户已存在的提示信息
  - 如果不存在, 保存到数据库, 返回成功的数据
- 前台: 接收到响应
  - 如果是不成功的数据, 提示
  - 如果是成功的数据, 自动跳转到登陆页面

### 5) 登陆流程

- 前台: 输入登陆需要的相关信息(用户名/密码),  进行前台表单校验, 如果不通过, 提示错误
- 前台: 发送登陆的ajax请求(post), 携带登陆接口需要的相关数据(用户名/密码)
- 后台: 获取到登陆请求携带的参数, 去数据库中查询看是否存在
  - 如果不存在, 返回登陆失败的信息
  - 如果存在, 生成一个新的token字符串, 将token与用户信息一起返回
- 前台: 接收到响应
  - 如果是不成功的数据, 提示
  - 如果是成功的数据, 
    - 将用户信息和token都保存到vuex中
    - 将token保存到localStorage中   ==> 不保存用户信息
    - 跳转到首页或redirect页面

### 6) 自动登陆流程

- 简单说: 页面一加载时, 发送请求根据token获取用户信息
- 利用全局前置守卫:
  -  一旦发再当前没有登陆, 但前面登陆过(有token, 没有用户信息)
  -  发送请求根据token获取用户信息
     - 成功了, 保存用户信息及token
     - 失败了(说明token过期了): 清除token, 强制跳转到登陆页面

### 7) 购物车模块

- 购物车数据是保存在后台的, 标识是什么?
  - 未登陆: 标识为用户临时ID(userTempId)
    - 第一次访问时前台利用uuid库生成的唯一字符串, 保存保存在local中
    - 每次请求时通过请求头自动携带它(利用请求拦截器)
  - 登陆: 登陆用户对应的token
    - 用户请求登陆时, 服务器端生成并返回给浏览器, 浏览器收到后自动保存到local中
    - 每次请求时通过请求头自动携带它(利用请求拦截器)
- 添加购物车 / 修改购物项数量
  - 提交请求时, 携带商品的skuid和数量
  - 这2个操作是同一个接口, 也就是数量有可能是负数
- 获取购物车列表
  - 请求获取时不需要携带额外参数, 会自动携带标识: userTempId / token
  - 一旦用户登陆上, 后台会将关联在usertempId上的购物车数据合并到token对应用户关联的购物车数据
- 删除购物项(一个/多个)
  - 请求接口, 携带一个skuId或多个skuId的数组
- 勾选购物项(一个/多个)
  - 请求接口, 携带一个skuId或多个skuId的数组 和 是否勾选的标识数据(0/1)



## Vue 后台项目的重要点

实现element-ui的按需打包

深度作用选择器修改第三方UI组件的内部样式

利用深拷贝解决修改不能取消的问题

利用nextTick与set实现: 动态显示输入框并自动获得焦点

 对Form表单前台校验, 减少无用请求

Upload组件管理图片上传: 限制图片大小和文件类型

路由权限: 路由全局前置守卫 + 动态添加路由: addRoutes()

路由组件懒加载: import()

路由跳转的loading处理: nprogress

登陆成功自动跳转到redirect参数路由

使用各种组件间通信技巧:

​	![后台项目_组件间通信.png](https://i.loli.net/2021/04/10/3vNkhMfDx1cy94T.png)

高复用组件:

![复用组件.png](https://i.loli.net/2021/04/10/gZP1iphXS9TLvOf.png)



## vue项目优化
> [Vue 项目性能优化 — 实践指南](https://juejin.cn/post/6844903913410314247)
> [🔥 2022 前端性能优化最佳实践 - SegmentFault 思否](https://segmentfault.com/a/1190000041753539)
> [聊一聊前端性能优化 - 掘金 (juejin.cn)](https://juejin.cn/post/6911472693405548557)

### 大纲

#### 基础的Web技术的优化
开启 gzip 压缩
浏览器缓存
CDN 的使用
使用Chrome Performance查找性能瓶颈


#### 代码层面的优化
v-if 和 v-show 区分使用场景
computed 和 watch  区分使用场景
v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
长列表性能优化
事件的销毁
图片资源懒加载
路由懒加载
第三方插件的按需引入
* babel-plugin-component
优化无限列表性能
*  vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表
服务端渲染 SSR or 预渲染
* 使用 prerender-spa-plugin添加预渲染

#### Webpack 层面的优化
Webpack 对图片进行压缩
* 插件image-webpack-loader
减少 ES6 转为 ES5 的冗余代码
提取公共代码
* Webpack内置插件 CommonsChunkPlugin
模板预编译
* 预编译模板最简单的方式就是使用单文件组件; vue-template-loader
提取组件的 CSS
优化SourceMap
构建结果输出分析
* Vue 项目中用到的分析工具：webpack-bundle-analyzer. 
Vue项目的编译优化





### 性能优化本质

**展示更快**、**交互响应快**、**页面无卡顿情况**。

更详细的说，就是指，在用户输入url到站点完整把整个页面展示出来的过程中，通过各种优化策略和方法，让页面加载更快；在用户使用过程中，让用户的操作响应更及时，有更好的用户体验。

### 性能优化指标

1.性能评估 Chrome Performance选项卡 / Lighthouse 生成性能检测报告 

2.值得关注的性能指标

(1)LCP (Largest Contentful Paint 最大内容绘制 ) 

(2)首屏渲染时间（也叫白屏时间） 

(3)FCP (Fitst Contentful Paint 首先内容绘制 ) 

(4)可交互时间 (Time to Interactive TTI)

(5) Network请求时间(jax,js等) 

3.浏览器开发者工具什么都能看得到，可以调用性能监测API 或建立 前端监控系统(无痕埋点) 



### 性能优化手段

前端性能优化分为两类，一类是文件加载更快，另一类是文件渲染更快。 

* 加载更快的方法： 
  * 让传输的数据包更小（压缩文件/图片）：图片压缩和文件压缩 
  * 减少网络请求的次数：雪碧图/精灵图、节流防抖 
    * 雪碧图的应用场景一般是项目中不常更换的一些固定图标组合在一起，比如logo、搜索图标、切换图标等
    * 电商项目中最常用到的懒加载，一般在查看商品展示的时候通常下拉加载更多，因为商品数据太多，一次性请求过来数据太大且渲染的时间太长。
  * 减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等） 
* 渲染更快的方法： 
  * 提前渲染：ssr服务器端渲染 
  * 避免渲染阻塞：CSS放在HTML的head中 JS放在HTML的body底部 
  * 避免无用渲染：懒加载 
  * 减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签 


### 1网页优化
#### JS中的性能优化

##### 1.不要覆盖原生方法

##### 2.事件委托(简化DOM操作)

##### 3.//JS动画

##### 4.节流与防抖



#### 页面渲染优化

##### 1.避免CSS, JS堵塞

CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。**尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化）**

实际使用时，可以遵循下面3个原则：
- **CSS 资源优于 JavaScript 资源引入**
- **JS 应尽量少影响 DOM 的构建**

改变JS阻塞方式
* defer（延缓）模式
`defer` 方式加载 script, 不会阻塞 HTML 解析，等到 DOM 生成完毕且 script 加载完毕再执行 JS。
* async（异步）模式
`async` 属性表示异步执行引入的 JS，加载时不会阻塞 HTML解析，但是加载完成后立马执行，此时仍然会阻塞 load 事件。
从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 `async`；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用`defer`。

##### 2.使用字体图标iconfont代替图片图标
字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。



##### 3.降低CSS选择器复杂性
浏览器读取选择器，遵循的原则是从选择器的右边到左边读取

1. 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素
2. 关注可以通过继承实现的属性，避免重复匹配重复定义
3. 尽量使用高优先级的选择器，例如 ID 和类选择器。
4. 避免使用通配符，只对需要用到的元素进行选择



##### 4.减少重绘和重排(回流)

**回流必将引起重绘，重绘不一定会引起回流，回流比重绘的代价要更高。**
如何避免?
**CSS**
- 避免使用table布局。
- 尽可能在DOM树的最末端改变class。
- 避免设置多层内联样式。
- 将动画效果应用到position属性为absolute或fixed的元素上。
- 避免使用CSS表达式（例如：calc()）。

**JavaScript**
- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
- 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

##### 5.使用flexbox布局

##### 6.图片资源优化

使用雪碧图

雪碧图的作用就是减少请求数，而且多张图片合在一起后的体积会少于多张图片的体积总和

图片压缩

压缩方法有两种，一是通过在线网站进行压缩，二是通过 webpack 插件 image-webpack-loader。它是基于 [imagemin](https://link.segmentfault.com/?enc=OIHazSW1xgE0eJv1ufzlhg%3D%3D.50sTefI%2FunQpQnTLFGGC2iHdYBRXLANOzcn9%2BnYmSIMvSsZ2MxqDRBV%2F%2BgM8jZ3hfnNCnY2A6GBe0w8Jx7FIk7eCSR1knYAy2lBQYNu45s4%3D) 这个 Node 库来实现图片压缩的。

图片拉加载

在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。

使用CSS3代替图片


使用webp格式的图片

小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。



##### 开启 Gzip
- 下载: yarn add compression-webpack-plugin --dev
- vue.config.js

```
var CompressionWebpackPlugin = require('compression-webpack-plugin');
...
configureWebpack: config => {
  config.plugins.push(
      new CompressionWebpackPlugin({
          test: new RegExp('\\.(js|css)$'),
          threshold: 8192,
          minRatio: 0.8
      })
 )
```

- nginx.conf中
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6749ab642da04d578181cc30d6f114e7~tplv-k3u1fbpfcp-watermark.image)

##### 静态资源(css/js/img)使用CDN引入
浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。
![image-20201119221157741.png](https://i.loli.net/2021/04/09/c2ZFgNI75WtVAze.png)


### 2Vue代码层面优化

####  1) v-for 遍历列表
指定非下标的唯一key
不同时使用 v-if

#### 合理使用watch computed
- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行**异步**或**开销较大**的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

#### 长列表性能优化
Vue 会通过 `Object.defineProperty` 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 `Object.freeze` 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

```javascript
export default {
  data: () => ({
    users: {}
  }),
  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
};
```



#### 优化无线列表性能: 虚拟列表
如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 [vue-virtual-scroll-list](https://link.segmentfault.com/?enc=RwGR6yk1CBddLI%2Bu8vtszQ%3D%3D.dlCkBYR4PA%2B55K3tT%2FQw8n0NYgopqNuyAiHiOl%2BmqkEbvSEXfwJzLmiOlCKtzroQt8eQCA8Nhva3W4K0YZ%2B%2FqtpzzMo6urAt17%2F52bgtgue87rsur8bCDAKfgfIWQNni) 和 [vue-virtual-scroller](https://link.segmentfault.com/?enc=VUESvmfK3cEynJ2TsRaDtw%3D%3D.BJ5wA7H4OmMcXokRRU59qGLNEEnNcyBtrSbVUK4mD9Dx8n1PY3Ug0ZqP05IZgBQjewtZNwuUGdg0J9VPr%2FVEGmAMU0cO94XO2a%2FeHYKtnDDlsvX9R2pFCY2p2kTTalwi) 来优化这种无限列表的场景的。



#### 事件的销毁
Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 JS 内使用 `addEventListener` 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：

```javascript
created() {
  addEventListener('click', this.click, false)
},
beforeDestroy() {
  removeEventListener('click', this.click, false)
}
```


#### 图片资源懒加载
如使用v-lazyload

##### 页面大量图片，如何优化加载，优化用户体验
1. 图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
2. 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
3. 如果图片为css图片，可以使用CSSsprite，SVGsprite等技术。
4. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
5. 如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。



#### 路由组件懒加载
```js
https://blog.csdn.net/fanjianglin/article/details/113430620
```

>  **Vue动态加载组件主要有两类方式，即import方式和require方式**, 

const Home = () => import('./pages/Home')

#### 第三方插件的按需引入
如: element-ui / vant 


#### 服务端渲染SSR / 预渲染

具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《 [Vue SSR 踩坑之旅](https://link.segmentfault.com/?enc=Hf%2BIPuMRv2K%2BeUWhiiDh1w%3D%3D.3jDS1JNzAA3uTddj1k%2FbKUkxDfmUV66bvM0o0VlBp7p4tnJIH%2F%2FCoaWInurEjB3S) 》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要**预渲染**，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 [prerender-spa-plugin](https://link.segmentfault.com/?enc=0VzVqkIFywisus2tXadNQA%3D%3D.idXZ937QutVTXXQ7wd01EK5OzIiISu2XSekHrv7pF9FQiDAmnD%2BWfxWCnx3amR%2FY1GwMIYYXtSDhO1lW0mWFyN7OTrA%2BbYHHgPsQzzqGblwB1SWoyI0BnBBKo7se13rh) 就可以轻松地添加预渲染 。


### 3 webpack配置层面优化

#### 1) 兼容性处理

- JS
  - babel-loader: presets: ['@babel/preset-env'] 问题就是只能编译/转换简单语法
  - @babel/polyfill: 做复杂语法(新的APi)兼容，问题是体积太大了
  - core-js: 在@babel/preset-env基础上，增加了useBuiltIns: 'usage'来实现按需打包

- CSS  
  - postcss-loader  
  - 内部使用autoprefixer插件, 给C3样式自动添加厂商前缀
  ![preview](https://segmentfault.com/img/remote/1460000014782566/view)

  - 在package.json中指定browserslist来指示postcss-loader兼容性做到什么程度

#### 2) 拆分打包与压缩
对第三方JS包, css进行拆分打包
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2130fabf53ec430b9d103ae8b8009eca~tplv-k3u1fbpfcp-watermark.image)

#### 3) 资源预加载(prefetch)
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a896fd6ab9e4e3b9479ea018aae8b49~tplv-k3u1fbpfcp-watermark.image)

#### 4) 生产环境时不生成 SourceMap
productionSourceMap: false
减少打包文件

#### 5) 文件名hash化=>利用浏览器缓存
对打包文件名用上contenthash ==> 某个bundle对应的模块文件内容发生改变文件名才会变化 ===> 利用浏览器缓存

#### 6) 代码Tree Shaking
效果: 打包时'摇掉'模块中没有被使用的代码
条件: 必须是ES6模块化导出且进行代码压缩时



### 4缓存优化 ??

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。
- HTML：使用协商缓存。
- CSS、JS和图片：使用强缓存，文件命名带上hash值



### 其他

#### vue-cli3 已有优化

> https://juejin.cn/post/6844904083858407438

webpack4中，`mode`为`production`时会自动开启**代码压缩**和`Tree Shaking`





## Vue3

### Proxy 与 Object.defineProperty 优劣对比
Proxy 的优势如下:
Proxy 可以直接监听对象而非属性；
Proxy 可以直接监听数组的变化；
Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

Object.defineProperty 的优势如下:
兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。



### 3.0 特性
#### 监测机制的改变
3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了Vue2当中基于 Object.defineProperty 的实现所存在的很多限制：
* 只能监测属性，不能监测对象
* 检测属性的添加和删除；
* 检测数组索引和长度的变更；
* 支持 Map、Set、WeakMap 和 WeakSet。

新的observer还提供了以下特性：
* 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。
* 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。
* 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。
* 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。
* 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。

#### 模板
模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。
同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。

#### 对象式的组件声明方式
vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。
此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。
#### 其它方面的更改
vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：

支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。
支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。
基于 treeshaking 优化，提供了更多的内置功能。


## vue开发中踩过最大的坑

### '就地复用'的问题
> vue在用v-if v-else渲染两个相同的按钮，一个绑定了事件，另外一个没有绑定事件。当渲染状态切换的时候，会导致未绑定事件的按钮也绑定上了事件。
> 原因是有的vue版本在没给条件渲染的元素加上key标识时候会默认复用元素提升渲染能力，导致事件被错误的绑定上另一个按钮。解决方案：更换高版本vue，加上key标识两个按钮。












## React

### 基础

- JSX语法最终都会经过babel编译，编译成JS语法
- 组件名首字母必须大写，JSX一旦标签首字母小写就会当做html元素解析，但是html中没有这个元素就会报错
- 内部返回虚拟DOM对象元素必须有结束符
- 必须要保证更新的数据是一个全新数据（不能push unshift等）
- Fragment  能作为多个虚拟DOM元素的根节点    优点：不会生成真实DOM元素   简写方式<></>

#### 通信方式

- props

  用PropTypes限制传入类型

- refs

  xxx = React.createRef()，再作用在标签上

- 消息订阅(subscribe)-发布(publish)机制

  import PubSub from 'pubsub-js' //引入

  PubSub.subscribe('delete', function(msg,data){ }); //订阅

  PubSub.publish('delete', data) //发布消息

- context  内部包含两个组件

  context.Provider 提供者（负责向后代组件提供数据）

  context.Consumer 消费者（负责消费数据，使用父（爷）组件提供的数据）

- forwardRef，获取工厂/纯函数组件的ref

  函数组件通过第二个参数接收ref

- render props

  本质上是一个组件，将B组件渲染到A组件内部，同时A组件传递必要的props（往往是属性数据，而不是方法）

  ```react
  <A render={(count) => {return <B count={count} />;}}/>
  ```

- 总结：

  触发事件元素和要收集数据元素是同一个元素，就e.target

  触发事件元素和要收集数据元素不是同一个元素，就用refs

#### 生命周期函数

**始化流程**

- constructor
- componentWillMount    将要挂载
- render     开始执行
- componentDidMount     挂在完成

**更新流程（三种方式触发）**

1. 父组件this.setState导致子组件重新渲染，子组件会触发：

   componentWillReceiveProps	将要接收数据

   shouldComponentUpdate	

   componentWillUpdate

   render

   componentDidUpdate	更新完成

2. 父组件this.setState, 父组件触发：

   shouldComponentUpdate

   componentWillUpdate

   render

   componentDidUpdate

3. 父组件this.forceUpdate, 父组件触发：

   componentWillUpdate

   render

   componentDidUpdate 

**卸载**

- componentWillUnmount 

  直接将之前插入到指定容器的DOM结构直接移除

  页面上没有该内容  

**即将废弃的生命周期**

- componentWillMount
- componentWillUpdate

**新的生命周期**

- static getDerivedStateFromProps(props, state){}

  用来取代willMount和willUpdate

  render 方法之前调用，并且在初始挂载及后续更新时都会被调用

  返回一个对象来更新 state，如果返回 null 则不更新任何内容

#### 重要生命周期函数

- componentDidMount

  发送请求、设置定时器、绑定事件等一次性任务

- shouldComponentUpdate    做性能优化

  返回值 true 要更新

  返回值 false 不更新

- componentWillUnmount

  取消请求、清除定时器、解绑事件等收尾工作

#### 高阶组件：HOC

- 本质上是一个函数：执行函数接受一个组件作为参数，返回值是一个新组件
- 给高阶组件命名 --> displayName优先级最高
- 可用高阶函数的形式传参
- 可用装饰器语法调用

#### Hooks（钩子）

- 本质就是函数，能让你使用React组件的状态和生命周期函数...

- 作用：让代码更加可复用，不用在定义繁杂的HOC

- 使用：

  - 让工厂函数组件拥有状态数据state

    `const [状态数据（初始化为defaultValue）, 更新状态数据的方法] = React.useState(defaultValue)`

  - 让工厂函数组件拥有生命周期函数（componentDidMount componentDidUpdate componentWillUnmount）

    ```react
    React.useEffect(() => {
        return () => {
          PubSub.unsubscribe("MSG");
        };
    },[])
    ```

#### react-router

- **Hash 模式** 

  兼容性好

  缺点带#

  刷新页面时只会把#前面地址发请求

- **History 模式**

  兼容性稍差

  地址很干净

  刷新页面时会把所有地址带上发请求（导致开发时刷新浏览器404问题）

  解决方法：

  ​		出现404，就直接返回 index.html

  ​		webpack配置devServer historyApiFallback: true

  问题：引入资源（css/js）路径问题

  ​		webpack配置output publicPath: "/"

  ​		index.html --> "/bootstrap.css"

- **API**

  ```react
  import {
    BrowserRouter,HashRouter,Link,NavLink,Route,Redirect,Switch,
  } from "react-router-dom";
  ```

- **路由组件三大属性（都在props上）**

  location     pathname 当前路由地址    state 

  history       push/replace/goBack/goForward/listen 等方法，用来操作浏览历史记录

  match        params 参数
  
- **特点**

  1. 默认是模糊匹配，如果想要精准匹配，需要给Route标签添加一个属性 exact
  2. 默认每次匹配都会匹配所有注册路由
  3. 性能优化相关： Switch, 一旦有匹配成的路由就停止匹配

- **路由传参**

  1. params传参

     ```react
     <Route path='/home/:id' component={Home}></Route>
     ```

  2. props 传参

     ```react
     <Route path='/personal' render={() => <Personal num={123}/>}></Route>
     ```

     

### 面试

#### 工厂函数组件和ES6类组件的区别

1. this不一样

   工厂函数没有this，ES6类组件函数中有this

2. 功能不一样

   工厂函数没有this，有些功能默认实现不了；ES6类组件有this，所以可以实现 

- 总结

  工厂函数组件一般用来定义功能简单组件

  ES6类组件一般用来定义功能复杂组件

#### 函数柯里化

- 是闭包的典型应用

```react
// 普通函数
function fn(a, b) { return a + b}
// 经过函数柯里化处理的函数
function fn(a) {
  return function (b) {
    return a + b;
  }
}
```

#### 性能优化

- 减少render调用次数，从而减少diff比较和重新渲染次数

1. 自己编写shouldComponentUpdate（nextProps, nextState）函数进行优化

2. PureComponent：组件内部实现了一种类似shouldComponentUpdate的比较

   ```react
   import { PureComponent } from "react";
   export default class Index extends PureComponent {}
   ```

- shouldComponentUpdate 和 PureComponent 同时存在只会生效 shouldComponentUpdate

#### Portals

- Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
- 通常情况下不会使用，一般用于Modal组件 
- 防止组件卸载/重新创建过程中创建多个div

#### 如何遍历显示子路由

- 没有通过Route加载，所以没有路由组件三大属性

- 解决：react-router-dom有一个高阶组件withRouter，withRouter内部保存路由组件的三大属性，会给被包装组件传递三大属性

- 判断routes中哪个配置匹配上当前路径

  forEach 一般写代码推荐forEach，语义化更好，一般用于要全部遍历的场景

  for循环 一般写库或框架，追求极致性能使用。性能好，一般用于遍历可中断的场景

- 判断 当前路径是否以一级菜单开头：

  String.prototype.startsWith()

  正则表达式

注意：

​		如果Route组件不加exact属性（严格模式），则会默认匹配以该路径开头的组件

#### 虚拟DOM的diff算法

**diff 策略**

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

- 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。

**tree diff**

- 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。

- 即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

- 如果出现了 DOM 节点跨层级的移动操作，性能不好!

**component diff** 

- 如果是同一类型的组件，按照原策略继续tree diff。

* 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。

* 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。

**element diff**

- 允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！

- 通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动

- 在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

### 深入理解setState

- **setState()更新状态的两种写法:**

  setState(stateChange,[callback])--------对象式的setState

  setState(updater,[callback])---------函数式的setState

- **setState()更新状态的动作是同步还是异步的**？（setState()执行的位置对其后续动作的影响）

  在由react所控制的回调函数中更新的动作是【异步】的，如：生命周期钩子 / react所监听的事件

  在非react控制的异步回调函数中更新的动作是【同步】的，如：定时器的回调 / 原生事件监听回调 /Promise所指定的成功、失败回调 / ajax所指定的成功或失败的回调

- **关于异步的setState()连续多次调用的问题**

  1. 多次调用，如何处理？

     若是对象式的setState，多次更新状态的动作合并为一次(只以最后一次为准),所以就调用一次render

     若是函数式的setState，每次更新的动作都会生效(更新的动作不合并)，但是只会调用一次render

  2. 注意：

     若函数式setState和对象式setState混用的时候，要把函数式写在最后

  3. 如何得到异步更新后的状态？

     在setState第二个参数的回调里





## 移动端

### 基础知识

- 1英寸(inch) = 2.54厘米(cm)

-  IPhone 6 的屏幕分辨率为 750 * 1334  设备独立像素为 375 * 667

- 物理像素：由屏幕制造商决定，屏幕生产后无法修改

- css像素：单位是px，它是为 Web 开发者创造的

- 设备独立像素的出现，使得即使在【**高清屏**】下，也可以让元素有正常的尺寸，让代码不受到设备的影响，它是设备厂商根据屏幕特性设置的，无法更改。

- 1个位图像素对应1个物理像素，图片才能得到完美清晰的展示

- pc端视口：默认宽度和浏览器窗口的宽度一致，也被称为初始包含块`document.documentElement.clientWidth`

- 移动端视口:

  - 布局视口：一般是**<span style='color:red'>980px</span>**左右，布局视口经过压缩后，横向的宽度用css像素表达就不再是375px了，而是980px

  - 视觉视口：用户可见的区域，它的绝对宽度永远和设备屏幕一样宽

  - 理想视口：布局视口宽度 与 屏幕等宽（设备独立像素），靠meta标签实现

    ```html
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    ```

### 适配

#### 1.viewport 适配

- 方法：拿到设计稿之后，设置布局视口宽度为设计稿宽度，然后直接按照设计稿给宽高进行布局即可。
- 一般适用于：计图稿宽度 < 375

```js
<meta name="viewport" content="width=375">
```



#### <span style="color:#ee0b41">2.rem适配</span>

- 方案一：（百度）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小 = **( 当前设备横向独立像素值 *100) / 设计稿宽度**</span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / 100** </span>
  4. 增加 JS 代码进行实时适配
- 方法二：（淘宝、搜狐、唯品会）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小  = **当前设备横向独立像素值 / 10** </span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / (设计稿宽度 / 10)**</span>
  4. 增加 JS 代码进行实时适配

#### 3.vw适配

vw和vh是两个相对单位

- 1vw = 等于布局视口宽度的1%
- 1vh = 等于布局视口高度的1%

#### 4.1px物理像素边框

高清屏幕下 1px 对应更多的物理像素，所以 1 像素边框看起来比较粗，解决方法如下

##### 方法一

使用媒查询：

```css
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo{
        border: 0.5px solid black;
    }
}
或
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo2::after{
        transform:scaleY(0.5);
    }
}
```

##### 方法二

根据dpr扩大布局视口，例如dpr为n则布局视口改为原来的n倍，则元素尺寸均变为原来的n分之一，为了保证元素尺寸比例不变，扩大根字体为原来的n倍，但整个过程中边框一直用px作为单位，不用rem。

1. rem 页面布局

2. 元素的边框设置为 1px

3. 通过 viewport 中的 initial-scale 将布局视口扩大n倍，这样页面元素就比原来缩小了n倍

```js
var viewport = document.querySelector('meta[name=viewport]')
var scale = 1 / window.devicePixelRatio
viewport.setAttribute('content', 'width=device-width,initial-scale=' + scale);
```

4. 重新设置根元素字体

```js
var fontSize = parseInt(document.documentElement.style.fontSize);
document.documentElement.style.fontSize = fontSize * window.devicePixelRatio + 'px'
```

### 移动端事件

* touchstart   元素上触摸开始时触发
* touchmove   元素上触摸移动时触发
* touchend   手指从元素上离开时触发
* touchcancel   触摸被打断时触发

### 移动端中touchstart,touchend,click执行顺序

- touchstart
- touchend
- click，浏览器在 click 后会等待约300ms去判断用户是否有双击行为，如果300ms内没有再一次click，那么就判定这是一次单击行为

### 点击穿透

- touch 事件结束后会默认触发元素的 click 事件

  方法一：阻止默认行为

  方法二：使背后元素不具备click特性，用touchXxxx代替click

  方法三：让背后的元素暂时失去click事件，300毫秒左右再复原，属性`pointer-events: none;`

  方法四：让隐藏的元素延迟300毫秒左右再隐藏

### getComputedStyle

- 可读取到非内联样式上的属性
- 可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式



### viewport

#### 设备像素(device pixel)

又名物理像素, 从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为`pt`

#### 设备独立像素

设备独立像素简称 DIP （device-independent pixel），又称：**屏幕密度无关像素**。表示*与设备无关的逻辑像素*，<span style="color:blue">代表可以通过程序控制使用的虚拟像素</span>。是一个总体概念，包括了`css`像素。可以理解为：<span style="color:blue">`CSS像素 = 设备独立像素 = 逻辑像素`。</span>在`iOS`、`Android`和`React Native`开发中样式单位其实都使用的是设备独立像素。

出现的原因?

更高分辨率的屏幕诞生.理论上来讲，在白色手机(分辨率320\*480)上相同大小的图片和文字，在黑色手机(分辨率640\*960)上会被缩小一倍，因为它的分辨率提高了一倍。

获取

在`javaScript`中可以通过`window.screen.width/ window.screen.height` 查看

#### 设备像素比

##### 是什么

设备像素比dpr(device pixel ratio), 单一方向上【设备像素】除以【设备独立像素】的比值，用于描述整个渲染环境在硬件设备上的缩放程度。

##### 获取

`window.devicePixelRatio`来帮助我们获取`dpr`。



#### 布局视口

获取

`document.documentElement.clientWidth / clientHeight`

设置

如果显式设置布局视口,可以使用HTML中的meta标签

```javascript
<meta name='viewport' content="width=400"
```

布局视口使移动端浏览器屏幕宽度与视口完全独立开来. CSS将根据它来进行计算,并被它约束.



#### 视觉视口

视觉视口(`visual viewport`)：用户通过屏幕真实看到的区域。

视觉视口默认等于当前浏览器的窗口大小<span style="background: #ccc">（包括滚动条宽度）</span>。

用户可以通过缩放操作视觉视口,同时不会影响布局视口.

<u>获取:</u>

```javascript
window.innerwidth / innerHeight
```



#### 理想视口

调用`screen.width / height`来获取理想视口大小。

上面在介绍`CSS像素时`曾经提到`页面的缩放系数 = CSS像素 / 设备独立像素`，实际上说`页面的缩放系数 = 理想视口宽度 / 视觉视口宽度`更为准确。????

所以，当页面缩放比例为`100%`时，`CSS像素 = 设备独立像素`，`理想视口 = 视觉视口`。

移动设备一般具有固定的DPR,即在缩放100%时, 用多少个物理像素显示一个逻辑像素,在CSS中就是用多少个物理像素来显示一个CSS像素.

> 理想视口宽度 = 移动设备横向分辨率 / DPR



#### 视口设置

移动设备默认的`viewport`是`layout viewport`，也就是那个比屏幕要宽的`viewport`，但在进行移动设备网站的开发时，我们需要的是`ideal viewport`。那么怎么才能得到`ideal viewport`呢？这就该轮到`meta`标签出场了。

借助`meta`元素的`viewport`来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maxium-scale=1, user-scalable=no">
```



`viewport`配置的具体含义：

| name          | 可能值                | 描述                                                         |
| :------------ | :-------------------- | :----------------------------------------------------------- |
| width         | 正整数或device-width  | 以pixels（像素）为单位， 定义布局视口的宽度。                |
| height        | 正整数或device-height | 以pixels（像素）为单位， 定义布局视口的高度。                |
| initial-scale | 0.0 - 10.0            | 定义页面初始缩放比率。This parameter sets the initial zoom level, which means **1 CSS pixel** is equal to **1 viewport pixel**. |
| minimum-scale | 0.0 - 10.0            | 定义缩放的最小值；必须小于或等于maximum-scale的值。          |
| maximum-scale | 0.0 - 10.0            | 定义缩放的最大值；必须大于或等于minimum-scale的值。          |
| user-scalable | 布尔值（yes或者no）   | 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。      |






## 小程序

### 1) 小程序特点

1. 体积小，压缩包的体积不能大于2M
2. 没有DOM对象
3. 基于组件化开发
4. 小程序环境不同于浏览器环境
   1. 浏览器环境中全局对象： window
   2. 小程序环境中全局对象：wx
   3. 小程序环境中没有window对象

### 2)小程序适配

1. 小程序适配单位： rpx(responsive px) 响应式单位
2. 小程序中规定所有的机型中页面宽度都是750rpx
3. iphone6: 1物理像素 = 0.5px = 1rpx ---> 1px = 2rpx
4. 小程序底层已经做了viewport适配

```js
const SCREEN_WIDTH = 750

let RATE = wx.getSystemInfoSync().screenHeight / wx.getSystemInfoSync().screenWidth

Page({
  data: {
    screenTotalW: SCREEN_WIDTH,
    screenTotalH: SCREEN_WIDTH * RATE
  }
)

// wxml
<view style="width:{{screenTotalW}}rpx; height:{{screenTotalH}}rpx"></view>

```

### 3) 小程序相关语法

1. 数据绑定

   1. 单项数据流: Model ---> view
   2. 修改状态数据： this.setData() 同步行为
   3. 页面中的数据均来自于data中，使用data中的数据的时候记住使用表达式{{}}
   
2. 事件绑定

   1. 事件分类： 冒泡事件 || 非冒泡事件
   2. 绑定的方式： bind + 事件名  || catch + 事件名
   
3. 路由跳转

   1. wx.navigateTo() || wx.redirectTo()
   
4. 本地存储
   1. 语法： 
      1. wx.setStorage() || wx.setStorageSync()
      2. wx.getStorage() || wx.getStorageSync()
   2. 注意点
      1. 单个key上限是1M
      2. 整体上限是10M
   
5. 全局传参

   app.js中可定义全局参数globalData

### 4) 向事件对象传参

1. 语法
   1. id=value
   2. data-key=value
2. 获取
   1. id: event.target.id || event.currentTarget.id
   2. data-key: event.target.dataset.key || event.currentTarget.dataset.key
3. 使用场景
   1. id：通常需要向event对象传递单一且唯一的标识
   2. data-key:   需要向event对象传递多个标识数据

### 5) 小程序获取用户唯一标识（openId）

1. 客户端先通过wx.login(获取code
2. wx.request()发送code给服务器
3. 服务器端发送请求携带参数(code, appSecret（开发密钥）, appId)给微信服务器获取openId
4. 微信返回openId给服务器后，服务器进行加密再返回给前端
5. 前端进行本地储存，下次发送请求时携带参数

### 6) 小程序支付流程

1. 用户在小程序客服端下单(包含用户及商品信息)
2. 小程序客户端发送下单支付请求给商家服务器
3. 商家服务器同微信服务器对接获取唯一标识openID
4. 商家服务器根据openId生成商户订单(包含商户信息)
5. 商家服务器发送请求调用统一下单API获取预支付订单信息
6. 商家对预支付信息签名加密后返回给小程序客户端
7. 用户确认支付（鉴权调起支付）
8. 微信服务器返回支付结果给小程序客户端
9. 微信服务器推送支付结果给商家服务器端


### 7) 面试问题

- Iphone6的dpr为多少？Iphone6Plus比Iphone6显示图像清晰吗？

  视网膜屏幕是分辨率超过人眼识别极限的高分辨率屏幕，Iphone4的dpr = 2; 人类肉眼分辨的极限
  
- 生命周期函数实际测试和官网描述有差

- wx.setStorage()，单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB

- 性能优化

  一个页面一次只有一个video标签，其余的使用image代替
  
- 请求相关

  小程序为了安全起见只支持Https请求

  wx.request最大并发限制10个

- 如何使用组件

  先创建组件，在对应的json文件下设置component: true

  到使用组件页面的json文件中，注册组件填写相应的路径

- 使用npm包

  下载后，勾选使用npm模块，再构建npm，会将node_modules中的包打包到miniprogram_npm中

- 分包相关

  分包后可解决2M限制，并且能分包加载内容，提高性能

  分包后单个包的体积不能大于2M，所有包的体积不能大于16M

  1. 常规分包

     加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容

     分包的页面可以访问主包的文件，数据，图片等资源

  2. 独立分包

     独立分包可单独访问分包的内容，不需要下载主包

     独立分包不能依赖主包或者其他包的内容

     通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页 || 活动页

  3. 分包预下载

     在加载当前包的时候可以设置预下载其他的包

     缩短用户等待时间，提高用户体验

### 7)-2小程序开发遇到的问题

```js
1.页面通信方式及注意事项
通信方式: 路由传参+storage
 路由传参只能通过query形式(原生小程序对query参数有长度限制,如果长度过长会自动截取.且会对query参数自动进行类型转换)
 wx.getStorage('cookies')

2.本地存储 有上限

3.请求
 协议: https请求
 并发数:10个
 
4.分包
4.1原因:程序要求压缩包体积小于2M;提高用户体验, 提高页面的加载速度
4.2形式
4.3特点:

5.性能优化:
5.1 视频优化 图片封面
5.2 
```



### 8) 开发相关

- setData行为始终是同步的
- H5中实现滑块功能，推荐大家使用：better-scroll

### 9) 封装

- 封装函数：

  1. 功能点明确

  2. 函数内部保留静态的数据

  3. 将动态的数据抽取出来作为形参，由使用者根据场景不同动态传入实参

- 封装组件：

  1. 功能点明确 || 呈现效果

  2. UI组件 || js组件

  3. 组件内部保留静态的数据

  4. 将动态的数据抽取出来作为 props属性，由使用者根据场景不同动态以标签属性的形式导入

  5. 封装良好的组件应该规定传入props数据的必要性还有数据类型 propsType

## express

### 基本使用

```js
// 引入
let express = require('express');
// 1. 生成应用实例
const app = new express(); // app: application 代表整个应用

// 3. 注册路由
app.get('/', (request, respone) => {
  console.log('1111');
  // 返回数据
  respone.end('success data');
});

app.get('/login', (req, res) =>  {
  console.log('2222');
  res.end('login data');
});

app.post('/register', (req, res) =>  {
  console.log('4444');
  res.end('register data');
});

// 2. 绑定监听(设置当前项目的端口号)
app.listen('3001', (err) => {
  if(err){
    console.log('服务器启动失败');
    console.log(err);
  }else {
    console.log('服务器启动成功');
    console.log('服务器地址： http://localhost:3001');
  }
})

```

### 2. 路由

1. 路由分类
   1. 前端路由
   2. 后端路由
2. 前端路由
   1. 发请求不需要走网络传输层
   2. 需要由前端指定的js库解析(vue-router, react-router-dom)
   3. 应用： SPA（single page application）
3. 后端路由
   1. 发请求需要走网络传输层
   2. 需要由服务器端解析
   3. 应用： 前后端交互

### 3. 路由参数

1. get请求
   1. params参数： 
      1. 请求： url/:id ==> url/参数
      2. 获取： req.params
   2. query参数:
      1. 请求：url?key=value&key2=value2
      2. 获取: req.query
   3. 总结:
      1. params参数只能有一个参数，适用于参数为标识数据
      2. query参数可以有多个
2. post请求
   1. params参数
   2. query参数
   3. body参数
      1. 相对安全
      2. 获取req.body，但是不能直接获取，需要使用中间键

### 4. res常用方法

1. res.end() 返回响应: 直接返回数据
2. res.send() 根据数据类型不同，自动做出判断处理，再返回，如：中文的话会自动设置content-type
3. res.set() 设置响应头的方法
4. res.json() 返回的数据一定是json数据，直接返回
5. res.cookie() 设置cookie
6. res.status() 设置状态码
7. res.redirect() 返回的是新地址，状态码通常是302，浏览器接收到响应以后会跳转至新的地址
8. res.download()  返回的文件信息，浏览器会自动下载该文件

### 5. 中间件

1. 本质
   1. 就是一个函数
2. 作用
   1. 处理请求，返回响应数据
   2. 获取，修改请求的参数及响应数据
   3. 执行下一个中间键
3. 体现形式
   1. (req, res, next) => {}
   2. req: 请求对象
   3. res: 响应对象
   4. next：是一个方法，用来调用下一个中间键
4. 注意
   1. 连续使用多个中间键的时候返回数据的动作应该放在最后且只有一次
   2. 路由对应的回调 也是中间键函数
   3. 如果请求方法和中间键共存的情况下，只能匹配一个，谁在前就匹配谁（满足匹配条件情况下）

## 问题




### 格式化金钱，每千分位加逗号

```javascript
function format(str) {
    let s = ''
    let count = 0
    for (let i = str.length - 1; i >= 0; i--) {
        s = str[i] + s
        count++
        if (count % 3 == 0 && i != 0) {
            s = ',' + s
        }
    }
    return s
}


function format(str) {
    return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,')
}
```



### 保持前后端实时通信

保持前后端实时通信的方法有以下几种： 

轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。

* 优点就是实现简单，无需做过多的更改。
* 缺点是轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担  

长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，如果没有新消息，就一直等待。有新消息，才会返回给客户端。

* 在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。
* 优点是做了优化，有较好的时效性。
* 缺点是保持连接会消耗资源; 服务器没有返回有效数据，程序超时。

iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。

* 优点是消息能够实时到达；浏览器兼容好。
* 缺点是服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。 

WebSocket是类似Socket的TCP长连接的通讯模式，一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。缺点是浏览器支持程度不一致，不支持断开重连。 SSE(Server-Sent Event)是建立在浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。

SSE 是单向通道，只能服务器向浏览器发送，因为 streaming 本质上就是下载。 优点是SSE 使用 HTTP 协议，现有的服务器软件都支持。SSE 属于轻量级，使用简单；SSE 默认支持断线重连； 

轮询适用于：小型应用，实时性不高 长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天 iframe适用于：客服通信等 WebSocket适用于：微信、网络互动游戏等 SSE适用于：金融股票数据、看板等










## 自我介绍

```md
// 时间1分钟30秒左右

您好,面试官. 我叫xxx, 我面试的岗位是前端开发.
个人目前涉及的技术包括:
 vue2及vuex,vuerouter全家桶系列, UI框架包括elementUI, antUI, vantUI.
 熟悉原生JavaScript;
 了解react,python,SEO/SEM.搭建过Django博客,做过搜索引擎关键字排名及网站推广.
 同时个人也在github上翻译英文仓库.
 
个人做过的项目有:
	商城网站前后台
	国网APP下一个微应用
	
	商城网站用来为客户提供商品的展示和购买服务,使用vue2+elementUI,个人负责及参与的页面包括首页,详情页及支付购买页面.
	国网APP的微应用是是便于国网基层员工对用电单位进行多维度的信息普查工具,使用vue2+vant, 个人负责的是基本信息普查模块.
	
最后,我希望在新的工作岗位上能有更多项目历练及技术提升的机会.
```

