## 面试题收集

> https://gitee.com/zxfjd3g/review-211227/tree/master
>
> [Trivia questions in front end interviews | Front End Interview Handbook](https://www.frontendinterviewhandbook.com/zh/trivia/)
>
> https://github.com/h5bp/Front-end-Developer-Interview-Questions
> 
> https://github.com/yangshun/front-end-interview-handbook
> 
> https://github.com/paddingme/Front-end-Web-Development-Interview-Question
> 
> https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions
> 
> https://www.frontendinterviewhandbook.com/zh/trivia/





## 标题大纲

[toc]











## HTML

### 标签语义化

什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。

#### 好处

- 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
- 方便其他设备解析，如盲人阅读器根据语义渲染网页
- 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。


#### 语义化标签
* 新的语义化元素：article 、footer 、header 、nav 、section,progress,detail&summary
* 新的 API：音频(用于媒介回放的 video 和 audio 元素)、图形（绘图 canvas 元素）



### doctype有什么用
doctype是文档类型声明，目的是告诉解析器要使用什么样的文档类型定义（DTD）来解析文档。
浏览器本身分为两种模式，<u>一种是标准模式，一种是怪异模式</u>，浏览器通过doctype来区分这两种模式. doctype来声明标准模式，如果不存在就怪异模式，有些样式会和标准模式存在差异.



### 行内元素和块级元素

#### 区别
区别: 一是排列方式，二是宽高边距设置，三是默认宽度。
块级元素会独占一行，而内联元素和内联块元素则会在一行内显示；
块级元素和内联块元素可设置 width、height 属性，而内联元素设置无效；
块级元素的 width 默认为100%，而内联元素则是根据其自身的内容或子元素来决定其宽度；

而行内块级元素又同时拥有块级元素和行内元素的特点。


|                              | `block`                                                     | `inline-block`                             | `inline`                                                     |
| ---------------------------- | ----------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 定位                         | 从新的一行开始，并且不允许旁边有 HTML 元素（除非是`float`） | 与其他内容一起流动，并允许旁边有其他元素。 | 与其他内容一起流动，并允许旁边有其他元素。                   |
| 能否设置`width`和`height`    | 能                                                          | 能                                         | 不能,设置会被忽略                                            |
| 可以使用`vertical-align`对齐 | 不可以                                                      | 可以                                       | 可以                                                         |
| 边距(margin)和填充(padding)  | 各个方向都存在                                              | 各个方向都存在                             | 只有水平方向存在。垂直方向会被忽略。 尽管`border`和`padding`在`content`周围，但垂直方向上的空间取决于'line-height' |
| 浮动（float）                | -                                                           | -                                          | 就像一个`block`元素，可以设置垂直边距和填充                  |





#### 来源
> [CSS中 块级元素、行内元素、行内块元素区别](https://juejin.cn/post/6998925491797229599)
> https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements

#### 行内元素
**是什么**
行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的高度一般由元素内部的字体大小决定，宽度由内容的长度控制。 

**特点**
* 不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化；
* 高/宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效  上下无效；
* 设置行高有效，等同于给父级元素设置行高；
* 元素的宽度就是它包含的文字或图片的宽度，不可改变；
* 行内元素中不能放块级元素，a链接里面不能再放链接；

```sh
结构类: br span
样式类: b big em i strong small a
语义类: abbr acronym code cite dfn kbd label
```

#### 块级元素
**是什么**
占据一整行，可自定义宽度/高度等. 可容纳块级元素和行内元素.
**特点**
* 每个块元素独占一行
* 高度，行高，外边距（margin）以及内边距（padding）都可以控制；
* 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%；
* 多个块状元素标签写在一起，默认排列方式为从上至下
**块元素介绍**
```sh
标题类: h1-h6
结构类: header article aside footer p div
表格类: table thead tbody tr th td tfoot
列表类: dl dt dd / li ol ul
表单类: form
语义类: adress caption(标题) figure,canvas,video,audio
```

**使用js判断元素是否是块级元素**
>https://segmentfault.com/q/1010000003994838

```js
//chatgpt生成: 1.获取元素的display属性; 2.判断元素tagName

window.getComputedStyle(ele).display === 'block'

document.getElementById('myEle').tagName
```


#### 行内块元素
**是什么**
行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如：input、img就是行内块级元素，它可设置高宽以及一行多个

**特点**
* 高度、行高、外边距以及内边距都可以控制；
* 默认宽度就是它本身内容的宽度，不独占一行，但是之间会有空白缝隙，设置它上一级的 font-size 为 0，才会消除间隙；

**元素介绍**
```sh
button input textarea select img
```

#### 元素之间的转换
* display：block ，定义元素为块级元素
* display : inline ，定义元素为行内元素
* display：inline-block，定义元素为行内块级元素





### 标签
为什么最好把 CSS 的`<link>`标签放在`<head></head>`之间？为什么最好把 JS 的`<script>`标签恰好放在`</body>`之前，有例外情况吗？

#### 把`<link>`放在`<head>`中
将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。

#### 把`<script>`标签恰好放在`</body>`之前
脚本在下载和执行期间会阻止 HTML 解析。把`<script>`标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。

例外情况是当你的脚本里包含`document.write()`时。但是现在，`document.write()`不推荐使用。同时，将`<script>`标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，`<script>`使用`defer`属性，放在`<head>`中。



#### defer 与 async区别
html文件都是按顺序执行的，script标签中没有加defer和async时，浏览器在解析文档时遇到script标签就会阻塞文档解析，先加载JS文件，加载完之后立即执行，执行完毕后才能继续解析文档。 

而在script标签中写入defer或者async时，就会使JS文件异步加载，即html执行到script标签时，JS加载和文档解析同时进行，而async是在JS加载完成后立即执行JS脚本，阻塞文档解析，而defer则是JS加载完成后，在文档解析完成后执行JS脚本


#### 渐进式渲染
渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。
使用场景: 带宽小的时代/不稳定的移动互联网场景
案例:
* 图片懒加载
* 分层次渲染: 页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。
* 异步加载 HTML 片段. 当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器


#### img标签中使用srcset属性.
因为需要设计响应式图片。我们可以使用两个新的属性: srcset 和 sizes——来提供更多额外的资源图像和提示，帮助浏览器选择正确的一个资源.
* srcset 定义了我们允许浏览器选择的图像集，以及每个图像的大小。
* sizes 定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。
浏览器处理过程:
* 查看设备宽度
* 检查 sizes 列表中哪个媒体条件是第一个为真
* 查看给予该媒体查询的槽大小
* 加载 srcset 列表中引用的最接近所选的槽大小的图像


#### href 与 src 区别
> https://zhuanlan.zhihu.com/p/91960069


| -    | 是什么                                | 用在哪里              | 浏览器解析方式                                                                                                                | 其它 |
| ---- | ------------------------------------- | --------------------- | ----------------------------------------------------------------------------------------------------------------------------- | ---- |
| href | 表示超文本引用,指向网络资源所在位置   | link/a标签上      | 当浏览器遇到href会并行下载资源并且不会停止对当前文档的处理(同时也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式) | 0    |
| src  | 表示引用资源,目的是把文件下载到页面上 | img/script/iframe | 当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载或执行完毕(这也是script标签为什么放在底部而不是头部的原因)  | 0    |








## CSS
> https://segmentfault.com/a/1190000013325778

### link 与 @import 的区别
就结论而言，强烈建议使用`link`标签，慎用`@import`方式。

> https://segmentfault.com/a/1190000015950516

**区别**
* 从属关系: `@import`是 CSS 提供的语法规则，只有导入样式表的作用；`link`是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。
* 加载顺序: 加载页面时，`link`标签引入的 CSS 被同时加载；`@import`引入的 CSS 将在页面加载完毕后被加载。
* 兼容性: `@import`是CSS2.1才有的语法，故只可在 IE5+ 才能识别；`link`标签不存在兼容性问题。
* DOM可控性: JS可以操作link,不能操作`@import`
* 权重(该项有争议，下文将详解)  `link`引入的样式权重大于`@import`引入的样式。




### 盒模型

#### 是什么?
指网页布局中，每个 HTML 元素都可以看作是一个矩形盒子（box），包括元素的内容区域、内边距（padding）、边框（border）和外边距（margin）四个部分。
页面渲染时，dom 元素所采用的 **布局模型**。可通过`box-sizing`进行设置。根据计算宽高的区域可分为：

- `content-box` (W3C 标准盒模型)
- `border-box` (IE 盒模型)
- `padding-box`
- `margin-box` (浏览器未实现)

#### 作用
通过设置元素的盒模型属性(box-sizing 属性)，可以控制元素的大小、位置和边距，以及元素之间的距离和排列方式。盒模型也是响应式设计和网页布局的基础。

#### 分类
* 标准盒模型
* 替代(IE)盒模型

#### 差异
主要差异在于计算元素宽度和高度时所包含的内容不同。
标准盒模型:元素的宽度和高度只包括内容区域，不包括内边距、边框和外边距。
IE盒模型: 元素的宽度和高度包括了内容区域、内边距和边框，而外边距是在宽度和高度之外计算的。

默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。


#### 切换
默认浏览器会使用标准模型。
替代模型  box-sizing: border-box
标准模型  box-sizing: content-box

#### 实例
所有元素都使用替代模式
设置 box-sizing 在 `<html>` 元素上，然后设置所有元素继承该属性.
```css
html {
  box-sizing: border-box;
}

*, *::before, *::after {
  box-sizing: inherit;
}
```







#### 盒模型内部/外部显示类型
> 了解
>https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#补充：内部和外部显示类型

外部显示类型: 外部显示类型来决定盒子是块级还是内联
内部显示类型: 决定了盒子内部元素是如何布局的, 默认情况下是按照**正常文档流**布局. 可以通过display:flex等方式改变内部显示类型.

### 浮动
#### 浮动问题
由于浮动元素不在文档流中, 浮动元素会漂浮在文档流的块框上。
* 父元素高度无法被撑开,影响与父元素同级的元素
* 与浮动元素同级的非浮动元素（内联元素）会跟随其后
* 若非第一个元素浮动，则该元素之前的元素也需要浮动

#### 清除浮动方法
* 父div定义高度
* 最后添加一个空div,并添加clear:both属性
* 父元素开启BFC,使用overflow值设置为hidden/auto
* 父元素div定义zoom(非标准属性)

#### 其它
* 元素浮动后,display自动变为block





### BFC
#### 定义
BFC块级格式化上下文, 是网页一块CSS渲染区域.它是块级盒子出现或与其它元素浮动交互的区域.


#### 会渲染BFC的元素
>https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context
* document的根元素(`<html>`)
* 浮动(float值不为none)
* 绝对定位元素(元素position值为absolute/fixed)
* 行内块(元素display属性值为inline-block)
* 表格单元(元素display属性为table-cell,默认的HTML表格)
* 表格标题(元素display属性为table-caption,默认的HTML表格)
* 被拥有`display:table`属性隐式创建的匿名table表格
* 带有overflow属性(其值不能为visible/clip)的块元素
* `display:flow-root`
* contain属性值为layout/content/paint的元素
* Flex子元素(属性为display:flex/inline-flex的元素的直接子元素),如果它们本身不是flex或grid或table容器.
* Grid子元素(属性为display:grid/inline-grid的元素的直接子元素),如果它们本身不是flex或grid或table容器.
* 多列容器(元素其column-count/column-width不是auto,column-count不是1)
* column-span:all


#### BFC区域布局规则
1. 内部的Box按垂直方向排列
2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。(是不补偿最左边??)
4. BFC的区域不会与float box重叠。
5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6. 计算BFC的高度时，浮动元素也参与计算

#### BFC应用
* 自适应两列布局
* 高度塌陷-内部浮动父元素高度为0
* 高度塌陷-相邻元素外边距重叠
* 高度塌陷-嵌套元素解决外边距塌陷



### 选择器优先级

#### 选择器
选择器是用来匹配HTML文档中特定元素的模式

#### 分类
##### 基本选择器
* 全局选择器
* 类型选择器
* 类选择器
* ID选择器
* 属性选择器

##### 分组选择器
* 选择器列表

##### 组合选择器
* 后代组合器
* 直接子代组合器
* 一般兄弟组合器
* 相邻兄弟组合器

##### 伪选择器
* 伪类选择器
* 伪元素选择器


#### 优先级
优先级就是CSS声明的一个<u>权重</u>，它由匹配的选择器中的<u>每一种选择器类型</u>的数值决定。

#### 计算优先级
<span style="color:blue">一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：</span>

1. **千位**： 如果声明在 [`style`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style) 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。
2. **百位**： 选择器中包含<u>ID选择器</u>则该位得一分。
3. **十位**： 选择器中包含<u>类选择器、属性选择器、伪类</u>则该位得一分。
4. **个位**：选择器中包含<u>元素、伪元素选择器</u>则该位得一分。

**注**: <span style="color:blue">通配符选择器 (`*`)，组合符 (`+`, `>`, `~`, ' ')，和否定伪类 (`:not`) 不会影响优先级。</span>


### flex弹性布局

#### 是什么?
Flexbox是一种用于布局的CSS3模块，它提供了一种灵活的方式来组织和对齐网页中的元素。通过定义容器和其子项的属性，可以轻松地实现各种布局，如水平和垂直居中、等高列、响应式布局等。


#### 实例
##### 如何实现响应式flex布局
通过使用媒体查询和弹性盒子属性，实现响应式Flex布局，以适应不同的屏幕尺寸。
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Flexbox Responsive Layout</title>
  <style>
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
    }

    .item {
      flex: 1 0 calc(33.333% - 20px);
      margin-bottom: 20px;
      background-color: #ccc;
      text-align: center;
      padding: 10px;
    }

    @media (max-width: 768px) {
      .item {
        flex: 1 0 calc(50% - 20px);
      }
    }

    @media (max-width: 480px) {
      .item {
        flex: 1 0 calc(100% - 20px);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="item">Item 1</div>
    <div class="item">Item 2</div>
    <div class="item">Item 3</div>
    <div class="item">Item 4</div>
    <div class="item">Item 5</div>
    <div class="item">Item 6</div>
  </div>
</body>
</html>
```

##### 等高列
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Equal Height Columns with Flexbox</title>
  <style>
    .container {
      display: flex;
    }

    .column {
      flex: 1;
      padding: 20px;
      background-color: #ccc;
    }

    .column:first-child {
      margin-right: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="column">
      <h2>Column 1</h2>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam malesuada felis vel augue accumsan, at posuere neque tincidunt. Sed pulvinar, nisi in fringilla fringilla, lorem nisl semper purus, vel consequat ipsum nibh vitae libero.</p>
    </div>
    <div class="column">
      <h2>Column 2</h2>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam malesuada felis vel augue accumsan, at posuere neque tincidunt. Sed pulvinar, nisi in fringilla fringilla, lorem nisl semper purus, vel consequat ipsum nibh vitae libero. Proin dictum arcu a libero pulvinar auctor. </p>
      <p>Praesent lobortis erat vel justo finibus, nec ullamcorper quam pretium. Vivamus sed ipsum ligula. Donec lobortis sodales massa eu placerat.</p>
    </div>
  </div>
</body>
</html>
```


#### flex容器6属性及作用
* flex-direction  主轴的方向（即子元素的排列方向）
* flex-wrap 子元素是否需要换行
* flex-flow 上面两项合并写法
* justify-content 子元素在主轴的对齐方式
* align-items 子元素在交叉轴上的对齐方式
* align-content 存在多发轴线时,子元素在交叉轴上的对齐方式

#### flex元素6属性
* order 定义子元素的排列顺序(在主轴上数字越小越靠前)
* flex-grow 元素的放大比例,默认为0.如果为1,则每项元素在空间扩大时等分剩余空间
* flex-shrink 元素的缩小比例,默认为1,空间不足时均等比例缩小.如果为0,则不会随着缩小.
* flex-basis 默认值为auto,表示元素占据主轴空间的原大小.可以设置具体数值
* flex 上面3项的缩写. 
	* `flex:1`表示项目会根据剩余空间按比例方法/缩小.最后值不为auto就不会按本身宽度而均分计算.
	* `flex:none`  等价于`flex:0 0 auto`
	* `flex:100px` 等价于`flex:1 1 100px`，表示项目会根据剩余空间按比例放大，也会按比例缩小，基准长度为100像素.
* align-self 单个元素的对齐方式


### position

#### position属性有那些值
position 属性用于指定一个元素在文档中的定位方式.
position有四个属性值：relative、absolute、fixed、static。三个不常用的：inherit、initial、sticky、unset

不设置Position的值，top，left，right，bottom，不起作用，但是设置了position:static也不会起作用。
通过position属性，我们可以让元素相对于其正常位置，父元素或者浏览器窗口进行偏移。

#### position属性值介绍

##### static
默认值. 不设定position或者设定position:static都不会对这个div（或者别的标签）的布局有影响. top，left，right，bottom不会起作用

##### relative
* 相对定位. 未脱离文档流,基于元素的margin左上角进行偏移,不会影响其它元素的位置
* left和right同时存在，仅left有效;当top和bottom同时存在仅top有效。

##### absolute
* 绝对定位. 元素脱离了文档流,绝对定位元素相对于最近的非static祖先元素定位。
* 当祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）,可以理解为窗口/body元素.

##### fixed
* 固定定位. 以浏览器的窗口为参考点进行定位.
* 当出现滚动条时，对象不会随着滚动，IE6以下不支持该属性。

##### sticky
* 磁贴定位. 
* 像position:relative和position:fixed的合体:

#### 其它

##### 声明为fixed/absolute时
* 该元素将变为块级元素(例子,span设置absolute后,可以设置宽高)
* 如果该元素是块元素且宽度是100%,则宽度变为auto


### css实例

#### 隐藏元素的3种方法
```css
display:none,
visibile:hidden,
opacity:0
```
|                 | 是否隐藏 | 是否在文档中占用空间 | 是否会触发事件 |
| --------------- | -------- | -------------------- | -------------- |
| display: none   | 是       | 否                   | 否             |
| visiblility: hidden | 是       | 是                   | 否             |
| opacity: 0      | 是       | 是                   | 是             |



#### 用css实现瀑布流
利用column-count和break-inside这两个CSS3属性即可

<iframe src="https://codesandbox.io/embed/staging-frog-598uwu?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="css3 瀑布流"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
   


#### 有什么不同的方式可以隐藏内容？
> https://www.frontendinterviewhandbook.com/zh/css-questions#有什么不同的方式可以隐藏内容使其仅适用于屏幕阅读器'
> 注意,链接提供的方法中涉及的Metadata格式化规范方法, WAI-ARIA规范和隐藏元素不太相关.

* display: none;：这是最常见的一种隐藏元素的方法。该属性可以完全从页面中删除元素，并在布局中不占用空间。然而，这种方法会将元素完全从文档流中删除，包括任何子元素和事件监听器。

* visibility: hidden;：这种方法与 display: none; 类似，但元素仍会占用布局空间。元素仍保留在文档流中，但对用户不可见，并且不会响应事件。

* opacity: 0;：该属性将元素的不透明度设置为 0，使元素在页面上不可见，但仍会保留在文档流中并响应事件。

* position: absolute;：将元素的 position 属性设置为absolute，可以将其从文档流中移除并相对于其最近的定位祖先进行定位。可以通过将 left 或 top 属性设置为负值来将元素移出视图区域。

* clip-path: polygon(0 0, 0 0, 0 0, 0 0);：该属性可以将元素裁剪成一个多边形，通过将其所有点的坐标设置为相同的值（例如，0），可以将元素完全裁剪并隐藏。

* height: 0; width: 0; overflow: hidden;：该属性将元素的高度和宽度设置为 0，并将其 overflow 属性设置为 hidden，以将其内容隐藏在元素内部。

* transform: scale(0);：该属性将元素缩放为 0，使其在页面上不可见，但仍会保留在文档流中并响应事件。


#### 编写高效的 CSS 应该注意什么？

浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。

选择器匹配语句链越短，浏览器的匹配速度越快。

避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。

原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。

搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。



#### div水平垂直居中的5种方法
* flex
* absolute+left/top+margin
* absolute+left/top+transform
* absolute+(left/right/top/bottom) + margin
* tabel-cell + vertical-align

<iframe src="https://codesandbox.io/embed/layout-divchui-zhi-ju-zhong-de-ji-zhong-fang-fa-k5np45?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="layout-div垂直居中的几种方法"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>






#### css水平、垂直居中的写法，请至少写出4种？

*水平居中*
- 行内元素: `text-align: center`
- 块级元素: `margin: 0 auto`
- position:absolute +left:50%+ transform:translateX(-50%)
- `display:flex + justify-content: center`

*垂直居中*
- 设置line-height 等于height
- position：absolute +top:50%+ transform:translateY(-50%)
- `display:flex + align-items: center`
- display:table+display:table-cell + vertical-align: middle;




#### 单行文本溢出
```css
overflow: hidden;
white-space: nowrap;
text-overflow: ellipsis;
```

#### 多行文本溢出
```css
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2; // 最多显示几行
-webkit-box-orient: vertical;
```



#### 画三角形
* border
* border+transform
* 伪元素
* linear-gradient
* clip-path
* svg
<iframe src="https://codesandbox.io/embed/san-jiao-xing-3mqln7?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="三角形"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>



#### inline-block元素间间距问题
> [去除inline-block元素间间距的N种方法 « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-去除间距/)

- 移除空格
- 使用margin负值
- 使用font-size:0
- letter-spacing
- word-spacing


#### 布局案例
##### 左侧固定右侧自适应
<iframe src="https://codesandbox.io/embed/bu-ju-zuo-ce-gu-ding-you-ce-zi-gua-ying-ez6btk?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="布局-左侧固定右侧自适应"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>




##### 圣杯布局
<iframe src="https://codesandbox.io/embed/bu-ju-sheng-bei-bu-ju-yt3zf5?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="布局-圣杯布局"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>



##### 双飞翼布局
<iframe src="https://codesandbox.io/embed/bu-ju-shuang-fei-yi-bu-ju-fnjxv4?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="布局-双飞翼布局"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>


#### 单行/多行文本居中
使用line-height实现
<iframe src="https://codesandbox.io/embed/wen-ben-chu-li-wc1nq3?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="文本处理"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>




### CSS 预处理器 //?

CSS 预处理器的原理: 是将类 CSS 语言通过 **Webpack 编译** 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能:

- 嵌套
- 变量
- 循环语句
- 条件语句
- 自动前缀
- 单位转换
- mixin 复用

```js
//less
0.嵌套 &代表当前选择器的父级.使用嵌套（nesting）代替层叠或与层叠结合使用

1.变量声明 @+变量名称=值
2.使用变量 
 2.1作为属性值
 2.2作为属性名 @{变量名称}
 2.3作为选择器 #@{变量名称} @{#变量名称}
 2.4


3.循环语句
4.条件语句

5.自动前缀




7.混入mixin
混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。
```


### 响应式设计

#### 是什么
一个网站能够兼容多个终端

#### 实现方法
通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。
```html
<meta name=’viewport’ content=”width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no”>
```






## JavaScript

### var/const/let的区别
- const定义常量, let/var定义变量
- const和let相对于var
  - 有块作用域
  - 没有变量提升
  - 不会添加到window上
  - 不能重复声明

### 声明变量的6种方式
>https://github.com/Easay/issuesSets/issues/113
* var
* let
* const
* function
* import
* class
#### 代码示例
代码1
```js
 function fun(str){
  let str = 'hello'+'world!';
  console.log(str);
}
fun('123');
```
结果：运行后是一个语法错误：Uncaught SyntaxError：Identifier 'code' has already been declared

代码二
```js
var str = 'hello';

function fun(){
  console.log(str);
  let str = 'world';
  console.log(str);
}
fun();
```
结果：只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响，这也就是传说中的 暂时性死区，ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错，所以上面是一段错误代码：Uncaught ReferenceError: Cannot access 'str' before initialization。

代码三
```js
const obj = {};
let str = '坚持一周写两篇博客';
let addObj = obj.names = str;

console.log(addObj); //坚持一周写两篇博客
console.log(obj);{names:"坚持一周写两篇博客"}
```

const需要注意：
* 只声明不赋值，会报错；
* 只在声明所在的块级作用域内有效；
* const命令声明的常量不提升，存在暂时性死区；
* 不可重复声明；
* 冻结对象，可以使用Object.freeze方法


**function**
ES6规定：
允许在块级作用域内声明函数。
函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
同时，函数声明还会提升到所在的块级作用域的头部。
上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。

// 浏览器的 ES6 环境
```js
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
```
**import**
import用于加载文件，在大括号接收的是一个或多个变量名，这些变量名需要与想要导入的变量名相同。

🌰：导入action.js文件中的某一个变量，这个变量里保存了一段代码块，所以要写成：import { Button } from 'action'，这个时候，就从action.js中获取到了一个叫 Button 的变量。

如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名，比如：
```js
import { NewButton as Button } from 'action.js';
```

**class**
```js
class Interest {
	constructor( x, y, e, z ){
		this.x = x;
		this.y = y;
		this.e = e;
		this.z = z;
	}

	MyInterest(){
		let arr = [];
		console.log(`我会${[...arr,this.x,this.y,this.e,this.z]}!`);
	}
}

let GetInterest = new Interest('唱','跳','rap','篮球');
console.log(GetInterest.MyInterest());  //我会唱,跳,rap,篮球!
```



### **执行上下文**

#### 是什么
当 JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

每个执行上下文都有3个属性:
* 变量对象(Variable object，VO)
* 作用域链(Scope chain)
* this

### 执行上下文栈

#### 定义

执行上下文栈（Execution context stack，ECS）来管理执行上下文
当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。


### 变量对象
#### 是什么
变量对象是与执行上下文相关的<span style="color:red">数据作用域</span>，存储了在上下文中定义的变量和函数声明。
全局上下文中的变量对象就是全局对象
函数上下文中的变量对象(活动对象)是进入函数上下文时被创建的

#### 变量对象的组成
执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：
1. 进入执行上下文
2. 代码执行
当进入执行上下文时，这时候还没有执行代码，
变量对象会包括：
1. 函数的所有形参 (如果是函数上下文)
   - 创建由名称和对应值组成的一个变量对象的属性
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 创建由名称和对应值（函数对象(function-object)）组成一个变量对象的属性
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 创建由名称和对应值（undefined）组成一个变量对象的属性
   - <span style="color:blue">如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</span>

#### 变量对象实例
```javascript
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：
```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```

代码执行:
在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值
还是上面的例子，当代码执行完后，这时候的 AO 是：
```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```


### 作用域
#### 产生的背景
将变量引入程序带来的问题: 变量存储在哪里? 程序需要的时候如何找到它们?
#### 是什么
存储变量和查找变量的规则.

#### 变量查找案例 (`var a = 2`)

以`var a = 2`为例:
* 首先, 编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。
* 遇到`var a`，<span style="color:blue;">编译器会询问作用域</span>是否在同作用域集合中存在同名变量
  * 是 编译器会忽略该声明，继续进行编译；
  * 否 它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a
* 编译器为引擎运行生成所需的代码,用来处理a=2这个赋值操作.<span style="color:blue;">引擎运行时会首先询问作用域</span>，在当前的作用域集合中是否存在一个叫作`a`的变量。
  * 是, 引擎就会使用这个变量
  * 否, 引擎会继续查找该变量
    * 找到, 就会将2赋值给它;
    * 没找到, 引擎就会举手示意并抛出一个异常 ?!!

#### 引擎查找变量两套规则

查找变量的两种查询方式:
- LHS查询  “赋值操作的目标是谁（LHS） 一般出现在赋值操作的左侧
- RHS查询  “谁是赋值操作的源头（RHS）”  一般出现在赋值操作的右侧

#### 查询未声明变量的处理过程
在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。具体表现如下:
- RHS查询遍寻不到所需的变量,引擎会抛出`ReferenceError`异常
- LHS查询遍寻不到所需变量,
  - 非严格模式: 全局作用域会创建一个具有该名称的变量,并返还给引擎(非'严格模式'下)
  - 严格模式: 抛出同RHS查询失败时类似的`ReferenceError`异常
- RHS查询找到一个变量,但对变量进行不合理操作(例如,对函数类型进行调用,引用null/undefined值中的属性), 引擎抛出`TypeError`.

> `ReferenceError` 同作用域判别失败相关
> `TypeError` 代表作用域判别成功了，但是对结果的操作是不合法的



#### 编程语言中作用域的类型

作用域共有两种主要的工作模型。
- 词法作用域: 最为普遍的，被大多数编程语言所采用的。<span style="color:blue;">词法作用域就是定义在词法阶段的作用域</span>。
- 动态作用域，仍有一些编程语言在使用（比如Bash脚本、Perl中的一些模式等）


#### JS中的作用域类型
* 全局作用域
* 函数作用域
* 块作用域

#### JS函数作用域的特点

> 在某个位置独立调用,将会局部提升

* 函数的作用域由函数的<u>定义位置决定</u>,和函数的调用位置无关
* 函数作用域在函数调用时<u>创建</u>，在调用结束时<u>销毁</u>  
* 函数每次调用都会产生一个<u>新的</u>函数作用域，函数作用域之间<u>相互独立</u>
* 在函数作用域中声明的变量是<u>局部变量</u>,只能在函数内部访问; 省略var或let，则变量默认会成为<u>全局</u>变量(不希望出现的情况)
* 在函数内部，使用var声明的变量和使用function开头的函数也会被<u>提升</u>



#### JS中的块作用域有哪些?

<u>with</u>

用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。

<u>try...catch</u>

其中声明的变量仅在catch内部有效

<u>let</u>

let关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说，let为其声明的变量<span style="color:blue;">隐式地劫持了所在的块作用域</span>


#### JS块作用域的实例

1.作用域作用-垃圾回收

让引擎清楚地知道没有必要继续保存某些数据

```javascript
function process(data) {
  //...
}
{ //在这个块中定义的内容完事可以销毁
	var someReallyBigData = {};
	process(someReallyBigData);
}

//
```

<u>2.let循环</u>

<span style="color:blue">for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</span>

下面通过另一种方式来说明每次迭代时进行重新绑定的行为：

```javascript
{
  let j;
  for (j=0; j<10; j++) {
    let i=j; //每个迭代重新绑定
    console.log(i);
  }
}

//说明了几件事情?
//1. for循环内存在块作用域
//2. let声明的变量会绑定到循环的每一次迭代中
```

<u>3.创建块作用域变量</u>

可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。





#### 作用域的使用
> 基于作用域隐藏变量和函数


#### 作用域嵌套

是什么?
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。

查找规则?
引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。



#### 作用域链

定义
由多个执行上下文的<u>变量对象</u>构成的链表叫做作用域链. 当查找变量时,会,就会,全局....


### 函数
#### 函数声明和函数表达式区别
* 以函数声明的方法定义的函数,函数名是必须的,而函数表达式的函数名是可选的。（函数声明整体会被提升到当前作用域的顶部，函数表达式也提升到顶部但是只有其变量名提升）
* 以函数声明的方法定义的函数,函数可以在函数声明之前调用,而函数表达式的函数只能在声明之后调用。

* 以函数声明的方法定义的函数并不是真正的声明,它们仅仅可以出现在全局中,或者嵌套在其他的函数中,但是它们不能出现在循环,条件或者try/catch/finally中,而函数表达式可以在任何地方声明。换句话说，函数声明不是一个完整的语句，所以不能出现在if-else,for循环，finally，try catch语句以及with语句中。


### 闭包
![image](https://cdn.staticaly.com/gh/aotushi/image-hosting@master/documentation/image.7g1aiggs0g00.webp)
#### 定义
一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。
也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。
简单来说,有权访问另一个函数作用域变量的函数.

#### 形成原因
存在上级作用域的引用


#### 如何创建
- 嵌套的内部函数引用了外部函数的变量, 当调用外部函数并执行返回的内部函数

#### 闭包作用
- 保护函数的私有变量不受外部干扰
- 形成不被销毁的栈内存
- 将上级作用域的引用保存下来,实现方法或属性的私有化

#### 缺点
* 内存泄露: 程序申请了内存,但没有及时释放,导致内存空间被浪费
* 内存溢出: 程序申请的内存超过系统提供的上限,导致无法分配内存.

#### 使用场景
闭包使用场景包括: 使用return返回函数; 函数作为参数; IIFE; 定时器setTimeout; 所有的回调函数.

1.回调
闭包有用之处在于它可以将一些数据和操作它的函数关联起来。这和面向对象编程明显相似。在面对象编程中，我们可以将某些数据（对象的属性）与一个或者多个方法相关联。(在<span style="color:red">定时器, 事件监听器,Ajax请求,跨窗口通信,Web Works或者其他的异步(或同步)任务</span>中,<span style="color:blue;"> 只要使用了回调函数,实际上就是在使用闭包.</span>)
因此，当你想只用一个方法操作一个对象时，可以使用闭包。

2.模拟私有方法
私有方法不仅可以限制代码的访问权限，还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口。


#### 闭包实例

##### 简述函数执行过程
```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```

简要复述其执行过程:

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2. 全局执行上下文初始化
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
4. checkscope 执行上下文初始化，创建变量对象、作用域链、this等
5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
7. f 执行上下文初始化，创建变量对象、作用域链、this等
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

问题:

当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

<span style="color:red"> f 执行上下文维护了一个作用域链</span>：



##### 实现一个只能执行3次的函数
有一个函数，参数是一个函数，返回值也是一个函数，返回的函数功能和入参的函数相似，但这个函数只能执行3次，再次执行无效，如何实现

```javascript
function sayHi() {
    console.log('hi')
}

function threeTimes(fn) {
    let times = 0
    return () => {
        if (times++ < 3) {
            fn()
        }
    }
}

const newFn = threeTimes(sayHi)
newFn()
newFn()
newFn()
newFn()
newFn() // 后面两次执行都无任何反应
```



##### 实现add函数,让add(a)(b)和add(a,b)两种调用结果相同

```javascript
function add(a, b) {
  if (b === undefined) {
    return function(x) {
       return a + x
    }
  }
  
  return a + b
}
```


#### 闭包面试题

1.for循环
```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0](); //输出3
data[1](); //输出3
data[2](); //输出3
```

如何改造:
* 立即执行函数
* 使用let
```js
var data = []
for (var i=0; i<3; i++) {
	//data[i] = (function() {console.log(i)})(i) 错误
	data[i] = (function(j){console.log(j)})(i)
}


//let
var data = []
for (let i=0; i<3; i++) {
	console.log(i)
}
```



#### 其它
##### IIFE是闭包吗?

```javascript
var a = 2;
(function IIFE() {
  console.log(a);
})();
```

以上代码并不是严格的闭包:
* 因为函数（示例代码中的IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行
* a是通过普通的词法作用域查找而非闭包被发现的。


##### 循环和闭包
```javascript
for (var i=1; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i*1000)
}
```

延迟函数的回调会在循环结束时才执行. 即使每个迭代中执行的setTimeout(..., 0), 所有的回调函数依然是在循环结束后才被执行.

**代码的问题:**

我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。<u>但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。</u>

解决:

IIFE解决方案:
```javascript
//正确代码
for (var i=1; i<=5; i++) {
  (function() {
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j*1000)
  })()
}
//改进
for (var i=1; i<=5; i++) {
  (function() {
    setTimeout(function timer() {
      console.log(i);
    }, i*1000)
  })(i);
}
```

使用let代替IIFE
使用let声明来代替IIFE创建新的作用域
```javascript
for (var i=1; i<=5; i++) {
  let j=i; //闭包的块作用域
  setTimeout(function timer() {
    console.log(j);
  }, j*1000);
}
```



##### 模块
通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。
* 接收参数
* 命名将要作为公共API返回的对象

```javascript
var foo = (function CoolModule(id) {
  function change() {
    //修改公共API
    publicAPI.identify = identify2;
  }
  
  function identify1() {
    console.log(id);
  }
  
  function identify2() {
    console.log(id.toUpperCase());
  }
  
  var publicAPI = {
    change: change,
    identify: identify1
  };
  
  return publicAPI;
})('foo module');

foo.identify(); //'foo module'
foo.change();
foo.identify(); //'FOO MODULE'
```

其他后续内容, 笔记中记录的比较详细, 面试就说到这里吧

### this

#### 介绍
* 执行上下文的一个属性
* 是在运行时进行绑定的,和函数声明的位置无关.

#### 使用原因
* 显式传递上下文对象会让代码越来越混乱
* 调用函数时候不用传递上下文对象, this隐式传递一个对象引用,API简洁易于复用

#### 绑定规则
* 默认绑定
  * 非严格模式下,函数直接调用,this绑定到window/globalThis; 严格模式下,this是undefined
* 隐式绑定
  * 调用位置上是否有上下文对象或者说是否被某个对象拥有或包含.(注意: 函数不属于对象,从作用域上来解释)
  * 规则:
    * 当函数引用有上下文对象时,隐式规则会把这个函数调用中的this绑定到这个上下文对象
    * <span style="color:red">对象属性引用链中只有最后一层在调用位置中起作用</span>
  * 存在的问题: 隐式丢失
    * 丢失绑定对象,会应用默认绑定.
  * 隐式丢失 几种情况
    * 将`对象.方法`赋值给变量,调用这个变量
    * 参数传递, 将函数是通过参数传递进函数
    * 把函数传入语言内置的函数
  * 隐式绑定存在问题
    * 隐式丢失中,无法控制回调函数的执行方式,也就无法控制调用位置以得到期望的值
    * 如何解决？ 固定this

* 显式绑定
  * 不想在对象内部包含函数引用，而想在某个对象上强制调用函数。  使用call/apply/bind
  * 如果call/apply第一个参数传入原始值？？
    * 装箱  基本类型转成它的对象形式
  * 显示绑定存在的问题（理解）
    * 虽然call和apply可以在任意地方调用,但是它是直接进行调用送的.设想,如果在某个第三方库中,其异步的回调函数需要改变this,如果这个时候使用call/apply会立即调用并更改this,异步在不知道完成与否的情况下,异步回调直接运行了.
* new绑定

使用new来调用函数,或者说发生构造函数调用时,会自动执行下面的操作:
1. 内存中新建一个对象
2. 将新建对象的隐式原型[[prototype]]指针赋值为构造函数的原型prototype
3. 这个新对象会绑定到函数调用的this
4. 如果函数返回非空对象,则返回;否则,返回新建对象.
```js
//隐式绑定丢失
//把函数传如语言内置的函数
function foo() {
  console.log(this.a)
}

var obj = {
  a:2,
  foo: foo
}

var a = 'oops, global!'
setTimeout(obj.foo, 100); //'oops, global'
//js内置的setTimeout函数和下面的伪代码类似
functionsetTimeout(fn, delay) {
  //delay
  fn()
}
```

```js
// new绑定

const newFn = () => {
	let obj = {}
	let fn = arguments[0]
	let args = [].slice.call(arguments, 1)
	obj.__proto__ = fn.prototype
	let res = fn.call(obj, args)
	return typeof res === 'object' ? res : obj
}
```

### this在不同场景下的取值?

- 常规情况下, 函数中的this取决于执行函数的方式
  - fn(): 直接调用  ==> **this是?**  window
  - new fn(): new调用 ==> **this是?**  新建的对象
  - obj.fn(): 通过对象调用 ==> **this是?**  obj
  - fn.call/apply(obj): 通过函数对象的call/apply来调用 ==> **this是?**  obj

- 特殊情况:
  - bind(obj)返回的函数  ==> **this是?**  obj
  - 箭头函数 ==> **this是?**  外部作用域的this
  - 回调函数
    - 定时器/ajax/promise/数组遍历相关方法回调  ==> **this是?**  window 或 当前的事件源
    - vue控制的回调函数  ==> **this是?**  组件的实例
    - React控制的生命周期回调, 事件监听回调  ==>  **this是?**  组件对象 / undefined

- 如何控制函数的this?  
  - 利用函数的bind()
  - 利用箭头函数
  - 也可以用外部保存了this的变量



### 原型链
#### 是什么
由相互关联的原型组成的<span style="color: blue">链状结构</span>

#### 原型对象
##### 定义
每一个JavaScript对象(null除外)在创建的时候就会<u>与之关联另一个对象</u>，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。

#### 原型链查找规则概述
- 当我们要获取一个对象的属性时,浏览器会先在对象自身中寻找
- 如果有则直接使用,如果没有则去对象的原型中寻找
- 找到了则使用,没有则去原型的原型里去寻找.以此类推, 直到找到Object的原型,如果依然没有找到则返回undefined
- Object的原型是所有对象的原型,它的原型没有原型

#### 原型链图例

![chian prototype](https://programmer.help/images/blog/d59acf5d5aca9dad1461354443dd7c17.jpg)








### 继承
#### **原型链继承**
> 子类原型 = 父类实例

缺点: 
 1.引用类型的属性被所有实例共享.(基本类型的值更改后不会被共享, 因为其他实例初始化后,)
 2.子类不能向父类中传参

#### **借用构造函数继承**
> 在子类构造函数中,通过call()/apply()调用父类构造函数

优点:
* 避免原型链继承中引用类型的属性被所有实例共享
* 可以在子类中向父类传参

缺点:
* 方法都在父类构造函数中定义,每次创建实例都会创建一遍方法
* 只能继承父类的实例属性和方法,不能继承其原型的属性/方法

#### 组合继承
> 原型继承 + 借用构造函数继承

优点: 融合原型链继承和构造函数的优点
缺点: 会调用两次父类的构造函数: 一次在子类的构造函数中call方法执行了一遍; 一次在在子类原型实例化为父类的实例时执行了一遍
```js
//方式一: 基于构造函数的继承: 原型链 + 借用构造函数的组合式继承
- 借用父类型构造函数: Person.call(this, name, age)
- 让子类的原型为父类的实例: Student.prototype = new Person()
- 让子类型原型的构造构造函数为子类型: Student.prototype.constructor = Student

// 父类型
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.fn = function () { console.log('aaa')}
Person.prototype.sayHello = function () {
  console.log(`我叫{this.name},年龄{this.$age}`);
}

// 子类型
function Student(name, age, price) {
  Person.call(this, name, age);
  this.price = price;
}
// 让子类原型为父类的实例
Student.prototype = new Person();
// 让原型对象的构造器为子类型
Student.prototype.constructor = Student;

Student.prototype.sayHello = function () {
  console.log(`名字${this.name},年龄${this.age},身价${this.price}`);
}

const s = new Student('tom', 12, 100)
s.sayHello();
s.fn();

//方式二: 基于class/类的继承
- 子类 extends 父类: class Teacher extends Person2
- 子类构造器中调用父类的构造: super(name, age)
 

class Teacher extends Person2 {
    constructor (name, age, course) {
      super(name, age)
      this.course = course
      Teacher.prototype.count++
    }
```



#### 原型式继承

> 将传入的对象赋值给临时构造函数的原型，然后返回这个临时构造函数的一个实例。
> 本质上，是对传入的对象执行了一次浅复制.

```javascript
function object(o) {
  function F()
  F.prototype = o
  return new F()
}
```

缺点:
跟原型链继承一样., 包含引用类型的属性值始终都会被所有实例共享

#### 寄生式继承

> 创建一个仅用于封装继承过程的函数,该函数在内部来增强对象(例如添加方法),最后返回对象
```javascript
function createObj(o) {
  let clone = Object.create(o)
  clone.sayName = function() {
    console.log('hi')
  }
  
  return clone;
}
```

缺点: 
跟借用构造函数模式一样,每次创建对象都会创建一遍方法


#### 寄生组合式继承

> 原型继承 + 借用父类构造函数 + 原型

组合式继承的最大缺点是会调用两次父构造函数. 一次是设置子类型实例的原型时;一次是创建子类实例时.
如何避免在子类构造函数中的重复调用呢?

```javascript
function Parent(name) {
  this.name = name;
  this.corlors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  console.log(this.name);
}

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

//关键步骤
function F() {}
F.prototype = Parent.prototype;
Child.prototype = new F();

let child1 = new Child('kevi', '18');
```

封装下这个方法
```javascript
function object(o) {
  function F() {};
  F.prototype = o;
  return new F();
}

function prototype(child, parent) {
  let prototype = object(parent.prototype);
  prototype.constructor = child;
  child.prototype = prototype;
}
```

> 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。


### 深拷贝与浅拷贝



### 面向对象的3特征
- 封装:
  - 将可复用的代码用一个结构包装起来, 后面可以反复使用
  - js的哪些语法体现了封装性: 函数 ==> 对象 ==> 模块 ==> 组件 ==> 库
  - 封装都要有个特点: 不需要外部看到的必须隐藏起来, 只向外部暴露想让外部使用的功能或数据
- 继承
  - 为什么要有继承? 复用代码, 从而减少编码
  - js中的继承都是基于原型的继承: ES6的类本质也是
  - 编码实现: 原型链+借用构造函数的组合 / ES6的类继承
- 多态: 多种形态
  - 理解
    - 声明时指定一个类型对象, 并调用其方法,
    - 实际使用时可以指定任意子类型对象, 运行的方法就是当前子类型对象的方法
  - JS中有多态:
    - 由于JS是弱类型语言, 在声明时都不用指定类型
    - 在使用时可以指定任意类型的数据 ==> 这已经就是多态的体现了





### 防抖节流原理及应用

#### 使用背景
如果是复杂的回调函数或是 ajax 请求呢? 假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。出现防抖和节流两种方案.

(高频操作导致一定时间内不能实现函数的全部功能,进而导致卡顿)

#### 应用场景
函数防抖:连续的事件,只需触发一次回调场景:搜索框输入,只能用户最后一次输入完,再发请求;浏览器窗口大小变化
函数节流:间隔一段事件执行一次的场景:滚动加载;高频点击提交,表单的重复提交; 多级分类列表


#### 防抖原理
* 在事件<span style="color:red">触发 n 秒后才执行</span>;
* 如果你在一个事件触发的 n 秒内又触发了这个事件，以新的事件的时间为准，n 秒后才执行.
```javascript
function debounce(fn, wait) {
  let timeId
  return function() {
    clearTimeout(timeId)
    timeId = setTimeout(fn, wait)
  }
}

//2 version  修复this 与 事件对象传递
function debounce2(fn, wait) {
  let timeId
  return function() {
    if (timeId) clearTimeout(timeId)
    let thisArg = this
    let args = arguments
    timeId = setTimeout(() => fn.apply(thisArg, args), wait)
  }
}

//3 version 立即执行  
function debounce3(fn, wait, immediate) {
  let timeId
  return function() {
    let thisArg = this, args = arguments
    
    if (timeId) clearTimeout(timeId)
   	
    if (immediate) {  //这个立方总是理解不好
      let callNow = !timeId
      timeId = setTimeout(() => {timeId = null} , wait)
      if (callNow) fn.apply(thisArg, args)
    } else {
      timeId = setTimeout(() => {fn.apply(thisArg, args)}, wait)
    }
  }
}


//其他
/* 
实现函数防抖的函数
*/
function debounce(callback, delay) {
  return function (event) {
    console.log('debounce 事件...')
    
    // 清除待执行的定时器任务
    if (callback.timeoutId) {
      clearTimeout(callback.timeoutId)
    }
    // 每隔delay的时间, 启动一个新的延迟定时器, 去准备调用callback
    callback.timeoutId = setTimeout(() => {
      callback.call(this, event)
      // 如果定时器回调执行了, 删除标记
      delete callback.timeoutId
    }, delay)
  }
}



//使用案例
<span>节流input表单:</span><input id="inputNode" />
    
let inputNode = document.getElementById('inputNode');
function ajax(content){console.log('ajax request'+content)};

function debounce(callback,delay){
    //n秒内又触发,则会重新计时
    if(callback.timeoutId){ 
        clearTimeout(callback.timeoutId)
    }
    callback.timeoutId = setTimeout(()=>{
        callback(event);
        //callback.call(this,event)
        delete callback.timeoutId;
    },delay);  
}

let debounceAjax = debounce(ajax, 3000);
inputNode.addEventListener('keyup',function(e){
    debounceAjax(e.target.value)
})
```



#### 节流原理
<span style="color:red">每隔一段时间只执行一次事件</span>。
节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。
```js
//时间戳
function throttle(fn, wait) {
  let ctx, args;
  let start = 0
  return function() {
    let now = +new Date()
    ctx = this
    args = arguments
    
    if (now - start > wait) {
      fn.apply(ctx, args)
      start = now
    }
  }
}
//定时器
function throttle(fn, wait) {
  let timeId, start = 0
  return function() {
    let thisArg = this
    let args = arguments
    
    if (!timeId) {
      timeId = setTimeout(() => {
        timeId = null
        fn.apply(thisArg, args)
      }, wait)
    }
  }
}

//比较两个方法：

//1. 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行
//2. 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件

//时间戳 + 定时器方案


/* 
实现函数节流的函数
*/

function throttle(callback, delay) {
  let start = 0 // 必须保存第一次点击立即调用
  return function (event) { // 事件回调函数
      // this是发生事件的dom元素
    console.log('throttle 事件')
    const current = Date.now()
    if (current - start > delay) { // 从第2次点击开始, 需要间隔时间超过delay
      callback.call(this, event)
      // 将当前时间指定为start, ==> 为后面的比较做准备
      start = current
    }
  }
}

<span>节流input表单:</span><input id="inputNode" />
    
let inputNode = document.getElementById('inputNode');
function ajax(content){console.log('ajax request'+content)}

function throttle(callback,delay){
    let start = 0;
    return function(event){
        let current = Date.now();
        if(current-start>delay){
            callback.call(this,event);  //用不用call, 不用
            start = current;
        }
    }
}

let throttleAjax = throttle(ajax,2000);
inputNode.addEventListener('keyup', function(e){
    throttleAjax(e.target.value)
})

```



### 白屏时间
白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。

Performance 接口可以获取到当前页面中与性能相关的信息,该类型的对象可以通过调用只读属性 Window.performance 来获得。

performance.timing.navigationStart: PerformanceTiming.navigationStart 是一个返回代表一个时刻的 unsigned long long 型只读属性，为紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。

所以将以下脚本放在 `</head>` 前面就能获取白屏时间。

```html
<script>
	new Date() - performance.timing.navigationStart
</script>
```



### 模块化

ES6模块的暴露和引入语法

暴露: 分别暴露, 暴露对象, 默认暴露

```javascript
// 分别暴露
export const a = 'a'
export const b = 'b'

//暴露对象
const c = 'c'
const d = 'd'
export {
	c,
  d as dd
}

//默认暴露
export default function foo() {}

```

引入: 通用引入; 解构赋值形式引入; 简便导入

```javascript
import * as m1from './m1'

//解构赋值形式引入
import {default as aaa} from 'xx.js'

//简便导入
import _ from 'lodash'
```







### 异步

#### 事件循环
事件循环是JavaScript的一种机制，它可以让JavaScript在单线程的情况下，同时处理同步代码和异步代码，通过不断地检查一个消息队列，来决定何时执行哪个函数

#### 背景
为什么JavaScript需要事件循环呢？因为JavaScript是一种单线程的语言，也就是说它一次只能执行一个任务。如果遇到了耗时的操作，比如网络请求或定时器，那么整个程序就会被阻塞，无法响应用户的交互。
**为了解决这个阻塞问题**，JavaScript采用了异步编程的方式，将耗时的操作交给浏览器或Node.js等环境去处理，而自己继续执行后面的代码。
**当耗时的操作完成后**，它们会产生一个消息（message），并放入一个消息队列（message queue）中等待被处理。
**那么什么时候处理这些消息呢**？这就需要事件循环来协调。简单地说，事件循环就是不断地检查消息队列中是否有待处理的消息，如果有，就取出消息并调用相应的函数来处理它。每个消息都会完整地处理完毕，然后再处理下一个消息。这样可以保证函数运行时不会被打断或干扰

下图是描述事件循环:
![](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg)

图中的stack表示函数调用栈（call stack），heap表示对象分配的内存区域（heap），queue表示消息队列（message queue）
* 函数调用栈是用来存储当前正在执行或等待执行的函数调用信息（比如参数、返回地址、局部变量等）的数据结构。每当有一个新的函数调用发生时，就会创建一个新的帧（frame）并压入栈顶；每当有一个函数返回时，就会弹出栈顶的帧并恢复之前的执行状态。
* 堆是用来存储对象（object）和其他复杂数据类型（比如数组、字符串等）分配空间和引用关系
* 消息队列是用来存储异步操作产生

#### 宏任务和微任务

##### 概述
* 宏任务和微任务是两种不同类型的异步任务
* 宏任务和微任务的执行顺序是：
	* 从宏队列中取出第一个宏任务（一般是script整体代码）执行，直到完成。
	* 检查微队列，如果有微任务，就依次执行所有的微任务，直到清空或者达到最大限制（浏览器不同）
	* 执行UI渲染，更新界面。
	* 重复以上步骤，从宏队列中取出下一个宏任务执行，然后再检查微队列，以此类推。
* 宏任务一般会在每次tick的开始或者结束时执行，而微任务一般会在每次tick中的同步代码执行完毕后立即执行。因此，微任务相比宏任务会更快地得到执行。


#### 组成
**宏任务**
script (整体代码)
setTimeout/setInterval
UI rendering/UI事件
postMessage，MessageChannel
setImmediate，I/O（Node.js 环境）

**微任务：**
`Promise.then/catch/finally`
async/await
MutationObserver
process.nextTick（Node.js 环境）

#### 实例
```js
setTimeout(() => {
    console.log("0")
  }, 0)
  new Promise((resolve,reject)=>{
    console.log("1")
    resolve()
  }).then(()=>{        
    console.log("2")
    new Promise((resolve,reject)=>{
      console.log("3")
      resolve()
    }).then(()=>{      
      console.log("4")
    }).then(()=>{       
      console.log("5")
    })
  }).then(()=>{  
    console.log("6")
  })

  new Promise((resolve,reject)=>{
    console.log("7")
    resolve()
  }).then(()=>{         
    console.log("8")
  })
```


#### 异步加载JS脚本的方法
>https://github.com/Easay/issuesSets/issues/122

**方法一：给script标签添加defer属性**
添加了defer属性，js脚本会异步加载，但会等到html解析完成后，在window.onload事件之前执行。
添加了defer属性的js文件执行的顺序和在文档中定义的顺序一样。
```html
<script src="../your_file.js" defer></script>
```
**方法二：给script标签添加async属性**
async属性会让js并行下载，但是js文件下载完成之后立刻执行无论html是否解析完毕
添加了async属性的js文件执行顺序不能保证
```js
<script src="../your_file.js" async></script>
```
**方法三：动态添加script标签**
和img标签不一样，设置了script的src属性并不会开始下载，而是要添加到文档中Js文件才会开始下载
```js
let script = document.createElement('script');
script.type = 'text/javascript';
script.src = 'your_file.js';
// 只有添加到html文件中才会开始下载
document.body.append(script);
```
问题⚠️：异步加载script的目的是不对html的渲染造成阻塞，如果脚本中有操作dom的行为，则不能进行。但动态添加script标签需要获取body，所以该script代码段放的位置不能在head标签中，至少要放到body标签内。

**方法四：使用xhr脚本注入**
会受到同源策略的限制
```js
let xhr = new XMLHttpRequest()
xhr.open('get', './01.extra.js', true)
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            let script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = './01.extra.js';
            script.text = xhr.responseText;
            console.log(xhr.responseText)
            // 只有添加到html文件中才会开始下载
            document.body.append(script);
        }
    }
}
xhr.send(null);

```



### Promise的理解

#### 概述

> Promise 是异步编程的一种解决方案，比传统的回调函数和事件更好。
> 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。类比为订阅演唱会的时间地址.

#### 状态
Promise有三种状态，分别是：Pending（进行中）， Fulfilled(Resolved已完成)，Rejected (已失败)。
Promise从Pending状态开始，如果成功就转到成功态，并执行resolve回调函数；如果失败就转到失败状态并执行reject回调函数。

#### 优点
- 指定回调函数的时机更加灵活: 在异步操作启动前或完成后, 指定回调函数得到异步结果
- promise链式调用解决嵌套回调的回调地狱问题 
```js
// 异步操作启动前执行操作
let promise = doSomething()
promise.then(successCallback, failureCallback)

// 异步操作完成后指定回调
let promise = doSomething()
setTimeout(() => {(promise.then(successCallback, failureCallback)), 3000)
```


### promise.prototype.then()返回值
Promise.then()方法返回一个新的 Promise 对象，它的状态和值取决于 then 中的回调函数的执行结果。具体来说，有以下几种情况：
* 返回一个Promise,其值和状态决定了返回Promise的值和状态
* 返回一个错误, 返回一个失败的Promise,其值为返回的错误
* 其它值 返回一个成功的Promise,其值为其它值



### Promise-API实现

| 静态方法                     | 作用                                                         | 其他 |
| ---------------------------- | ------------------------------------------------------------ | ---- |
| Promise.all(iterable)        | 传入一个可迭代对象,返回一个promise<br/>* 当所有promise都resolve的时候, 新的 promise 才会 resolve，并且其结果数组将成为新 promise 的结果。<br/>* 当其中一个promise被reject, 立即返回这个reject,忽略其他promise |      |
| Promise.allSettled(iterable) | 返回一个在所有给定的 promise 都已经`fulfilled`或`rejected`后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。<br/> 适用于多个彼此不依赖的异步任务settled时, 或想知道每个promise的结果时 |      |
| Promise.any()                | 接收一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)可迭代对象，只要其中的一个 `promise` 成功，就返回那个已经成功的 `promise` 。 |      |
| Promise.race                 | 返回一个Promise,一旦迭代器中的某个promise解决或拒绝,返回的promise就会解决或拒绝. |      |





#### Promise.all

##### 概述
all方法接受一个或多个promsie（以数组方式传递），返回一个新promise，该promise状态取决于传入的参数中的所有promsie的状态：
当所有promise都完成是，返回的promise完成，其最终值为由所有完成promsie的最终值组成的数组；
当某一promise被拒绝时，则返回的promise被拒绝，其拒绝原因为第一个被拒绝promise的拒绝原因；

##### 代码实现
```javascript
//20220724
Promise.prototype.all = function (promises) {
	return new Promise((resolve, reject) => {
		// 判断是否为可迭代对象
		if (!Array.isArray(promises)) {
			throw new TypeError('promises must be an iterable object')
		}

		let resultArr = []
		promises.forEach((promise, idx) => {
			promise.then(
				value => {
					resultArr[idx] = value
					idx === (promises.length - 1) && resolve(resultArr)
				 },
				error => { 
					reject(error)
				}
			)
		})
	})
}
```

##### 案例
```js
function p1(){
    var promise1 = new Promise(function(resolve,reject){
        console.log("p1的第一条输出语句");
        console.log("p1的第二条输出语句");
        resolve("p1完成");
    })
    return promise1;
}

function p2(){
    var promise2 = new Promise(function(resolve,reject){
        console.log("p2的第一条输出语句");
        setTimeout(()=>{console.log("p2的第二条输出语句");resolve("p2完成")},2000);

    })
    return promise2;
}

function p3(){
    var promise3 = new Promise(function(resolve,reject){
        console.log("p3的第一条输出语句");
        console.log("p3的第二条输出语句");
        resolve("p3完成")
    });
    return  promise3;
}

Promise.all([p1(),p2(),p3()]).then(function(data){
    console.log(data);
})


//输出结果
p1的第一条输出语句
p1的第二条输出语句
p2的第一条输出语句
p3的第一条输出语句
p3的第二条输出语句
p2的第二条输出语句
['p1完成','p2完成','p3完成']
```

#### Promise.allSettled

```javascript
function allSettled(promises) {
  if (promises.length === 0) return Promise.resolve([])
  
  const _promises = promises.map(
    item => item instanceof Promise ? item : Promise.resolve(item)
    )
  
  return new Promise((resolve, reject) => {
    const result = []
    let unSettledPromiseCount = _promises.length
    
    _promises.forEach((promise, index) => {
      promise.then((value) => {
        result[index] = {
          status: 'fulfilled',
          value
        }
        
        unSettledPromiseCount -= 1
        // resolve after all are settled
        if (unSettledPromiseCount === 0) {
          resolve(result)
        }
      }, (reason) => {
        result[index] = {
          status: 'rejected',
          reason
        }
        
        unSettledPromiseCount -= 1
        // resolve after all are settled
        if (unSettledPromiseCount === 0) {
          resolve(result)
        }
      })
    })
  })
}
```



#### Promise.any

```javascript
function any(promises) {
  // return a Promise, which resolves as soon as one promise resolves
  return new Promise((resolve, reject) => {
    let isFulfilled = false
    const errors = []
    let errorCount = 0
    promises.forEach((promise, index) => promise.then(
      (data) => {
      if (!isFulfilled) {
        resolve(data)
        isFulfilled = true
      }
    }, 
      (error) => {
      errors[index] = error
      errorCount += 1

      if (errorCount === promises.length) {
        reject(new AggregateError('none resolved', errors))
      }
    }))
  })
}

//https://github.com/azl397985856/fe-interview/issues/125
Promise.any = ps => new Promise((resolve, reject) => {
  ps.forEach((p, idx) => p.then(resolve)).catch(err => idx === (ps.length - 1) && reject(new Aggregate('none resolved')))
})
```



#### Promise.race

```javascript
Promise.race2 = function(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach(promise => Promise.resolve(promise).then(resolve, reject))
  })
}
```



### async/await与promise的关系

- async/await是消灭异步回调的最终方法
- 简化promise对象的使用, 不用再使用then/catch来指定回调函数. 但和Promise并不互斥
- 执行async函数, 返回promise对象,  
  - await相当于promise的then
  - try...catch可捕获异常, 相当于promise的catch




### aysnc/await 概述

* `async`用来描述`async`函数的.函数的返回值为promise对象.
* promise对象的结果和状态由`async`函数的返回值决定. 返回规则和then方法回调返回结果是一样的.
  * 如果返回结果是非promise类型的值,则返回值是成功的promise
  * 抛出一个错误, 函数的状态为失败状态rejected, 错误值为函数返回值.
  * 如果返回结果是promise类型的值, 则promise的状态和值决定了async这个promise的状态和返回
* await右侧的表达式一般为promise对象, 但也可以是其它的值
    * 如果表达式是promise对象, await返回的是promise成功的值.如果是失败的值,await会把promise的异常抛出, 我们可以使用try..catch捕获错误.
    * 如果表达式是其它值, 直接将此值作为await的返回值

* await...后面的代码相当于放到成功的回调中










### 问题总结

#### 如何改变Promise的状态

```js
//3种方法
1.resolve() 状态由pending变为fulfilled
2.reject()  状态由pending变为rejected
3.抛出异常   状态由pending变为rejected
```



#### Promise状态改变和指定回调函数(then)谁先谁后

```js
1.都有可能. 正常时先指定回调再改变状态
2.先改变状态再指定回调的方法//同步
 2.1 直接调用resolve()/reject()
 2.2 延迟更长时间才调用then()
    let p = new Promise((resolve, reject)=>{
        setTimeout(()=>{resolve('ok')},1000);
    })
    setTimeout(()=>{p.then(value=>{console.log(value)})},3000)
 
3.先指定回调(先调用then方法)再改变状态//执行器种直接异步调用resolve()/reject()
   let p = new Promise((resolve,reject) => {
        setTimeout(function(){
            resolve('ok')
        },1000)
     })
     p.then(value => {
         console.log(value);
     })

4.什么时候得到数据?
4.1 如果先指定的回调函数,当状态发生改变时,调用回调函数,得到数据
4.2 如果先改变的状态,在指定回调函数时,回调函数就会调用,得到数据
```



#### Promise.then()返回新的Promise的结果状态由什么决定

```js
//then方法的返回结果是一个promise对象
(1)	简单表达: 由then()指定的回调函数执行的结果决定(执行结果就是函数的返回值)
(2)	详细表达:                                    
①	如果抛出异常, 新promise变为rejected, reason为抛出的异常/throw抛出的值
②	如果返回的是非promise的任意值, 新promise变为fulfilled(resolved) 值为返回值
③	如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果,其值也会为then方法的返回值.
```



#### Promise异常穿透

```js
(1)	当使用promise的then链式调用时, 可以在最后指定失败的回调 
(2)	前面任何操作出了异常, 都会传到最后失败的回调中处理
```



#### Promise中断链条

```js
//返回一个pending状态的promise对象  return new Promise(()=>{})
//传一个错误的promise对象值,会被catch捕获,如果没有catch方法会报错
```


### 案例
> https://juejin.cn/post/7055460626923012104
> https://juejin.cn/post/6945319439772434469


```js
setTimeout(() => {
    console.log("0")
  }, 0)
  
new Promise((resolve,reject)=>{
    console.log("1")
    resolve()
  }).then(()=>{        
    console.log("2")
    new Promise((resolve,reject)=>{
      console.log("3")
      resolve()
    }).then(()=>{      
      console.log("4")
    }).then(()=>{       
      console.log("5")
    })
  }).then(()=>{  
    console.log("6")
  })

new Promise((resolve,reject)=>{
    console.log("7")
    resolve()
  }).then(()=>{         
    console.log("8")
  })
```




### js的垃圾回收机制

#### JS中判定位垃圾的情形如下:

- 对象不再被引用；
- 对象不能从根上访问到；

#### 常见的GC算法

- 引用计数
  - 语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。
- 标记清除
  - 遍历所有对象找标记活动对象；
  - 遍历所有对象清除没有标记对象；
  - 回收相应的空间。
- 标记整理
  - 标记整理可以看做是标记清除的**增强**。标记阶段的操作和标记清除一致。
- 分代回收
  - 内存分为新生代、老生代
  - 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
  - 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

​	

#### 性能优化
* 避免使用全局变量
* 减少判断层级
* 减少数据读取次数
* 减少循环体中的活动
* 事件绑定优化
* 避开闭包陷阱

### 内存泄露和内存溢出比较

- 内存溢出
  - 运行程序需要分配的内存超过了系统能给你分配的最大剩余内存
  - 抛出内存溢出的错误，程序中断运行
  - 演示代码

    ```
    const arr = []
    for (let index = 0; index < 100000000; index++) {
    	arr[index] = new Array(1000)
    }
    ```

- 内存泄漏
  - 理解: 当程序中的某个内存数据不再需要使用， 而由于某种原因， 没有被释放
  - 常见情况:
  - 意外的全局变量
```
	function fn () {a = new Array(100000)}
	fn()
```

  - 没有及时清除的定时器
  this.intervalId = setInterval(() => {}, 1000) // clearInterval(this.intervalId) ```
  - 没有及时解绑的监听
  this.bus.bus.on('xxx', this.handle) // this.bus.bus.off('xxx')```
  - 没有及时释放的闭包


### JS功能实现

#### 使用setTimeout实现setInterval
>https://github.com/Easay/issuesSets/issues/95
```js
function mySetInterval(fn, delay) {
	function interval() {
		setTimeout(interval, delay)
		fn()
	}
	setTimeout(interval, delay)
}

mySetInterval(() => console.log(1), 1000)


```
//实现clearInterval
```js
let id = 0
let timeMap = {}
const mySetInterval = (cb, time) => {
	let timeId = id;
	id++
	const fn = () => {
		cb()
		timeMap[timeId] = setTimeout(() => {fn()}, time)
	}
	timeMap[timeId] = setTimeout(fn, time)
	return timeId
}

function clearInterval(id) {
	clearTimeout(timeMap[id])
	delte timeMap[id]
}

let newId = mySetInterval(count, 1000)
setTimeout(() => clearInterval(newId), 3000)

function count() {
	console.log('a')
}
```


#### 实现一个准确的倒计时 ?
>https://github.com/Easay/issuesSets/issues/105










## DOM/BOM/浏览器

### 事件(了解)

**事件是文档或者浏览器窗口中发生的，特定的交互瞬间。**

事件是用户或浏览器自身执行的某种动作，如click,load和mouseover都是事件的名字。

事件是javaScript和DOM之间交互的桥梁。

### 事件流

#### 概述

事件流描述的是从页面中接收事件的顺序

#### 两种事件流模型

事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流

**冒泡型事件流**：事件的传播是从**最特定**的**事件目标**到最不特定的**事件目标**。即从DOM树的叶子到根。**【推荐】**

**捕获型事件流**：事件的传播是从**最不特定**的**事件目标**到最特定的**事件目标**。即从DOM树的根到叶子。



#### DOM事件流

DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束

DOM标准规定事件流包括三个阶段：事件捕获阶段、处理目标阶段和事件冒泡阶段。
- 事件捕获阶段：**实际目标**（\<div>）在捕获阶段**不会接收事件**。也就是在捕获阶段，事件从document到\<html>再到\<body>就停止了。上图中为1~3.
- 处理目标阶段：事件在\<div>上发生并处理。**但是事件处理会被看成是冒泡阶段的一部分**。
- 冒泡阶段：事件又传播回文档。



### 事件绑定方式
- 嵌入dom
```js
<button onclick="func()">按钮</button>
```

- 直接绑定
```js
btn.onclick = function(){}
```

- 事件监听
```js
btn.addEventListener('click',function(){})
```


### 事件冒泡
事件在传递给目标元素后, 会由内向外传递给外层的元素处理

### 事件委托
* 事件委托利用了事件冒泡，不直接给多个子元素绑定多个事件监听, 而是给它们共同的父元素绑定一个监听
* 当操作任意子元素时, 事件会冒泡到父元素上处理
* 使用事件委托可以节省内存。
```javascript
<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>凤梨</li>
</ul>

// good
document.querySelector('ul').onclick = (event) => {
  let target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
  }
}

// bad
document.querySelectorAll('li').forEach((e) => {
  e.onclick = function() {
    console.log(this.innerHTML)
  }
})
```



### 事件循环 //?
#### 是什么
执行消息队列的机制.(由于JS是单线程,一次只能执行一个任务.当多个任务堆在一起的时,需要给任务排队.按照先进先出的原则,形成一条消息队列)


事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。




### event.target/event.currentTarget
Event.target：返回触发事件的元素；
Event.currentTarget：返回绑定事件的元素。

当事件在DOM中传播时，event.target始终指向最初触发事件的元素，而event.currentTarget则随着事件的捕获或冒泡阶段而变化，指向当前处理事件的元素。

例如，如果你在一个ul元素上绑定了一个点击事件，并且点击了其中一个li子元素，那么event.target就是这个li元素，而event.currentTarget就是这个ul元素。

你可以利用event.target来实现事件委托，即通过在父元素上绑定一个事件处理函数来处理子元素的相同类型的事件。







### 事件冒泡与事件委托

#### 1) 事件冒泡的流程
- 基于DOM树形结构
- 事件在目标元素上处理后, 会由内向外(上)逐层传递
- 应用场景: 事件代理/委托/委派

#### 2) 事件委托
- 减少内存占用(事件监听回调从n变为1)
- 动态添加的内部元素也能响应
- 不直接给多个子元素绑定多个事件监听, 而是给它们共同的父元素绑定一个监听
- 当操作任意子元素时, 事件会冒泡到父元素上处理
- 在事件回调中通过event.target得到发生事件的目标元素, 并进行相关处理


### 封装一个绑定事件监听的函数

> [封装事件监听函数_巴拉巴拉小魔仙_的博客-CSDN博客](https://blog.csdn.net/m0_66637749/article/details/122708615)

```js
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
  </head>
  <body>
    <div>
      <button id="btn">按钮</button>
      <ul id="divBox">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
      </ul>
    </div>
    <script>
      function bindEvent(ele, type, selector, fn) {
        if (fn == null) {
          fn = selector
          selector = null
        }

        ele.addEventListener(type, event => {
          const target = event.target
          if (selector) {
            // 代理绑定
            if (target.matches(selector)) {
              fn.call(target, event)
            }
          } else {
            // 普通绑定
            fn.call(ele, event)
          }
        })
      }


      // 普通绑定
      const btn = document.getElementById('btn')
      bindEvent(btn, 'click', function(e) {
        e.preventDefault();
        console.log(this)
        alert(this.innerText)
      })

      // 代理绑定
      const div = document.getElementById('divBox')
      bindEvent(div, 'click', 'li', function(e) {
        e.preventDefault()
        alert(this.innerText)
      })
    </script>
  </body>
</html>

```



### 前台数据存储

#### 存储方式
- cookie
- sessionStorage
- localStorage



#### localStoarge与sessionStorage比较
- 相同点:
  - 浏览器不能禁用, 请求时不会自动携带
  - 纯浏览器端存储, 
  - 只能保存文本, 如果是对象或数组, 需要转换为JSON
  - API相同:
    - setItem(key, value)
    - getItem(key, value)
    - removeitem(key, value)
- 不同点(关闭浏览器是否会被删除):
  - localStorage保存在本地文件中, 除非编码或手动删除, 否则一直存在
  - sessonStorage数据保存在当前会话内存中, 关闭浏览器则清除

#### sessionStorage同源跨窗口可以共享吗?
只有在本页面中以新页签或窗口打开的同源页面会‘临时复制’之前页面的sessionStorage。
a标签也是同样的效果



#### cookie与localStorage和sessionStorage比较
都是浏览器提供的用于存储数据的技术
* 存储大小不同：cookie一般只能存储4KB左右的数据，而localStorage和sessionStorage可以存储更大的数据，一般为5MB或更多。
* 数据有效期不同：cookie可以设置过期时间，如果没有设置，则在浏览器关闭时失效；localStorage始终有效，除非用户手动清除；sessionStorage只在当前浏览器窗口关闭前有效。
* 作用域不同：cookie在所有同源窗口中都是共享的，并且会随着每次HTTP请求发送到服务器；localStorage也在所有同源窗口中共享，但不会发送到服务器；sessionStorage一般不在不同的浏览器窗口中共享。
* 数据安全性不同：cookie相对较容易被篡改或窃取，因此不适合存储敏感信息；localStorage和sessionStorage相对较安全，但仍然可能受到XSS攻击

#### cookie与session比较
cookie和session都是用来记录客户状态的机制，但它们有以下几个区别：
* 存储位置不同：cookie数据存放在客户端浏览器中，session数据存放在服务器上。
* 安全性不同：cookie相对较容易被篡改或窃取，因此不适合存储敏感信息；session相对较安全，因为它只能通过特定的sessionID来访问。
* 服务器性能不同：session会占用服务器的内存资源，如果访问量过大，可能会影响服务器的性能；cookie则不会给服务器增加负担。
* 存储容量和有效期不同：单个cookie保存的数据一般不能超过4KB，而且一个站点最多只能保存20个cookie；session则没有明确的上限，但出于对服务器性能的考虑，应该尽量精简和及时删除无用的session。
* 有效期: cookie可以设置过期时间，如果没有设置，则在浏览器关闭时失效；session也有一定的有效期，一般为30分钟，如果超过这个时间没有活动，则会自动失效.



### Ajax
#### 概述
Ajax是一种用于创建异步Web应用的技术，它可以在不刷新整个网页的情况下，与服务器交换数据并更新部分网页内容，从而提高用户体验和性能。

Ajax的核心是XMLHttpRequest对象，它可以使用JavaScript向服务器发送请求，并接收服务器的响应。响应的数据格式可以是XML、JSON、文本或其他类型。然后，JavaScript可以使用DOM操作来修改网页内容




#### 使用Ajax的优缺点分别是什么
>https://www.frontendinterviewhandbook.com/javascript-questions#what-are-the-advantages-and-disadvantages-of-using-ajax

**优点**
- 交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。
- 减少与服务器的连接，因为脚本和样式只需要被请求一次。
- 状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。
- 基本上包括大部分 SPA 的优点。

**缺点**
- 动态网页很难收藏
	- URL可能不会随内容变化而更新导致收藏无法访问
	- 动态网页可能依赖临时会话信息/身份验证,收藏无法访问/显示错误
- 如果 JavaScript 已在浏览器中被禁用，则不起作用。
- 有些网络爬虫不执行JavaScript，也不会看到 JavaScript 加载的内容。
- 基本上包括大部分SPA的缺点


#### Ajax和Fetch区别
* ajax是一种异步JS和XML技术合集,它的实现就有xhr和fetch
* fetch 是浏览器自带的 API，且它是基于标准 Promise 的. 
* axios = xhr + http；


#### 封装一个简易的ajax异步请求函数

##### 简洁版(必须)

```js
/* 
xhr + promise 封装一个异步ajax请求的通用函数  简洁版
*/
function ajax(url) {
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const xhr = new XMLHttpRequest()
    // 初始化一个异步请求(还没发请求)func
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function () {
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (xhr.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (xhr.status>=200 && xhr.status<300) {
        // 指定promise成功及结果值
        resolve(JSON.parse(xhr.responseText))
      } else { // 请求失败了
        // 指定promise失败及结果值
        reject(new Error('request error staus '+ request.status))
      }
    }
    xhr.send(null)
  })
}
```

##### 加强版(可选)

```js
/* 
xhr + promise 封装一个异步ajax请求的通用函数  加强版
  返回值: promise
  参数为配置对象
    url: 请求地址
    params: 包含所有query请求参数的对象
    data: 包含所有请求体参数数据的对象
    method: 为请求方式
*/
function axios({url, params={}, data={}, method='GET'}) {
  // 返回一个promise对象
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const request = new XMLHttpRequest()
    
    // 根据params拼接query参数
    let queryStr = Object.keys(params).reduce((pre, key) => {
      pre += `&${key}=${params[key]}`
      return pre
    }, '')
    if (queryStr.length>0) {
      queryStr = queryStr.substring(1)
      url += '?' + queryStr
    }
    // 请求方式转换为大写
    method = method.toUpperCase()
    
    // 初始化一个异步请求(还没发请求)
    request.open(method, url, true)
    // 绑定请求状态改变的监听
    request.onreadystatechange = function () {
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (request.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (request.status>=200 && request.status<300) {
        // 准备响应数据对象
        const responseData = {
          data: JSON.parse(request.response),
          status: request.status,
          statusText: request.statusText
        }
        // 指定promise成功及结果值
        resolve(responseData)
      } else { // 请求失败了
        // 指定promise失败及结果值
        const error = new Error('request error staus '+ request.status)
        reject(error)
      }
    }

    // 如果是post/put请求
    if (method==='POST' || method==='PUT' || method==='DELETE') {
      // 设置请求头: 使请求体参数以json形式传递
      request.setRequestHeader('Content-Type', 'application/json;charset=utf-8')
      // 包含所有请求参数的对象转换为json格式
      const dataJson = JSON.stringify(data)
      // 发送请求, 指定请求体数据
      request.send(dataJson)
    } else {// GET请求
      // 发送请求
      request.send(null)
    }
  })
}
```



### 跨域
#### 概述
跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这种资源一般是由浏览器的同源策略所禁止访问的。
跨域问题的出现是因为浏览器和服务器之间需要进行数据交互，而有些数据又不希望被其他来源的网站访问，所以需要有一种机制来限制或允许跨域请求。

#### 同源策略
同源策略是浏览器为了保护用户隐私和安全而实施的一种安全机制，它要求两个 URL 的协议、域名和端口都相同，才能认为是同源，否则就是跨域。

#### 跨域解决方法
- JSONP
- CORS
- 代理服务器


##### JSONP原理
是什么?
>利用 `<script>` 标签没有跨域限制的特点，通过动态创建 `<script>` 标签，发送带有回调函数名的 GET请求，服务器返回包含该回调函数的数据，浏览器执行该函数并获取数据。
>这种方法只能发送 GET 请求，并且需要服务器端配合


- 前台:
  - `<script src="目标url?callback=fn" />`
  - 声明函数 function fn (data) {}
- 后台
  - 处理请求, 产生需要返回的数据data
  - 读取callback请求参数得到前台处理响应数据的函数名fn
  - 返回执行函数fn的js代码: 'fn(data)'

- 不足
  - 只能处理GET请求
  - 每个请求在后台都要做处理, 麻烦
  ```js
  // 发送jsonp请求的函数
  function jsonp() {
      var script = document.createElement('script')
      script.type = 'text/javascript'
      // 传参并指定回调执行函数为backFn
      script.src = 'http://localhost:4000/getUserInfo?id=100&callback=cbFn'
      document.body.appendChild(script)
  }
  
  // 回调函数, 接收响应数据
  function cbFn(data) {
  	console.log(data)
  }
  ```

  

##### CORS原理

>即跨域资源共享，是一种 W3C 标准，它允许浏览器向跨源服务器发出 XMLHttpRequest 请求。它需要浏览器和服务器同时支持，并且在服务器端设置响应头 Access-Control-Allow-Origin 等字段来允许或拒绝跨域请求。
> 这种方法支持各种类型的请求，并且可以携带 Cookie 等信息。

```js
// 使用cors, 允许跨域, 且允许携带跨域cookie
app.use(function (req, res, next) {
  // console.log('----')
  // 允许跨域的地址
  res.header('Access-Control-Allow-Origin', 'http://localhost:5500')  // 不要是*
  // 允许携带凭证(也就是cookie)
  res.header('Access-Control-Allow-Credentials', 'true')
  // 允许跨域的请求头
  res.set("Access-Control-Allow-Headers", "Content-Type")
  // 放行
  next()
})
```


#### 代理服务器

- 开发环境: 利用webpack-dev-server中的http-proxy-middle  进行正向代理
  - vue脚手架项目: vue.config.js
  - react脚手架项目: package.json
- 生产环境: 利用nigix 进行反向代理





### axios二次封装

#### 第一种
1. 配置通用的基础路径和超时: 
	axios.create({baseURL, timeout})
2. 显示请求进度条
   显示: 准备发请求前显示, 在请求拦截器中执行NProgress.start()
   ​隐藏: 请求结束隐藏, 在响应拦截器成功/失败回调中NProgress.done()

3. 携带token数据
   ​在请求拦截器中, 将token添加到请求头中
4. 成功返回的数据不再是response, 而直接是响应体数据response.data
   ​响应拦截器成功的回调中: return response.data
5. 统一处理请求错误, 具体请求也可以选择处理或不处理
   ​在响应拦截器失败的回调中: alert提示错误信息, return Promise.reject(error)
```js
//
import axios from 'axios';
import Nprogress from 'nprogress';
import 'nprogress/nprogress.css'

const service = axios.create({
    baseURL:'/api',
    timeout:20000
})

service.interceptors.request.use(
  (config)=>{
    Nprogress.start();
    //临时数据标识  token
    let userTempId = store.state.user.userTempId;
    if(userTempId){
        config.headers.userTempId = userTempId;
    }
    let token = store.state.user.token;
    if(token){
        config.headers.token = token;
    }
    return config;
},
  
(error)=>{
    alert(error.message)
 }                                 
)

service.interceptors.response.use(
    (response)=>{
    Nprogress.done();
    return response.data;
	},
    (error)=>{
        Nprogress.done();
        //return new Promise(()=>{})
        return Promise.reject(new Error('请求失败'))
    }
)

export default service;
```


#### 第二种







### Restless API 与 Restful API   // ?
- Restless API  
  - 传统的API, 把每个url当作一个功能操作      /updateUser
  - 同一个url, 后台只进行CRUD的某一种操作
  - 请求方式不决定请求的CRUD操作
  - 一个请求路径只对应一个操作
  - 一般只有GET/POST

- Restful API 
  - 新式的API, 把每个url当作一个唯一资源   /user/2
  - 同一个url, 可以通过不同类型的请求对后台资源数据进行CRUD四种操作
  - 请求方式来决定了请求在后台进行CRUD的哪种操作
    - GET: 查询
    - POST: 添加
    - PUT: 更新
    - DELETE: 删除
  - 同一个请求路径可以进行多个操作
  - 请求方式会用到GET/POST/PUT/DELETE

- 测试: 可以使用json-server快速搭建模拟的rest api 接口


### 重排和重绘
> https://juejin.cn/post/6844904083212468238


#### 重绘重排区别
重绘和重排是浏览器渲染页面的两个过程，它们有以下区别：
* 重绘是指元素的外观发生改变，但不影响布局的情况，例如改变颜色、背景、边框等。
* 重排是指元素的几何属性发生改变，影响了布局的情况，例如改变位置、大小、内容等。
* 重排往往有重绘。因此，在优化页面性能时，应该尽量减少重排和重绘的次数和范围。

#### 哪些操作导致重排
- 元素位置和尺寸发生改变的时候
- 新增和删除可见元素
- 内容发生改变（文字数量或图片大小等等）
- 元素字体大小变化。
- 激活CSS伪类（例如：:hover）。
- 设置style属性
- 频繁查询布局信息的属性。比如说： offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight


#### 哪些操作会导致重绘
- 更新元素的部分属性(影响元素的外观，风格，而不会影响布局)，比如 visibility、outline、背景色等属性的改变。

#### 重排优化建议
##### 减少重排范围
* 尽可能直接在目标元素上操作,而不用操作父元素/兄弟元素
* 不使用table布局,1个小改动会造成整个table重新布局
##### 减少重排次数
* 样式集中改变
* 分离读写操作
* 将DOM离线
* 使用absolute或fixed脱离文档流
* 优化动画

**样式集中改变**

**分离读写操作**
读操作放在一起,写入操作放在一起

**将DOm离线** !!
* 使用 display:none
* documentFragment
* 复制节点,副本操作,然后替换

**优化动画**
* 动画效果应用position为absolute/fixed
* 启用GPU加速的属性: CSS转换, CSS33D变换transform webgl, 视频



## 手写代码

### 深拷贝

#### 是什么
深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**。

浅拷贝: 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在==栈==中的地址，而不是堆中的数据。两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。

#### 浅拷贝
和深拷贝对应的浅拷贝,JS中的相关方法有:
* `[].slice(0)`
* `[].concat(arr)`
* 扩展运算符
* Object.assign(obj1,obj2)

#### 深拷贝实现方式
- JSON.parse(JSON.stringfy(obj)) 
  -  ===> 问题: 方法/函数会丢失
  -  ===> 问题2: 循环引用会出错(死循环)
- 递归遍历
  - 如果是基本类型与函数直接返回, 函数就不会丢失也不会拷贝
  - 如果是对象/数组创建拷贝对象/数组
  - 问题: 循环引用会出错的问题(死循环)
- 使用Map缓存拷贝对象
  - 如果发现一个对象已经产生拷贝对象, 直接返回这人拷贝对象
  - 使用Map存储 ==> key为源对象, value是拷贝产生的对象  (不能用对象来存储, 因为对象的key为字符串)
- 库. lodash

```js
/* 
1). 大众乞丐版
    问题1: 函数属性会丢失   原因: json字符串数据是不存在函数, 函数属性就会丢失
    问题2: 循环引用会出错   原因: 转换为json字符串是会产生死循环查找, 报错
利用JSON转换成json字符串, 再解析回来
*/
deepClone1 (target) {
  if (target!==null && typeof target==='object' ) {
    return JSON.parse(JSON.stringify(target))
  } else {
    return target
  }
},
```


```javascript
//作者：神三元
//链接：https://juejin.cn/post/6844903986479251464
const getType = obj => Object.prototype.toString.call(obj);

const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

const canTraverse = {
  '[object Map]': true,
  '[object Set]': true,
  '[object Array]': true,
  '[object Object]': true,
  '[object Arguments]': true,
};
const mapTag = '[object Map]';
const setTag = '[object Set]';
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}

const handleNotTraverse = (target, tag) => {
  const Ctor = target.constructor;
  switch(tag) {
    case boolTag:
      return new Object(Boolean.prototype.valueOf.call(target));
    case numberTag:
      return new Object(Number.prototype.valueOf.call(target));
    case stringTag:
      return new Object(String.prototype.valueOf.call(target));
    case symbolTag: //es6不推荐使用new,Symbol无法使用;所以使用valueOf
      return new Object(Symbol.prototype.valueOf.call(target));
    case errorTag: 
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}

const deepClone = (target, map = new WeakMap()) => {
  if(!isObject(target)) 
    return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return handleNotTraverse(target, type);
  }else {
    // 这波操作相当关键，可以保证对象的原型不丢失！
    let ctor = target.constructor;
    cloneTarget = new ctor();
  }

  if(map.get(target)) 
    return target;
  map.set(target, true);

  if(type === mapTag) {
    //处理Map
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key, map), deepClone(item, map));
    })
  }
  
  if(type === setTag) {
    //处理Set
    target.forEach(item => {
      cloneTarget.add(deepClone(item, map));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop], map);
    }
  }
  return cloneTarget;
}
```



#### 复述一下深拷贝的操作流程:

* 定义函数,  参数(target, map=new WeakMap())
* 判断是否是对象(判断条件), 非对象直接返回
* 获取具体的对象类型
* 判断是否是 5种 可遍历的对象 (可遍历对象5个: Array/Object/Set/Map/Arguments)
  * 如果是不可遍历的对象, 声明外部函数`handleNotCanTraverse(target, type)`来处理
    * 一类: 调用原型上的`valueOf`方法获取原始值, 再使用`new Object()`生成包装类对象 (string / number / boolean /symbol )
    * 一类: 默认调用原型上的构造函数,生成新的对象 (date error)
    * 一类: 调用独立的方法来处理( 正则表达式, 函数)
  * 如果是可遍历的对象
    * 首先是:  通过`target.constructor`属性获取其构造函数, 调用构造函数生成相应的实例对象
    * 如果存在对象引用 , 会提前在函数的参数中添加`map = new WeakMap()` (这个地方不熟悉的话可以省略不说)
      * 存在对象引用: 直接返回这个对象; 
      * 当前对象不存在引用, 将当前对象添加进map集合中 `map.set(target, true)`
    * 如果是map类型
      * `cloneTarget.set(deepClone(key, map), deepClone(item, map))`
    * 如果是set类型
      * `cloneTarget.add(deepClone(item , map))`
    * 如果是对象 / 数组 类型, 使用`for...in`循环来处理
      * `cloneTarget[key] = deepClone(target[key], map)`



### 数组相关

#### 判断数据类型是否为数组的方案7种
* [] instanceof Array
* [].\_\_proto\_\_ === Array.prototype
* [].constructor === Array
* Array.prototype.isPrototypeOf([])
* Object.getPrototypeOf([]) === Array.prototype
* Object.prototype.toString.call([]).slice(8, -1)
* Array.isArray([])


#### 数组扁平化 7种
* toString + split
* flat
* JSON.stringify + replace + split / JSON.parse
* 递归
  * for ...of
  * reduce
* 扩展运算符 + some 
```javascript
//toString + split

arr.toString().split(',')

//flat
arr.flat(Infinity)

//JSON + replace+split
//JSON.stringify(arr.replace(/\[|\]/g, '')).split(',')
JSON.stringify(arr).replace(/\[|\]/g, '').split(',')``

//JSON + replace + JSON.parse
let res = JSON.stringify(arr).replace(/\[|\]/g, '')
let newArr = JSON.parse('[' + res + ']')

//递归+for/reduce
let res = []
function flat(arr) {
  for (let i=0; i<arr.length; i++) { 
    if (Array.isArray(arr)) {
    	flat(arr[i])
  	} else {
      res.push(arr[i])
    }
  }
}
//
function flat(arr) {
  return arr.reudce((pre, crt) => {
    return pre.concat(Array.isArray(crt) ? flat(crt) : crt
  }, [])
}
                    

//扩展运算符
while(arr.some(Array.isArray)) {
    arr = [].concat(...arr)  // arr = [].concat(arr) 加不加扩展运算符都一样的 多循环一次
  }
```



#### 实现flat
```javascript
//递归
// arguments.callee指向argumetns对象所在函数的指针, 实现函数名与逻辑的解耦
function flat(arr) {
  let res = []
  arr.forEach(item => {
    if (Array.isArray(item)) {
      res = res.concat(arguments.callee(item)) 
      // res.push(...arguments.callee(item))
    } else {
      res.push(item)
    }
  })
  
  return res
}

//reduce
const flat = arr => {
  return arr.reduce((acc, crt) => {}, [
    return acc.concat(Array.isArray(crt) ? flat(crt) : crt)
  ])
}

//其他方法
```







#### 数组去重 7 种
* for + for  + splice
* for + for+ 新数组
* for + indexOf / includes
* reduce + indexOf/includes
* filter + indexOf / sort()
  * indexOf存在的问题
  * sort排序的问题  sort()排序有漏洞, 并不适用于特殊类型的排序. !!!!???
* sort快慢指针
* object键值对 + map键值对
  * object键值对存在的问题: 不能去重正则表达式
* new Set()
```javascript
let arr = [1,2,3,1,1,4,3,2,5,6,7];
// for + for 

for (let i=0; i<arr.length; i++) {
  for (let j=i+1; j<arr.length; j++) {
	  if (arr[j] === arr[i]) {
		  arr.splice(j, 1)
	    j--
	  }
  }
}

//for + 新数组

let newArr = []
let j;

for (let i=0; i<arr.length; i++) {
  for (j=0; j<newArr.length; j++) {
    if (arr[i] === newArr[j]) {
      break
    }
  }
  if (j === newArr.length) {
    newArr.push(arr[i])
  }
}

let newArr = []
for (let i=0, len=arr.length; i<len; i++) {
  for (let j=0, len=newArr.length; j<len; j++) {   //这里如果不采用变量形式,会出现死循环
    if (arr[i] === newArr[j]) {
      break
    }
    
    if (j === newArr.length) {
      newArr.push(arr[i])
    }
  }
}
```



```javascript
//for + indexOf / includes

let res = []
for (let i=0; i<arr.length; i++) {
  if (res.indexOf(arr[i] === -1)) { // !res.includes(arr[i])
    res.push(arr[i])
  }
}
```



```javascript
// reduce + indexOf / includes

arr.reduce((pre, crt) => pre.includes(crt) ? pre : pre.concat(crt), [])
arr.reduce((pre, crt) => pre.indexOf(crt) === -1 ? pre.concat(crt) : pre, [])
```



```javascript
//filter + indexOf

arr.filter((item, idx, arr) => arr.indexOf(item) == idx)
//存在的问题
1.arr.indexOf(NaN)的结果是-1,所以会忽略NaN这个值.
2.对象不去重

arr.concat().sort().filter((item, idx, arr) => !idx || item !== arr[idx - 1])
```



```javascript
//sort快慢指针

//https://juejin.cn/post/6844904202162929671

function unique(arr) {
  arr.sort((a, b) => a - b);
  let left = 0,
      right = 1;
  
  while(right < arr.length) {
    if (arr[left] === arr[right]) {
      right++;
    } else {
      arr[left + 1] = arr[right];
      left++;
      right++;
    }
  }
  return arr.slice(0, left+1);
}

//https://juejin.cn/post/7033275515880341512
function unique2(arr) {
  arr.sort((a, b) => a - b);
  let slow = 1,
      fast = 1;
  
  while(fast < arr.length) {
    if (arr[fast - 1] !== arr[fast]) {
      arr[slow++] = arr[fast];
    }
    ++fast;
  }
  arr.length = slow;
  return arr;
}
```



```javascript
//object键值对

// 考虑到 `JSON.stringify` 任何一个正则表达式的结果都是 `{}`，所以这个方法并不适用于处理正则表达式去重。

let obj = {}
arr.filter( v => obj.hasOwnProerpty(v) ? false : (obj[typeof v + JSON.stringify(v)] = true))
```



```javascript
//map键值对

let map = new Map()
arr.fitler((item, idx, arr) => !map.has(item) && map.set(item, true))
```



```javascript
// set
let res = (arr) => [...new Set(arr)]
```

#### 数组去重存在的问题

重点关注下 对象 和NaN 的去重

| 方法                                                         | 结果                                                         | 说明                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------- |
| for循环(双for+新数组)                                        | [1, "1", null, undefined, String, String, /a/, /a/, NaN, NaN] | 对象和 NaN 不去重                       |
| indexOf(作者用的是新数组+for循环+indexOf方法)                | [1, "1", null, undefined, String, String, /a/, /a/, NaN, NaN] | 对象和 NaN 不去重                       |
| sort<br />结论是数字1不去重,没有勘误.不知道是哪个数字1,是包装类的吗? | [/a/, /a/, "1", 1, String, 1, String, NaN, NaN, null, undefined] | 对象和 NaN 不去重 <br />数字 1 也不去重 |
| filter+indexOf                                               | [1, "1", null, undefined, String, String, /a/, /a/]          | 对象不去重 NaN 会被忽略掉               |
| filter+sort                                                  | [/a/, /a/, "1", 1, String, 1, String, NaN, NaN, null, undefined] | 对象和 NaN 不去重 数字 1 不去重         |
| 优化后的键值对方法                                           | [1, "1", null, undefined, String, /a/, NaN]                  | 全部去重                                |
| Set                                                          | [1, "1", null, undefined, String, String, /a/, /a/, NaN]     | 对象不去重 NaN 去重                     |






#### 数组翻转

1. 使用原型中的reverse方法

   ```js
   let array = [1, 2, 3, 4, 5]
   array.reverse() 
   ```
   
2. 循环
* 临时变量(索引之和等于长度减1)
* unshift
   ```js
   for(var i = 0; i < arr.length; i++){
       var temp = arr[i];
       arr[i] = arr[arr.length - 1 - i]
       arr[arr.length - 1 - i] = temp;
   }

   ```

   


#### 排序算法

##### 简单排序: 冒泡 / 选择 / 插入

```js
/* 
冒泡排序的方法
*/
function bubbleSort (array) {
  // 1.获取数组的长度
  var length = array.length;

  // 2.反向循环, 因此次数越来越少
  for (var i = length - 1; i >= 0; i--) {
    // 3.根据i的次数, 比较循环到i位置
    for (var j = 0; j < i; j++) {
      // 4.如果j位置比j+1位置的数据大, 那么就交换
      if (array[j] > array[j + 1]) {
        // 交换
        // const temp = array[j+1]
        // array[j+1] = array[j]
        // array[j] = temp
        [array[j + 1], array[j]] = [array[j], array[j + 1]];
      }
    }
  }

  return arr;
}

/* 
选择排序的方法
*/
function selectSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 从0位置开始取出数据, 直到length-2位置
  for (var i = 0; i < length - 1; i++) {
    // 3.内层循环: 从i+1位置开始, 和后面的内容比较
    var min = i
    for (var j = min + 1; j < length; j++) {
      // 4.如果i位置的数据大于j位置的数据, 记录最小的位置
      if (array[min] > array[j]) {
        min = j
      }
    }
    if (min !== i) {
      // 交换
      [array[min], array[i]] = [array[i], array[min]];
    }
  }

  return arr;
}

/* 
插入排序的方法
*/
function insertSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后
  for (var i = 1; i < length; i++) {
    // 3.记录选出的元素, 放在变量temp中
    var j = i
    var temp = array[i]

    // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环
    while (j > 0 && array[j - 1] > temp) {
      array[j] = array[j - 1]
      j--
    }

    // 5.将选出的j位置, 放入temp元素
    array[j] = temp
  }

  return array
}
```



##### 快速排序(选择性)

```js
function quickSort(arr) {
  // 递归结束的条件
  if(arr.length < 2){
    return arr
  }
  // 获取中间值
  let flag = Math.floor(arr.length / 2);
  let flagValue = arr.splice(flag, 1)[0];
  
  let leftArr = [];
  let rightArr = [];
  for (var i = 0; i < arr.length; i++) {
    var arrItem = arr[i];
    
    if(arrItem > flagValue){
      rightArr.push(arrItem)
    }else {
      leftArr.push(arrItem)
    }
  }
  
  leftArr = quickSort(leftArr);
  rightArr = quickSort(rightArr);
  return [...leftArr, flagValue, ...rightArr]
}
```





### 函数相关

#### 函数的call() / apply() / bind()

```javascript

//call
Function.prototype.call2 = function(...items) {
  let obj = items.shift() || globalThis
  let tempFn = Symbol()
  obj[tempFn] = this
  
  let res = obj[tempFn](...items)
  delete obj[tempFn]
  
  return res
}

// 不建议使用arguments
Function.prototype.myCall = function() {
  let obj = [].shift.call(arguments) || globalThis;
  obj.tempFn = this
  
  let res = obj.tempFn(...[...arguments]);
  delete obj.tempFn;
  return res;
}



//apply
Function.prototype.apply2 = function(...items) {
  let obj = items.shift() || globalThis
  obj[tempFn] = this
  let res = obj[tempFn](items)
  delete obj[tempFn]
  
  return res
}

//bind

//1 version
Function.prototype.bind = function(cxt) {
  let fn = this
  let argsOut = [].slice.call(arguments)
  return function() {
    let argsInner = [].slice.call(arguments)
    fn.apply(cxt, argsOut.concat(argsInner))
  }
}

//

//2 version  避免实例通过原型链更改函数原型上的属性,使用空函数中转 + 可以使用new调用
Function.prototype.bind = function () {
	let fn = this
  let argsOut = [].slice.call(arguments, 1)
  let fNOP = function() {}
  let fbound = function () {
    let argsInner = [].slice.call(arguments)
    return fn.apply(this instanceof fNOP ? this : crt, argsOut.concat(argusInner))
  }
  
  fNOP.prototype = this.prototype
  fbound.prototype = new fNOP()
  return fbound
}
```



```js
/* 
自定义函数对象的call方法
*/
function call (fn, obj, ...args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
自定义函数对象的apply方法
*/
function apply (fn, obj, args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
  自定义函数对象的bind方法
  重要技术:
    高阶函数
    闭包
    call()
    三点运算符
*/
function bind (fn, obj, ...args) {
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  
  return function (...args2) {
    call(fn, obj, ...args, ...args2)
  }
}
```



### 字符串处理

```js
/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/

/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
*/
function reverseString(str) {
  // return str.split('').reverse().join('')
  // return [...str].reverse().join('')
  return Array.from(str).reverse().join('')
}

/* 
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
*/
function palindrome(str) {
  return str === reverseString(str)
}

/* 
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/
function truncate(str, num) {
  return str.length > num ? str.slice(0, num) + '...' : str
}
```



### instanceof内部原理和实现

instanceof运算符判断一个对象是否为另一个对象的实例

```javascript

function isntanceof2(case, Ctor) {
    //基本数据类型返回false
  //兼容一下函数对象
  if (typeof(Case) !== 'object' && typeof(Case) !== 'function' || Case === 'null') {
    return false;
  }
  
  let caseProto = Object.getPrototypeOf(case)
  while(true) {
    if (caseProto == null) return false
    //找到相同的原型
    if (caseProto === Ctor.prototype) return true
    caseProto = Object.getPrototypeOf(caseProto)
  }
}


```



## 浏览器和网络

### HTTP

### 输入网址后发生了什么

> [what-happens-when-zh_CN/README.rst at master · skyline75489/what-happens-when-zh_CN (github.com)](https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst?utm_medium=social&utm_source=wechat_session&from=timeline&isappinstalled=0)

* 合成URL
* DNS域名解析
  * 浏览器缓存--->本地hosts文件--->本地DNS解析器缓存--->本地DNS服务器--->根域名服务器-->顶级域名服务器(com, cn,...)-->权威域名服务器(顶级域名托管商)

* 建立TCP连接
  * 首先，判断是不是https的，如果是: 服务端和客户端的信息传输都会加密
  * 进行三次握手,建立TCP连接
    * 第一次握手：建立连接。客户端发送连接请求报文段
    * 第二次握手：服务器收到报文段。同时，自己还要发送请求信息给客户端
    * 第三次握手：客户端收到服务器的报文段。然后将向服务器发送报文段，客户端服务器更新状态,完成TCP三次握手。

* 客户端发送HTTP请求,服务器处理请求,返回响应结果

* 一方完成数据发送任务.关闭TCP连接,四次挥手
	* 客户端告诉服务器，我不需要再发送数据了。
	* 服务器告诉客户端，我知道你不需要再发送数据了。
	* 服务器告诉客户端，我也不需要再发送数据了。
	* 客户端告诉服务器，我知道你不需要再发送数据了。

* 浏览器渲染
  1.HTML 被 HTML 解析器解析成 DOM 树；
  2.CSS  被 CSS 解析器解析成 CSSOM 树；
  3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree,这一过程称为 Attachment)
  4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
  5.将布局绘制(paint)在屏幕上，显示出整个页面。


### 浏览器如何渲染页面的？

1、HTML被HTML解析器解析成DOM树。 
2、CSS被CSS解析器解析成CSS规则树。 
3、浏览器会将CSS规则树附着在DOM树上，并结合两者生成渲染树Render Tree。 
4、生成布局（flow），浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。 
5、将布局绘制（paint）在屏幕上，显示出整个页面

### GET和POST的区别
**使用范围**
GET: 用于获取资源。
POST: 用于提交资源。
**数据发送方式**
GET: 通过URL将数据传输到服务器。
POST: 通过HTTP协议body将数据传输到服务器。
**数据发送长度**
GET: 受限于浏览器和服务器的限制，通常最多为2048个字符。
POST: 通常没有大小限制。但是，很多服务器会对提交数据的大小设置一个上限。
**数据发送类型**
GET: 只能发送ASCII字符。
POST: 没有编码限制，可以传输二进制数据。
**处理速度**
GET: 数据通过URL传输，处理速度更快。
POST: 数据通过消息主体传输，处理速度略慢。
**数据缓存**
GET: 可以被缓存，结果可被缓存。
POST: 不能被缓存。
**安全性**
GET: 数据以明文形式出现在URL中，并且被浏览器保存在历史记录中。跨站点脚本利用（XSS）容易利用这种意味着敏感数据不应使用GET传输。
POST: 与GET相比，POST提供更好的安全性，因为数据不可见在URL中，且由于该方法请求的数据存储在HTTP协议的内部，所以不容易被网络上的其他用户获取。






### Accept和Content-Type

Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。 服务器使用 Content-Type 应答头通知客户端它的选择。

```text
Accept: text/html
Accept: image/*
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

1.Accept属于请求头， Content-Type属于实体头。
Http报头分为通用报头，请求报头，响应报头和实体报头。
请求方的http报头结构：通用报头|请求报头|实体报头
响应方的http报头结构：通用报头|响应报头|实体报头

2.Accept代表发送端（客户端）希望接受的数据类型。
比如：Accept：text/xml;
代表客户端希望接受的数据类型是xml类型

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。
比如：Content-Type：text/html;
代表发送端发送的数据格式是html。

二者合起来，
Accept:text/xml；
Content-Type:text/html
即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。


### post常用的数据格式,form-data和json的区别
- application/json: json格式文本
- application/x-www-form-urlencoded: 形如query参数(name=tom&age=12)的文本
- multipart/form-data: 文件上传



### 状态码
| 状态码 | 类别                             | 描述                   |
| ------ | -------------------------------- | ---------------------- |
| 1xx    | Informational（信息状态码）      | 接受请求正在处理       |
| 2xx    | Success（成功状态码）            | 请求正常处理完毕       |
| 3xx    | Redirection（重定向状态码）      | 需要附加操作已完成请求 |
| 4xx    | Client Error（客户端错误状态码） | 服务器无法处理请求     |
| 5xx    | Server Error（服务器错误状态码） | 服务器处理请求出错     |


### Http与Https的区别
* url
* 端口
* 安全性/加密
* 证书: HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书


### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。

可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。


### reflow repaint

#### Reflow

当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。

#### Repaint

当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。

#### 引起Repaint和Reflow的一些操作

- 调整窗口大小
- 字体大小
- 样式表变动
- 元素内容变化，尤其是输入控件
- CSS伪类激活，在用户交互过程中发生
- DOM操作，DOM元素增删、修改
- width, clientWidth, scrollTop等布局宽高的计算

#### Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：

- 避免逐条更改样式。建议集中修改样式，例如操作className。
- 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置display:none的元素上操作，最后显示出来。
- 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。
- 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流




## git操作

- git config --global credential.helper store (记住用户和密码)

- 分支操作
  ​	拉取远程新分支到本地
  ​	git pull (如果分支是在clone后创建的才需要执行)
  ​	git checkout -b dev origin/dev

- 版本注释一般规范
  feature 特性：新增功能
  docs 文档：新增文档
  fix 修复 Bug
- xiongjian分支到本地仓库xiongjian分支上
  git fetch origin xiongjian:xiongjian 拉取远程仓库

```bash
git checkout -b branchName

git add .

git commit -m 'xxx'

git checkout master

git merget branchName

git pull

git push
```





## webpack

#### 1. Webpack 基本概念

##### 1) entry 入口

- 以某个文件为入口开始打包
- 分类
  - 单入口 String 
    - 只会输出一个文件
  - 多入口 Array / Object
    - Array 只会输出一个文件
    - Object 会输出多个文件  ==> 多页应用(MPA)

##### 2) output 输出

- 打包后资源输出到哪里去
- 输出的文件名叫什么

##### 3) loader 加载器

- webpack 本身只能识别 json、js 模块，其他模块一旦加载就会报错
- 需要借助 loader 帮助 webpack 识别其它识别不了的模块

##### 4) plugins 插件

- loader 功能有限，要想做功能更加强大的工作交给插件
- 比如在页面中自动引入打包生成的js/css, 压缩css, 拷贝文件等

##### 5) mode

- 模式：开发环境（development）和生产环境（production）
- 提供一系列默认配置, 用于简化配置

#### 2. Webpack 基本配置

##### 1) 处理JS文件
- eslint-loader
  - 在package.json中配置eslintConfig来指示eslint-loader到底要干什么事
  - enfore: 'pre' 优先执行
- babel-loader
  - 在webpack配置中配置babel来指示babel-loader到底要干什么事
  - babel.config.js: 配置webpack的preset与plugin

##### 2) 处理Vue文件

- vue-loader

##### 3) 处理JSX文件 

- babel-loader
- presets: ['@babel/preset-react']

##### 4) 处理CSS文件

- 开发环境：创建style标签插入样式
  - style-loader
  - css-loader
  - postcss-loader
  - less-loader / sass-loader / stylus-loader
- 生产环境：提取单独css文件，将来通过link引入
  - MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）
  - css-loader
  - postcss-loader
  - less-loader / sass-loader / stylus-loader

##### 5) 处理HTML文件

- 目标: 自动引入打包生成的js/css
- html-webpack-plugin

##### 6. 处理图片/字体/音视频文件

- url-loader / file-loader
- limit: 10000 小于10kb一下的图片会被base64处理

#### 3. Webpack 优化手段

##### 1) 优化打包构建速度

##### HMR 热模块替换

- 为什么要用？
  - 默认情况下，一旦修改了代码，全部代码重新编译刷新，速度慢（全体刷新）
- 有什么作用？
  - 只更新修改的模块，其他模块不变（局部更新）  
- 怎么使用？
  - devServer: { hot: true }  
  - new webpack.HotModuleReplacementPlugin()  
- 注意：
  - 默认情况下只有样式文件有HMR功能（style-loader），JS是没有的
- 开启JS的HMR功能：
  - 手写JS代码 --> module.hot.accpet('模块路径', () => {})
  - 在Vue使用 --> vue-loader
  - 在React使用 --> react-hot-loader

#### 缓存

- eslint和babel两个任务处理JS文件，时间一般会比较长，为了让其重新构建速度更快, 可以使用缓存。
- eslint --> cache: true
- babel --> cacheDirectory: true
- cache-loader放置在要缓存loader的前面
- 注意：一般只针对耗时长的任务：eslint-loader/babel-loader/vue-loader

#### oneOf

- 作用：
  - 让模块只被一个loader处理，其他的就不看了(原本所有都会判断一下)
  - 能够提升打包速度
- 注意：
  - eslint-loader: 处理js, 需要先执行, 将其定义在oneOf的外面
  - babel-loader: 处理js, 后执行, 将其定义在oneOf的内部

#### 多进程打包

- 过去: happyPack
- 现在: thread-loader
- 用法和cache-loader差不多，放在要使用loader前面
- 作用：开启多进程处理前面的任务，提升打包速度
- 注意：每个进程开启和通信都有开销，一般只针对耗时长的任务：babel-loader

### 2) 优化打包代码体积和性能

#### 兼容性处理

- JS
  - ES6由二个部分
    - 新语法: const/let/箭头函数/解构赋值/对象简写 
    - 新API: Promise / 数组新方法/ 对象新方法
  - babel-loader presets: ['@babel/preset-env'] 问题就是只能编译语法, 不能处理新API
  - @babel/polyfill 做API兼容，问题是体积太大了
  - core-js3 在@babel/preset-env基础上，增加了useBuiltIns: 'usage'来实现按需加载
  - 指定浏览器版本或占有率配置, 进一步减小打包文件: 只打包使用了且浏览器没有实现的
- CSS  
  - postcss-loader 
  - 在package.json中指定browserslist来指示postcss-loader兼容性做到什么程度

#### tree shaking( 摇树)

- 去除没有使用的JS代码
- 必须使用ES6模块化（需要禁止@babel/preset-env转换ES6模块化语法 modules: false）
- 开启webpack的生产模式（内部启用TerserPlugin，用来压缩JS代码的插件，tree shaking功能就是这个插件完成的）
- 在package.json配置sideEffects来指定哪些文件需要进行tree shaking

#### code split 代码分割 / lazy loading 懒加载

- 作用：
  - 抽取公共代码 
  - 拆分多个文件，减少单个文件体积（避免单次请求时间过长）
- 配置：
  - 多入口 + optimization
    - 将node_modules抽取成单独模块
    - 将多入口的公共模块也抽取成单独模块
  - 单入口 + optimization + import
    - 将node_modules抽取成单独模块
    - 动态导入语法import就能将某些文件抽取成单独模块
  - import()动态引入模块
    - 原生 JS:  在需要的回调函数中动态加载模块, import(模块).then()
    - Vue: () => import('./Foo.vue'), 实现路由组件懒加载
    - React: Suspence +lazy(() => import('./SomeComponent')), 实现路由组件懒加载

#### preload 和 prefetch 预加载

- 作用：
  - 让资源提前加载
- 区别：
  - preload 让当前页面的要使用资源加载（延后加载）
  - prefetch 让后面要使用资源提前加载（当前不需要使用）
- 使用：
  - import(/*webpackChunkName: xxx webpackPrefetch: true */'./xxx')
  - import(/*webpackChunkName: xxx webpackPreload: true */'./xxx') // 没有效果
  - 问题：兼容性较差 
- 使用Chrome团队提供的一个工具包: preload-webpack-plugin
  - npm i -D preload-webpack-plugin@next  // 必须是最新的下一个版本
  - 对异步模块包使用: prefetch
  - 对同步模块包使用: preload

#### 浏览器cache/缓存

- hash 
  - webpack每次构建都会生成一个新的且唯一的hash
  - 问题：只要webpack重新构建，所有文件的hash都会发生变化，缓存就会失效

- chunkhash
  - 打包属于同一个chunk，就共享同一个hash
  - 问题：样式文件被css-loader打包js文件中，导致样式文件和js文件属于同一个chunk，共享同一个hash
  - 一旦样式文件发生变化，js文件也会变

- contenthash
  - 根据文件的内容来成hash，所以只要文件内容不一样，hash就不一样
  - 问题：
    - 比如A模块有一个依赖，是B模块，那么A模块内部就会保存B模块hash值，
    - 一旦B模块发生变化，B模块的hash值就会变，导致A模块内部保存B模块hash值也发生改变
    - 此时A模块文件内容发生变化，它的hash值也会变
  - 解决：
    - runtimechunk: true 将A模块保存的B模块hash值存到runtime文件中，这样A模块内部就没有B模块的hash值了，就不会因为B模块的修改而修改



### 基础

- entry 入口
  指示 webpack 从哪个文件开始打包

- output 输出
  指示 webpack 将打包后的文件输出到哪里去

- loader 加载器
  帮助 webpack 解析它解析不了的模块（将其他模块解析成 webpack 能识别的模块，这样才能打包）

  还有其他功能：多进程打包...

- plugin 插件
  能够功能更加强大的事
  将现有库包装成 webpack 能够识别的功能模块，从而加载使用

- mode 模式
  模式（development/production）
  区别：设置不同 NODE_ENV，启用不同的插件

### 其他配置

- resolve 解析：帮助 webpack 解析模块

  alias 配置路径别名

  extensions 配置自动补全文件扩展名

  modules 配置 引入 node_modules 库，node_modules 文件夹去哪找

- optimization 优化

- devServer 开发服务器

### 兼容性处理

- JS 兼容性处理 babel
- CSS 兼容性处理，使用 postcss-loader 做 css 兼容性处理

### 摇树（**tree shaking**）

- 摇树：去除无用的 JS 代码

- 配置

  必须使用 ES6 模块化

  开启 mode: production

### 缓存

- 客户端端缓存服务器请求的资源（js/css/图片...）

  - 强制缓存（不会重新访问服务器，直接读取缓存）

    问题：如果资源在缓存期间内，是没办法更新的~

  - 协商缓存（每次都会重新访问服务器，由服务器来决定要不要走缓存，304）

- hash webpack 打包生成的，所以资源共享 hash 值

  问题：如果改动一个资源，所有资源的 hash 都变~导致其他资源缓存失效

- chunkhash 属于同一个 chunk，hash 值一样，不同 chunk，hash 值不一样

  问题：单入口样式文件因为 css-loader，会把样式文件打包到 js 中，此时就会和 js 共享同一个 hash 值，一旦改动 js/css 文件，css/js 文件缓存失效

- contenthash 根据文件内容来生成 hash，不同文件 hash 值不同

  新问题：如果 A 文件采用 import 进行代码分割文件 B，分割文件 B 一旦变化，那么 A 文件缓存失效

  原因是：A 文件保存 B 文件的 hash 值，一旦 B 文件变化，A 文件的 hash 值也要更新，从而导致 A 文件也变了

  解决：需要将 A 文件保存 B 文件的 hash 值单独提取出来，成单独文件，这样就不会影响 A 文件了

  ```js
  runtimeChunk: {
    name: (entry) => `runtime-${entry.name}.js`;
  }
  ```

### 关闭map(vue项目生产环境)

productionSourceMap: false, // 关闭map映射文件



### 实际使用
#### require.context
```javascript
//store/index.js

const moduleFIles = require.context('./modules', true, /\.js$/)
const modules = moduleFiles.keys().reduce((modules, modulePath) => {
  let moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
  //处理多层文件
  if (moduleName.includes('/')) {
    let moduleNameParts = moduleName.split('/')
    for (let idx=1,len=moduleNameParts.length; idx<len; idx++) {
      const item = moduleNameParts[idx]
      moduleNameParts[idx] = item.slice(0, 1).toUpperCase() + item.slice(1)
    }
    moduleName = moduleNamePargs.join('')
  }
  const value = modulesFiles(modulePath)
  modules[moduleName] = value.default
  return modules
}, {})
```



## Vue 基础
### 面试题资源
> https://vue3js.cn/interview/
> https://juejin.cn/post/6844903918753808398
> https://www.cnblogs.com/wenshaochang123/p/14888494.html


### 什么是MVVM
是一种用于设计用户界面的软件架构模式，它是一种将应用程序 UI 与后端数据及逻辑分离的模式。

MVVM 模式由以下三个组件构成：
Model（模型）：管理数据和应用程序的状态。通常包含数据库操作、网络请求和与业务数据相关的逻辑。

View（视图）：负责显示用户界面和接收用户输入。View 通过 ViewModel 处理数据，维持用户界面的状态。

ViewModel（视图模型）：是视图（View）和模型（Model）之间的中间件，负责连接二者、协调二者之间的通信，以及处理与用户所有交互的逻辑，例如数据的格式化和验证、数据的分页、排序及筛选等等。


### 说说你对 SPA 单页面的理解，它的优缺点分别是什么？
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
**优点：**
* 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
* 基于上面一点，SPA 相对对服务器压力小；
* 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**
* 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
* 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
* SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。


### 怎么实现vm

1.需要利用Object.defineProperty，将要观察的对象，转化成getter/setter，以便拦截对象赋值与取值操作.也就是<u>数据观察者</u><span style="color:blue">Observer</span>；

2.将DOM解析，提取其中的指令与占位符，并赋与不同的操作. 也就是<u>指令解析器</u><span style="color:blue">Compile</span>

3.需要将Compile的解析结果，与Observer所观察的对象连接起来，在Observer观察到对象数据变化时，接收通知，同时更新DOM. 也就是<u>订阅者</u><span style="color:blue">Watcher</span>，它是Observer和Compile之间通信的桥梁；

4.最后，需要一个公共入口对象，接收配置，协调上述三者，称为vm，也就是Vue;

### Vue响应式

Vue响应式指的是：组件的data发生变化，立刻触发视图的更新 

实现原理： Vue 采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。

### Vue数据流
1. Vue也是一个单向数据流的框架
2. Vue通过指令实现了双向数据绑定： v-model
3. v-model都做了哪些事情; `<input v-model='msg' />`
   1. 将指定变量的数据赋值给input的value
   2. 给当前的表单项自动绑定一个input事件，监听View层表单项数据发生改变获取最新value的同时更新Model的数据

### Vue单向数据流
* 父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
* 每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

**两种常见的更改Prop的情况**
* prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：
```vue
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```
* 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性
```vue
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

### 虚拟 DOM 实现原理？
虚拟 DOM 的实现原理主要包括以下 3 部分：

用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
diff 算法 — 比较两棵虚拟 DOM 树的差异；
pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589#heading-14)》




### 虚拟DOM优缺点
优点：

保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

缺点:
无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。


### 组件间通信的方式

#### 根据通信的2个组件间的关系来选择一种通信方式

```
父子
	props
	vue自定义事件
	v-model
	.sync
	$refs, $children与$parent
	插槽 ==> 作用域插槽
祖孙
	$attrs与$listeners
	provide与inject
兄弟或其它/任意
	全局事件总线
	Vuex
```



#### 方式1: props 

```
1). 实现父向子通信: 属性值是非函数
2). 实现子向父通信: 属性值是函数
应用: 最基本, 用得最多的方式
```



#### 方式2: vue自定义事件

```
1). 用来实现子组件向父组件通信
2). 相关语法:
    父组件中给子组件绑定自定义事件监听:
      <Child @eventName="callback">
    子组件中分发事件
      this.$emit('eventName', data)
应用: elment-ui的组件的事件监听语法都用的是自定义事件
      我们项目中的组件也用了不少自定义事件
```



#### 方式3: 全局事件总线   ===> 消息订阅与发布

```
1). 实现任意组件间通信
2). 编码:
    将入口js中的vm作为全局事件总线对象: 
        beforeCreate() {
            Vue.prototype.$bus = this
        }
    分发事件/传递数据的组件: this.$bus.$emit('eventName', data)
    处理事件/接收数据的组件: this.$bus.$on('eventName', (data) => {})
应用: 前台项目中使用全局事件总线
```

#### 方式4: v-model

    1). 实现父子之间相互通信/同步
    2). 组件标签上的v-model的本质: 自定义input监听来接收子组件分发$emit的数据更新父组件数据
        父组件: 
            <CustomInput v-model="name"/>
            <!-- 等价于 -->
            <CustomInput :value="name" @input="name=$event"/>
        子组件: 
            <input type="text" :value="value" @input="$emit('input', $event.target.value)">
            props: ['value']
    应用: element-ui中的表单项相关组件都用了v-model: Input / Select / Checkbox / Radio

#### 方式5: .sync

    1). 实现父子之间相互通信/同步(在原本父向子的基础上增加子向父)
    2). 组件标签的属性上使用.sync的本质: 事件监听来接收子组件分发$emit过来的数据并更新父组件的数据
        父组件:
            <child :money.sync="total"/>
            <!-- 等价于 -->
            <Child :money="total" @update:money="total=$event"/>
    
            data () {
              return {
                total: 1000
              }
            },
        子组件:
            <button @click="$emit('update:money', money-100)">花钱</button>
            props: ['money']
    应用:  
        element-ui在有显示隐藏的组件上: Dialog / Drawer

#### 方式6: `$attrs`与$listeners

    1). $attrs
        //实现当前组件的父组件向当前组件的子组件通信
        父组件传递给子组件的属性,除了props已经声明接收的属性及父组件的style,class属性.
        它是包含所有父组件传入的标签属性(排除props声明, class与style的属性)的对象
        使用: 通过 v-bind="$attrs" 将父组件传入的n个属性数据传递给当前组件的子组件
    2). $listeners
        实现当前组件的子组件向当前组件的父组件通信
        $listeners是包含所有父组件传入的自定义事件监听名与对应回调函数的对象
        使用: 通过v-on="$listeners" 将父组件绑定给当前组件的事件监听绑定给当前组件的子组件
    应用: 利用它封装了一个自定义的带hover文本提示的el-button

#### 方式7: $refs & $children & $parent

    1). $refs
        实现父组件向指定子组件通信
        $refs是包含所有有ref属性的标签对象或组件对象的容器对象
        使用: 通过 this.$refs.child 得到子组件对象, 从而可以直接更新其数据或调用其方法更新数据
    2). $children
        实现父组件向多个子组件通信
        $children是所有直接子组件对象的数组
        使用: 通过this.$children 遍历子组件对象, 从而可以更新多个子组件的数据
    3). $parent
        实现子组件向父组件通信
        $parent是当前组件的父组件对象
        使用: 通过this.$parent 得到父组件对象, 从而可以更新父组件的数据
    应用: 在后台管理项目中使用了$refs

#### 方式8: provide与inject

	1). 实现祖孙组件间直接通信
	2). 使用
		在祖组件中通过provide配置向后代组件提供数据
		在后代组件中通过inject配置来声明接收数据
	3). 注意:
		不太建议在应用开发中使用, 一般用来封装vue插件
		provide提供的数据本身不是响应式的 ==> 父组件更新了数据, 后代组件不会变化
		provide提供的数据对象内部是响应式的 ==> 父组件更新了数据, 后代组件也会变化
	应用: element-ui中的Form组件中使用了provide和inject



#### 方式9: vuex

- vuex用来统一管理多个组件共享的状态数据

- 任意要进行通信的2个组件利用vuex就可以实现

  A组件触发action或mutation调用, 将数据保存到vuex的状态中

  B组件读取vuex中的state或getters数据, 得到最新保存的数据进行显示
  
- 面试题

  1. mutation负责同步修改状态数据的，能不能异步修改

     可以异步修改

     如果异步修改的话会导致Vuex的调试工具失效，无法检测异步修改数据

  2. 设计的时候为什么建议mutation同步修改状态数据，而新增action负责异步

     Vuex的作用是给多个组件共享数据

     如果支持mutation异步修改数据，又因为异步的特性，会导致store对象中state数据发生错乱甚至是报错

     为了数据的安全

  3. Vuex刷新页面，数据丢失问题
```md
 //数据丢失原因
1.	Vuex数据保存在运行内存中，vue实例初始化的时候为其分配内存
2.	当刷新页面的时候重新初始化Vue实例，所以重新为Vuex分配内存导致之前保存的数据丢失

   //如何解决?
1.	Vuex的数据都是每次组件加载时候动态请求获取数据保存
a)	优点： 保证数据不会丢失
b)	缺点: 性能差，因为网络问题可能有网络延迟

2.	将Vuex中的数据每次同步更新保存到sessionStorage中
a)	优点: 每次页面刷新后从sessionStorage中获取保存的数据，不会丢失
b)	缺点: state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差

3.	在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取
a)	优点: 减少动态更新sessionStorage的次数，性能好
b)	重点: 给window绑定beforeupload事件监听

4.插件
使用持久化插件：可以使用Vuex持久化插件如vuex-persistedstate或vuex-along来将Vuex存储在浏览器的localStorage或cookie中，以便在刷新页面时保留数据状态。
```



```js
//绑定事件监听: 在页面卸载(关闭)或刷新时候保存当前数据
// beforeunload 页面即将刷新之前调用
window.addEventListener('beforeupload', () => {
    sessionStorage.setItem('test2', JSON.stringify(this.personArr))
})
// 读取sessionStorage中是否有之前缓存的数据
let personArr = sessionStorage.getItem('test2')
// 如果有： 更新Vuex中状态数据
personArr && this.changePersonArrMutation(JSON.parse(personArr))
```









#### 方式10:  插槽  ==> 作用域插槽slot-scope

    1). 实现父组件向子组件传递标签内容
    2). 什么情况下使用作用域插槽?
        父组件需要向子组件传递标签结构内容
        但决定父组件传递怎样标签结构的数据在子组件中
    3). 编码:
        子组件:
            <slot :row="item" :$index="index">  <!-- slot的属性会自动传递给父组件 -->
            </slot>
        父组件:
            <template slot-scope="{row, $index}">
                <span>{{$index+1}}</span> &nbsp;&nbsp;
                <span :style="{color: $index%2===1 ? 'blue' : 'green'}" >{{row.text}}</span>
            </template>
    应用: element-ui中的Table组件


### computed与method和watch的区别

- **computed** 
  1. 支持缓存，多次读取, 只会执行一次计算, 只有依赖数据发生改变，才会重新进行计算 
  2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
  3. 底层用到的是对象set和get方法: 简写为函数形式,就是get方法;完整写法为对象,get+set方法;
     1. setter和getter中的this上下文自动绑定为Vue实例;如果使用箭头函数形式, 可以将实例作为第一个参数
  4. 执行时机: 初始化时; 当依赖数据发生变化时;

- **method**
  - 没有缓存, 多次读取, 必须多次调用

- **watch**
  1. watch支持异步；
  2. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
  3. 当一个属性发生变化时，需要执行对应的操作；一对多；
  4. 监听数据必须是一个响应式数据(data/props/computed)

  　　immediate：组件加载立即触发回调函数执行，

  　　deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变


### Vue 列表为什么加 key？

比如有很多li元素，要在某个位置插入一个li元素，但没有给li上加key，那么在进行运算的时候，就会将所有li元素重新渲染一遍，但是如果有key，那么它就会按照key一一比对li元素，只需要创建新的li元素，插入即可，不需要对其他元素进行修改和重新渲染。 

key也不能是li元素的index，因为假设我们给数组前插入一个新元素，它的下标是0，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了

### Class 与 Style 如何动态绑定？
Class 可以通过对象语法和数组语法进行动态绑定：

对象语法：
```vue
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
data: {
  isActive: true,
  hasError: false
}
```
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>

数组语法：
```vue
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>


data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```


Style也可以通过对象语法和数组语法进行动态绑定：

对象语法：
```vue
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>


data: {
  activeColor: 'red',
  fontSize: 30
}
```
数组语法：
```vue
<div v-bind:style="[styleColor, styleSize]"></div>

data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}
```





### Vue 中 $nextTick 作用与原理？

Vue 在更新 DOM 时是异步执行的，在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。

所以修改完数据，立即在方法中获取DOM，获取的仍然是未修改的DOM。 $nextTick`的作用是：该方法中的代码会在当前渲染完成后执行，就解决了异步渲染获取不到更新后DOM的问题了。 ``$nextTick的原理：`$nextTick`本质是返回一个Promise

应用场景：在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中


### 直接给一个数组项赋值，Vue 能检测到变化吗？
由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：
* 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
* 当你修改数组的长度时，例如：`vm.items.length = newLength`

为了解决第一个问题，Vue 提供了以下操作方法：
```js
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```
为了解决第二个问题，Vue 提供了以下操作方法：
```js
// Array.prototype.splice
vm.items.splice(newLength)
```


### vfor与vif同时使用的问题?

> 在官方文档中明确指出**v-for和v-if不建议一起使用**。 原因：v-for比v-if优先级高，所以使用的话，每次v-for都会执行v-if,造成不必要的计算，影响性能，尤其是当之需要渲染很小一部分的时候。

`v-for` 和 `v-if` 同时使用有 3 种情景：

1. 部分遍历（内/外部条件）：一个 `list` 中某个属性值符合条件的遍历出来；
2. 全部遍历（外部条件）：某外部条件符合条件时遍历全部。
3. 全部遍历（内部条件）：根据某内部条件渲染出不同的内容。

#### 解决方案:

##### 使用计算属性

> 在计算属性中先用内/外部条件处理数据，再遍历处理后的数据

```javascript
<!-- 遍历list，条件是值小于100 方案：使用计算属性activeList首先筛选出符合条件的值再直接遍历 -->
<ul>
  <li v-for="item in activeList" :key="item"></li>
</ul>

export default {
  data() {
    return {
      list: [78, 90, 20, 45, 66, 120, 136]
    }
  },
  computed: {
    activeList() {
      return this.list.filter((item) => item < 100)
    }
  }
}
```



##### 条件放于父元素(外部条件)

> 解决方案：外部条件放到遍历的父级元素上，没有父级可以使用`<template></template>`。

```html
<ul v-if="isActive">
  <li v-for="item in list" :key="item"></li>
</ul>
<!-- or -->
<div>
  <template v-if="isActive">
    <span v-for="item in list" :key="item"></span>
  </template>
  <p>Hello,My name is Lillian!</p>
</div>

<script>
export default {
  data() {
    return {
      isActive: true,
      list: [78, 90, 20, 45, 66, 120, 136]
    }
  }
}
</script>
```



##### 遍历`template`(内部条件)

> 根据某内部条件，显示不同内容。注意 `key` 不能放 `template` 标签上

```html
<div>
  <template v-for="item in list">
    <span v-if="item.type===0" :key="item.id">文字+图标</span>
    <span v-if="item.type===1" :key="item.id">文字+文字</span>
    <span v-else :key="item.id">其他</span>
  </template>
</div>
```

`vue` 中会优先执行 `v-for`, 当 `v-for` 把所有内容全部遍历之后 , `v-if` 再对已经遍历的元素进行删除 , 造成了加载的浪费 , 所以应该尽量在执行 `v-for` 之前优先执行 `v-if` , 可以减少加载的压力。







### 为什么组件中的data必须是函数形式？

- Vue解析组件标签时，会创建一个新的组件实例对象
- 每个组件实例对象, 都需要有自己的data数据对象
- 如果data配置是对象, 就会导致同个组件的多个实例共享一个data对象
- 如果data是函数, 组件的多个实例的data对象是各自的, 是多份



### 如何理解vue的渐进式

![](https://img-blog.csdn.net/201806191038393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6dW5rdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



所谓的渐进式框架,就是把框架分层.

最核心的部分是视图层渲染,然后往外是组件机制,在这个基础上再加入路由机制,再加入状态管理,最外层是构建工具.

所谓分层,就是说你既可以只用最核心的视图层渲染功能来快速开发一些需求,也可以使用一整套全家桶来开发大型应用.




### Vue实例的生命周期

#### 是什么

> 每个 Vue 实例在被创建时都要经过一系列的初始化过程, 这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同阶段添加自己的代码的机会


#### Vue生命周期说明

* 有什么
* 三个阶段
  * 挂载阶段=>beforeCreate、created、beforeMounted、mounted
  * 更新阶段=>beforeUpdate、updated
  * 销毁阶段 beforeDestroy、destroyed
* 每个阶段适合干什么
  * created：实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求
  * 页面的初始化 beforeMount 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 
  * mounted：实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求
  * beforeupdate：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 
  * updated：虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作避免在这个钩子函数中操作数据，可能陷入死循环 
  * beforeDestroy：实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例，常用于销毁定时器、解绑全局事件、销毁插件对象等操作

| 生命周期钩子    | 说明                                                         | 对应上述步骤   |
| --------------- | ------------------------------------------------------------ | -------------- |
| `beforeCreate`  | 初始化实例前，`data`、`methods`等不可获取                    | 1 之后，2 之前 |
| `created`       | 实例初始化完成，此时可获取`data`里数据和`methods`事件，无法获取 DOM | 2 之后，3 之前 |
| `beforeMount`   | 虚拟 DOM 创建完成，此时未挂载到页面中，`vm.$el`可获取未挂载模板 | 3 之后，4 之前 |
| `mounted`       | 数据绑定完成，真实 DOM 已挂载到页面，`vm.$el`可获取真实 DOM  | 4 之后         |
| `beforeUpdate`  | 数据更新，DOM Diff 得到差异，未更新到页面                    | 5 之后，6 之前 |
| `updated`       | 数据更新，页面也已更新                                       | 6 之后         |
| `beforeDestroy` | 实例销毁前                                                   | 7 之前         |
| `destroyed`     | 实例销毁完成                                                 | 7 之后         |



#### 重要生命周期函数（开发中常用） 

- **created / mounted** 

  发送AJAX请求、设置定时器等一次性任务

  created速度更快

- **beforeDestroy** 

  做一些收尾工作：取消AJAX请求，清除定时器等

#### 周期函数补充

- 动态组件

  `<component :is="comName"></component>`  is属性来切换不同的组件

  正常传入props数据就可以接受到

- 缓存组件

  ```vue
  <keep-alive :include="['a','b']>
    <component :is="view"></component>
  </keep-alive>
  ```

- **errorCaptured(errObj, errVM, errMsg)**

  捕获一个来自子孙组件的错误时被调用

  return false // 阻止错误继续向上传播，并且不会在浏览器控制台抛出错误

  参数：错误对象，抛出错误的实例，错误信息



动态`<component>`案例

```vue
// src/comopnents/baseComponents/baseForm/index.vue

<template>
	<div @clik.stop>
    <component
    	:is="componentId"
      v-bind="$attrs"
      @click="(param) => this.$emit('click', param)"
    ></component>
  </div>
</template>


<script>
	import baseInput from "./baseInput"
  import baseSelect from "./baseSelectCustom"; // 定制版
  import baseTime from "./baseTime";
  import baseCheck from "./baseCheck";
  import baseJudge from "./baseJudge";
  import baseupload from "./baseupload";
  import baseSelectQuery from "./baseSelectQuery";
  import baseSelectQuery_two from "./baseFromMask_two";
  import baseSearchShll from "./baseSearchShll";
  import baseCheckTwo from "./basecheckTwo";
  import baseTime_two from "./baseTime_two";
  import baseCheckthree from "./baseCheckthree";
  import baseInputTwo from "./baseInputTwo";
  import baseuploadMetering from "./baseuploadMetering";
  import baseInputSelects from "./baseInputSelects";
  import basejudeFlag from "./basejudeFlag"
  import basePopup from "./baseInputpopup";
  import baseInforSearchShll from "./baseInforSearchShll";
  import baseTimeashdas from "./baseTimeashdas";
  import baseJudges from "./baseJudges";
  import baseJudgetb from "./baseJudgetb";
  
  export default {
    name: 'baseFrom',
    components: {
      baseInput,
      baseSelect,
      baseTime,
      baseCheck,
      baseJudge,
      baseupload,
      baseSelectQuery,
      baseSelectQuery_two,
      baseSearchShll,
      baseCheckTwo,
      baseTime_two,
      baseCheckthree,
      baseInputTwo, 
      baseuploadMetering,
      baseInputSelects,
      basejudeFlag,
      basePopup,
      baseInforSearchShll,
      baseTimeashdas,
      baseJudges,
      baseJudgetb,
    },
    props: {
      type: {type:String, default: '1'}
    },
    computed: {
      componentId() {
        return [
          "baseInput",//ok
          "baseSelect",//ok
          "baseTime",//ok
          "baseCheck",//ok
          "baseJudge",//ok
          "baseupload",//该组件默认不可修改
          "baseSelectQuery",//ok
          "baseSelectQuery_two",//
          "baseSearchShll",//9
          "baseCheckTwo",//ok
          "baseTime_two",//ok
          "baseCheckthree",//ok
          "baseInputTwo", //13ok
          "baseuploadMetering", // 14
          "baseInputSelects",//15
          "basejudeFlag",//16
          "basePopup",
          'baseInforSearchShll',//18ok
          'baseTimeashdas',//19ok
          'baseJudges',//20ok
          'baseJudgetb',//21ok
        ][this.type - 1];
      }
    }
  }
</script>
```



```vue
// 其他组件调用baseForm

<!-- 发电用户普查 -->
<article class="publicData" v-show="powerUsers">
  <template v-for="(item, index) in publicEntryList">
	<baseFrom
          v-if="[19].indexOf(index) != -1"
          :key="index"
          v-bind="item"
          v-model="publicEntryList[index]"
          @click="entryList($event, item, index)"
          />
  </template>
</article>
```



##### 在缓存组件的基础上存在的声明周期

- **activated()**

  每次缓存组件被激活时就会调用

- **deactivated()**

  缓存的组件停用时调用，可替代destroyed



#### 父子组件生命周期

加载渲染过程

父 beforeCreate -> 父 created -> <span style="color:blue">父 beforeMount -></span><span style="color:red"> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted </span>-> <span style="color:blue">父 mounted</span>

子组件更新过程

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

父组件更新过程

父 beforeUpdate -> 父 updated

销毁过程

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed


#### 父组件可以监听到子组件的生命周期吗？
比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：
```ts
// Parent.vue
<Child @mounted="doSomething"/>
    
// Child.vue
mounted() {
  this.$emit("mounted");
}
```

以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：
```ts
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...  
```
当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。



### keep-alive
keep-alive是vue的内置组件，能在组件切换过程中将状态保留在内存中，相当于缓存，防止DOM的重复渲染；
* keep-alive有三个属性：include（只有名字匹配的才会被缓存）、exclude（任何名字匹配的都不会被缓存）、max（最多可以缓存多少个组件）。
* 一般结合路由和动态组件一起使用，用于缓存组件；
* 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
* 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。


### v-model 的原理？
我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
* text 和 textarea 元素使用 value 属性和 input 事件；
* checkbox 和 radio 使用 checked 属性和 change 事件；
* select 字段将 value 作为 prop 并将 change 作为事件。
以 input 表单元素为例：
```vue
<input v-model='something'>
    
//相当于
<input v-bind:value="something" v-on:input="something = $event.target.value">
```
如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：
```js
父组件：
<ModelChild v-model="message"></ModelChild>

子组件：
<div>{{value}}</div>

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
}
```




### Vue-router

#### vue-router 路由模式有几种？
vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：
```js
switch (mode) {
  case 'history':
	this.history = new HTML5History(this, options.base)
	break
  case 'hash':
	this.history = new HashHistory(this, options.base, this.fallback)
	break
  case 'abstract':
	this.history = new AbstractHistory(this, options.base)
	break
  default:
	if (process.env.NODE_ENV !== 'production') {
	  assert(false, `invalid mode: ${mode}`)
	}
}
```
其中，3 种路由模式的说明如下：
* hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；
* history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；
* abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.


#### vue-router 中常用的 hash 和 history 路由模式实现原理
**hash 模式的实现原理**
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：
```awk
https://www.word.com#search
```

hash  路由模式的实现主要是基于下面几个特性：

* URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
* hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
* 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
* 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。


**history 模式的实现原理**
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
```js
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
```
history 路由模式的实现主要基于存在下面几个特性：
* pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
* 我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；
* history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。


#### 重载组件,页面没有变化的解决方法

当从 C 组件切换到 C 组件（只更新参数的时候），C 组件并不会被重新创建或卸载，而是复用之前 C 组件，这样会导致只有路由变化，页面没有发生变化

<span style="color:red;">解决方案</span> 3种
* watch
* beforeRouteUpate
* router key

##### watch

​	使用watch进行监视，因为每次更新时，$route都会创建一个新对象 ，而不是原对象，所以所有数据都是新的，可以监视

```js
watch: {
  $route(to, from) {
    // to 变化前的路由对象
    // from 变化后的路由对象
  }, 
}

//项目中使用
search页面改变参数，无法重复发请求的问题
watch: {
    $route(newVal, oldval) {
      this.handlerSearchParams();
      this.getSearchInfo();
    },
  },
```



##### beforeRouteUpdate

```javascript
beforeRouteUpdate(to, from, next) {
  
}
```



##### router key

> https://mp.weixin.qq.com/s/0Yekkc08ozbNxuquHVGveg

```html
<router-view v-bind:key="$route.fullpath"></router-view>
```



#### history模式刷新404问题解决方法

通过配置webpack来解决：在devServer中加 historyApiFallback: true

index.html 需要将 href="./bootstrap.css" 改成 href="/bootstrap.css"

webpack.config.js 需要output上增加 publicPath: '/'



#### 命名路由的时候params和query分别可以和什么搭配使用

query + name

query + path

params + name  (怎么记忆, 都有am)



#### **路由传参**

1. query
   传参方式：

       1. 注册的路由的时候不需要做任何事情
       2. 请求的时候通过path?key=value&key2=value2
        
       query参数无需声明即可接收,接收通过计算属性this.$route.query

   获取:  $route.query.key

   使用场景：适合多个参数
   
2. params

   传参方式:

   1. 注册路由的时候需要声明占位符，{path: '路由路径/:key(占位符)'}
   2. 请求的时候通过 path/params参数

   获取:  $route.params.key

   使用场景：

   1. 通常只有一个参数的时候(也可以指定多个params参数)
   2. 该参数通常是一个标识id

3. meta

   传参方式:

   1. 注册的时候通过meta字段进行参数设置

   获取:  $route.meta.key

   使用场景：

   1. 路由元信息，用于描述当前的路由信息
   2. 可以自定义参数内容的时候(可以有多个)

4. props

   传参方式:

   1. 布尔值(只能搭配params参数使用)
   2. 对象(用于自定义参数)
   3. 函数(自定义参数 + 路由信息)

   获取:  在组件内部通过props接收获取

   使用场景：用来解耦$route和组件实例的耦合度


#### $router VS $route的区别

1. $router

   路由器对象

   用来控制路由的跳转，包含相关方法: push()/replace()/back()/addRoutes()

2. $route

   路由信息对象

   包含当前路由的所有信息(path, query, params, meta)





### 导航守卫（路由守卫）

#### 全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // 使用场景： 验证用户身份，判断用户是否登录
  if(isLogin){ // 如果登录，正常跳转至home
    next()
  }else { // 如果未登录就跳转至登录界面
    if(to.path === '/login'){
      next()
    }else {
      next('/login')
    }
  }
})
```

#### 全局解析守卫

- 这和 `router.beforeEach` 类似，区别是在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后**，解析守卫就被调用。

```js
router.beforeResolve((to, from, next) => {
  // 负责解析路由地址，加载对应的路由组件
})
```

#### 全局后置钩子

```js
router.afterEach((to, from) => {
  // 路由完全跳转后执行
})
```

#### 组件内的守卫

```js
beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
    // 因为当守卫执行前，组件实例还没被创建
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
},
beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
},
beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
}
```



#### 路由守卫

```js

```



### 完整导航解析流程

1. 导航被触发。
2. 在失活的组件里调用组件后置守卫 `beforeRouteLeave` 。
3. 调用全局前置守卫 `beforeEach` 。
4. 在重用的组件里调用 组件解析守卫`beforeRouteUpdate`  (2.2+)。
5. 在路由配置里调用路由前置守卫 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用组件前置守卫 `beforeRouteEnter`。
8. 调用全局解析守卫 `beforeResolve` (2.5+)。
9. 导航被确认。
10. 调用全局后置守卫 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用组件前置守卫 `beforeRouteEnter` 中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。



#### 触发钩子的完整顺序

> https://www.yuque.com/cuggz/interview/hswu8g#2c3f563ad7506984575f1a323937c5c0

路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件

- beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。
- beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。
- beforeEnter：路由独享守卫
- beforeRouteEnter：路由组件的组件进入路由前钩子。
- beforeResolve：路由全局解析守卫
- <u>afterEach：路由全局后置钩子</u>
- beforeCreate：组件生命周期，不能访问this。
- created;组件生命周期，可以访问this，不能访问dom。
- beforeMount：组件生命周期
- <u>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</u>
- mounted：访问/操作dom。
- <u>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</u>
- 执行beforeRouteEnter回调函数next。




### 路由懒加载

引入路由时，动态引入，代码分割，异步加载，例：

```js
const Home = () => import('../components/Home/Home')
```

import函数不是webpack提供的语法。是es6语法

### Vue.use
1. 自定义Vue插件需要向外暴露对象或者是函数
2. 如果向外暴露对象的话，对象中必须有install方法
3. 如果向外暴露的是函数的话，那么该函数本身就是install方法
4. 当Vue.use()的时候，会自动调用install方法，并且将Vue对象作为实参传入到install方法中


#### 父子组件的生命周期

```js
子组件初始化: 在父组件beforeMount-->mounted之间 执行beforeCreated->mounted4个钩子
子组件更新: 在父组件beforeUpdate->updated之间 执行2个钩子
子组件死亡: 在父组件beforeDestroy->destroyed之间 执行2个钩子
```

- 初始化:
  - beforeCreate
  - created
  - beforeMount
  - *--child beforeCreate*
  - *--child created*
  - *--child beforeMount*
  - *--child mounted*
  - mounted
- 更新:
  - beforeUpdate
  - *--child beforeUpdate*
  - *--child updated*
  - updated
- 死亡:
  - beforeDestroy
  - *-- child beforeDestroy*
  - *-- child destroyed*
  - destroyed

#### 3) 带缓存的路由组件生命周期keep-alive

```js
路由组件添加<keep-alive></keep-alive>之后,在mounted之后会出现activated
总结:路由组件生命钩子activated是在挂在mounted之后.离开的路由组件生命周期钩子deactivated是在进入的路由组件生命钩子mounted之前调用

(路由组件,activated是在自身mounted之后;deactivated是在进入其他路由组件mounted之前调用)
当前组件激活总是最后一个

 同级路由组件:离开一个进入一个 ++表示进入的路由组件,没有加的表示离开的路由组件
++beforeCreate
++created
++beforeMount
 deactivated
++mounted
++activated
```



- 初始化:
  - ...
  - mounted
  - *--Child activated*
  - activated
- 路由离开
  - *--Child deactivated*
  - deactivated
- 路由回来
  - *--Child activated*
  - activated

#### 4) 捕获子组件错误的勾子

- 子组件执行抛出错误
  - errorCaptured

```js
父组件中调用这个钩子:
errorCaptured(err,child,info){
    console.log('errorCaptured')
    console.log(err,child,info)  //打印的错误是灰色的
    return false;//不再向外传递,说明当前已经处理了错误
}
```



#### 5) 各个生命周期勾子说明

![vue组件生命周期详图.png](https://i.loli.net/2021/04/03/t4AIhPlnpNe8i9d.png)

(1) beforeCreate(): 在实例初始化之后调用, data和methods都还没有初始化完成, 通过this不能访问

初始化data与methods/computed

(2) created(): 此时data和methods都已初始化完成, 可以通过this去操作, 可以在此发ajax请求

编译模板

(3) beforeMount(): 模板已经在内存中编译, 但还没有挂载到页面上, 不能通过ref找到对应的标签对象

插入到界面上显示

(4) mounted(): 页面已经初始显示, 可以通过ref找到对应的标签, 也可以选择此时发ajax请求



n次更新数据

(5) beforeUpdate(): 在数据更新之后, 界面更新前调用, 只能访问到原有的界面

更新界面

(6) updated(): 在界面更新之后调用, 此时可以访问最新的界面



**销毁组件/ v-if隐藏/离开不缓存的路由组件**

(7) beforeDestroy(): 实例销毁之前调用, 此时实例仍然可以正常工作

(8) destroyed(): Vue 实例销毁后调用, 实例已经无法正常工作了



(9) deactivated():组件失活, 但没有死亡

(10) activated(): 组件激活, 被复用

(11) errorCaptured(): 用于捕获子组件的错误,return false可以阻止错误向上冒泡(传递)





### Vue组件间多种通信方式

#### 1) 组件间通信方式列表

```
1) props
2) vue自定义事件
3) 全局事件总线
4) v-model
5) .sync 
6) $attrs与$listeners
7) $refs, $children与$parent
8) provide与inject
9) Vuex
10) 插槽 ==> 作用域插槽
```

#### 2) 通信方式的选择

```js
//父子
	props: 
		父向子
		子向父
	vue自定义事件: 
		子向父
	v-model: 
		父子之间
	.sync: 
		在父向子的基础上添加子向父
	$refs, $children与$parent: 
		$refs/$children: 父向子
		$parent: 子向父
	插槽 ==> 作用域插槽
		默认插槽/具名插槽: 父组件向子组件传递标签内容
		作用域插件: 子向父传递数据后, 父组件根据接收到的数据来决定向子组件传递不同的标签内容
//祖孙
	$attrs与$listeners
	provide与inject
//兄弟或任意
	全局事件总线
	Vuex
```

```js
//provide于inject案例

export default{
    //
    provide(){
        return { //声明向所有后代提供2个数据
            content1:this.content1,
            content2:this.content2,
            updateContent:this.updateContent
        }
    }
}

export default{
    //
    inject:['content1', 'content2', 'updateContent'] //声明注入的属性会成为组件对象的属性
}


//.sync

```





#### 3) 各种组件间通信详细说明

查看 ***vue_组件间通信.md***

```js
//组件间通信 面试题
1.父组件如何获取子组件实例对象的方法
 $refs, $children
 $refs包含所有有ref属性的标签对象或组件对象的容器对象, 通过this.$refs.组件name来操作子组件方法
 $children是所有直接子组件组成的数组
 
2.父子组件互相调用方法
 父调子:$refs, $children
 子调父:props, $parent

3.常用事件修饰符
.stop .prevent .native

4.v-on可以监听多个方法吗?
 可以. $listeners  <el-button v-on="$listeners">
```







### Vue的响应式

- **组件的data为什么只能是函数不能是对象?**
- 同一个组件的多个组件实例的data必须是不同的对象(内容初始数据可以相同)
  - 如果是data是对象, 组件的多个实例共用一个data对象
  - 如果是函数, 组件对象通过调用函数得到的一个新的data对象
- **响应式数据与非响应式数据?**
  - 响应式: data / props / computed/ vuex的state与getters
  - 非响应式:　仅仅存在于组件对象上的属性数据
    - 给组件对象添加一个新属性: this.xxx = value 
    - 直接给一个响应式对象添加一个新属性: this.product.xxx = 'abc'  ==> this.$set(this.product, 'xxx', 3)
- **对象的响应式与数组的响应式有什么区别?**
  - 对象: 通过Object.defineProperty()添加setter方法来监视属性数据的改变 + 订阅-发布
  - 数组: 重写数组一系列的更新数组元素的方法 + 订阅-发布(pop/push/shift/unshift/splice/sort/reverse)

```js
//vue种数组实现响应式为什么不用object.defineProperty
1.如果使用defineProperty,数组作为对象形式,只能通过下标属性来修改属性
2.假设数组元素过多,就需要为每一个元素添加这个属性, 使用方法效率高于此种方式.

重写数组方法的限制: 只能通过7个方法来更新数据.
```




#### 3) Vue双向数据绑定

- 通过v-model来实现双向数据绑定
- v-model的本质
  - 将动态的data数据通过value属性传给input显示  ==> data到view的绑定
  - 给input标签绑定input监听, 一旦输入改变读取最新的值保存到data对应的属性上 ==> view到data的绑定
- 双向数据绑定是在单向数据绑定(data-->view)的基础, 加入input事件监听(view ==> data)



#### 4) 响应式原理面试交流总结

```js
dev是依赖对象,是中间人
watcher 监视器
```

- 初始化
  - 实现数据代理
    - 通过defineproperty给vm定义与data中属性对应的带getter/setter的属性
    - 在getter中, 读取data中对应的属性值返回      ==> 读取this.msg ==> 读取的是data中msg属性值
    - 在setter中, 将最新值保存到data对应的属性上   ==> this.msg = 'abc'   ==> 'abc'会保存到data的msg上
  - 创建observer
    - 目标: 对data中所有层次的属性进行监视/劫持
    - 通过defineproperty给data中所有层次属性, 都重新定义, 加上getter与setter
      - getter: 用来建立dep与watcher的关系   
      - setter: 用来当data数据发生改变去更新界面
    - 为data中所有层次的属性创建一个对应的dep   ==> 用来将来更新界面的
  - 创建compile
    - 目标1: 实现界面的初始化显示
    - 目标2: 为将更新做准备
      - 为模板中每个包含表达式(事件表达式除外)的节点创建一个对应的watcher
      - 给watcher绑定用于更新对应节点的回调函数
      - 将watcher添加到n个对应的dep中 

- 更新
  - this.msg = 'abc'
  - 由于有数据代理 ==> data的msg更新为了'abc'
  - 由于有数据劫持 ==> data中msg的setter调用了
  - 在setter中, 通过对应的dep去通知所对应的watcher去更新对应的节点     ==> 使用了订阅发布模式


#### 问题: Vue.use()内部做了什么?

- 对象插件: 调用插件对象的install方法(传入Vue)来安装插件(执行定义新语法的代码)
- 函数插件: 直接将其作为install方法来调用(传入Vue)来安装插件(执行定义新语法的代码)

### Vue状态管理: Vuex

#### 概述下Vuex
Vue应用的状态管理模式.每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
* Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
* 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

主要包括以下几个模块：
State： 定义了应用状态的数据结构，可以在这里设置默认的初始状态。
Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

#### vuex多模块编程
- vuex的多模块编程的必要性
  - vuex单模块问题: 
    - 需要的管理状态数据比较多, 那对应的mutations/actions模块就会变得比较大
    - 如果添加新的数据管理, 需要修改现在文件(不断向其添加内容) 
  - vuex多模块编程: 对各个功能模块的数据分别进行管理, 这样更加具有扩展性

- 什么时候需要用vuex多模块编程? 需要vuex管理的数据比较多时使用
- 多模块编程的总state结构:

```js
{
	home: {
        categoryList: [],
        xxx: {}
    },
    user: {
        userInfo: {}
    }
}
```

#### 问题1: vuex中的mutation可以执行异步操作吗?

- 可以 ==> 异步更新数据后界面确实会自动更新
- 问题 ==> vuex的调用工具监视不到mutation中的异步更新, 工具记录还是更新前的数据(不对)
- 扩展: 工具如何记录数据变化? ==> 每次mutation函数执行完后, 立即记录当前的数据   ==> 在mutation中同步更新state, 才能被记录到



#### 问题2: vuex中的状态数据的响应式的原理?

1. 创建了一个vue实例(vm)对象

2. state中的数据都是实例的data数据(是响应式的)

3. 组件中读取的state数据本质读取的就是data中的数据

4. 一旦更新了state中的数据, 所有用到这个数据的组件就会自动更新



#### 6) 问题3: vuex数据刷新丢失的问题

```js
//数据丢失原因
1.	Vuex数据保存在运行内存中，vue实例初始化的时候为其分配内存
2.	当刷新页面的时候重新初始化Vue实例，所以重新为Vuex分配内存导致之前保存的数据丢失


//如何解决?
1.	Vuex的数据都是每次组件加载时候动态请求获取数据保存
a)	优点： 保证数据不会丢失
b)	缺点: 性能差，因为网络问题可能有网络延迟

2.	将Vuex中的数据每次同步更新保存到sessionStorage中
a)	优点: 每次页面刷新后从sessionStorage中获取保存的数据，不会丢失
b)	缺点: state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差

3.	在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取
a)	优点: 减少动态更新sessionStorage的次数，性能好
b)	重点: 给window绑定beforeupload事件监听

```

- 绑定事件监听: 在页面卸载(关闭)或刷新时候保存当前数据

```js
beforeCreate(){
    window.addEventListener('beforeunload', () => {
	sessionStorage.setItem('CART_LIST_KEY', 
		JSON.stringify(this.$store.state.shopCart.cartList))
	})
}
```

- 在初始时读取保存数据作为状态的初始值. 解决页面刷新数据丢失的问题

```js
//state中初始化属性值
cartList: JSON.parse(sessionStorage.getItem('CART_LIST_KEY')) || [],
```



#### vuex面试题

```js
1.vuex与redux的区别
redux根据老的状态来更新新的状态

2.vuex和store的关系,vuex的5大属性
 vuex是vue插件,核心对象是store,store管理5大属性


3.vuex原理,组件传参方式
 构建一个vm,state中的数据都是实例的data属性
 组件传参方式? 先需要确认是否是组件和vuex传递数据
 组件->vuex dispatch commit
 vuex->组件: mapState,mapGetters
     
4.监听vuex自身数据
 两种方式获取vuex的state数据:  $store.state与mapState
 定义返回state数据的计算属性->通过watch监视这个计算属性->state变化,计算属性值,监视的回调

5.vuex理解
 - vuex是vue中集中式状态管理的一个插件,可以对组件共享状态进行集中式管理(管理:读写)
 - vuex是组件间通信的一种方式,可实现任意组件间通信.
 - 什么时候使用? 多个组件依赖同一状态,不同组件的行为要变更为同一状态: 购物车页面要根据登录状态来访问



6.vuex如何外部改变内部的值
 是组件更新了state中的数据:dispatch, commit
 模块化编程下,内部模块改变外部模块的值:
 
 
7.对vuex的理解一些使用场景
 多个组件共享数据或者是跨组件传递数据时
 购物车的数据共享, 登录注册
```





### 7. Vue路由: vue-router

#### 1) 一些基本知识

- 跳转/导航路由的2种基本方式
  - 声明式路由:  \<router-link :to="{path: '/xxx'}" replace>xxx</router-link/>
  - 编程式路由: this.$router.push/replace(location)


```js
//<router-link>解析过程
1.生成a标签
2.阻止默认行为,绑定事件监听
3.调用编程式路由
```



- 跳转路由携带参数(数据)的方式
  - params参数
    - 注册的路由路径得有点位: /xxx/:name/:age
    - 跳转时指定参数值:
      - /xxx/abc/12
      - {name: 'xxx', params: {name: 'abc', age: 12}}
  - query参数
    - 位置: url路径中以?开始以&连接key=value的字符形式    /xxx?name=tom&age=12
    - 注册路由时不需要做特别的指定
    - params和query同时使用,params参数要放在query前面.
  - props
    -  props: true, // 只能同名映射params参数
    -  props: {a: 1, b: 'abc'}, // 只能映射非params/query参数
    -  props: route => ({keyword3: route.params.keyword, keyword4: route.query.keyword2, xxx: 12}), //可以指定任何数据都可以
  - meta
    - 通过路由的meta的配置来指定包含n个数据的对象
    - 取数据: this.$route.meta.xxx
- location的2种类型值
  - 字符串 path
  - 对象形式: {name, path, params, query}
  - push(location)
  - \<router-link :to="{}">

####   2) 参数相关问题

- params与path配置能不能同时使用

  不可以: router.push({path: '/xx', params: {name: 'tom'}})

  params只能与name配合: router.push({name: 'xx', params: {name: 'tom'}})   

- 如何配置params参数可传可不传?

  path: '/search/:keyword?',    

  注意: 一旦声明可以不传, 不能传入一个空串的param参数

- 跳转携带的参数, 刷新就丢失了

  如果注册没有指定/:xxx的点位, 而跳转时通过params配置携带的参数数据, 刷新时就会丢失

  因为url中没有携带的参数数据路径

  this.$router.push({name: 'Info', params: {a: 1, b: 2}})

  this.$route.params.a

  /info/1/2

- 路由组件能不能传递props参数?

  可以, 但只是将params/query映射成props传入路由组件的

- **编程式路由跳转到当前路由, 参数不变, 会报出错误?  ==> 在做项目时有没有遇到比较难/奇怪的问题?**

  push(location, () => {}, () => {})

  push(location).then(() => {}, () => {})

  

push(location, () => {})



- 说明情况:

  - 上一个项目这种操作没有这个问题

    - 后面的一个项目(2019.8之后)开始有这个问题, 而且是声明式跳转没有, 只有编程式跳转有

  - 当编程式跳转到当前路由且参数数据不变, 就会出警告错误:

    错误: Avoided redundant navigation to current location ==> 重复跳转当前路由

  - 原因: 

    vue-router在3.1.0版本(2019.8)引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise

    说明文档: https://github.com/vuejs/vue-router/releases?after=v3.3.1

  - 

  - 解决:

    - 办法1: 在每次push时指定回调函数或catch错误

      ```js
      push('/xxx', () => {})   ===> 声明式路由跳转本质就是这样执行的
      push('/xxx').catch()
      ```

    - 办法2: 重写VueRouter原型上的push方法 (比较好)

      - 1). 如果没有指定回调函数, 需要调用原本的push()后catch()来处理错误的promise
      - 2). 如果传入了回调函数, 本身就没问题, 直接调用原本的push()就可以

    ```js
    const originPush = VueRouter.prototype.push
    VueRouter.prototype.push = function (location, onComplete, onAbort) {
      console.log('push()', onComplete, onAbort)
      // 判断如果没有指定回调函数, 通过call调用源函数并使用catch来处理错误
      if (onComplete===undefined && onAbort===undefined) {
        return originPush.call(this, location).catch(() => {})
      } else { // 如果有指定任意回调函数, 通过call调用源push函数处理
        return originPush.call(this, location, onComplete, onAbort)
      }
    }
    
    ```

  - 说明:

    声明式路由跳转之所有没有问题, 是因为默认传入了成功的空回调函数

    

```js
//路由问题:
1.二级路由介绍? 
- 实现:路由对象中添加children属性,属性值是数组,内部是对象
- 子路由path写法: 基本: /home/message  简化:message

2.params参数,及和query参数一起用注意问题?
- params参数需要占位接收;
- 一起使用,params参数需要写在query参数的前面

3.路由配置中props属性的作用
- 组件中使用$route会使对应的组件形成耦合,这些组件只能在相应的url上使用,限制灵活性
- 通过props传递,简化了以往需要计算属性获取params,query参数.可以直接在组件的props属性上声明接收.
```



​    

#### 3) 有点难度, 但很重要的

- 路由懒加载: 

  - () => import('./Home.vue')
  - 组件单独打包, 开始不加载其打包文件, 第一次请求时才会加载 ==> 加载更快, 提高用户体验


```js
使用import  from 这样的方式是同步执行，将所有的路由组件一次性打包在一个大的文件当中
//这样打包之后，打包出来的文件体积比较大，当浏览器在访问这个文件加载的时候，效率不高
//所以我们就想办法将所有的路由组件，分别打包为一个小的文件
//浏览器在访问哪个组件的时候，再去加载哪一个小的文件，效率就会提升
//这个过程就是我们所说的路由懒加载

路由对象中的component属性组件名称,函数

const Home = ()=>import('@/pages/Home')
或
{
    name:'Home',
    component:()=>import('@/pages/Home')
    //component:Home
}
```



- 缓存路由组件

  ```vue
  <keep-alive>
      <router-view/>
  </keep-alive>
  ```

​			路由离开时不销毁, 路由回来时不用重新创建  ==> 利用缓存, 切换路由更快

​			再利用上prefetch实现预获取, 用户体验更佳

- 动态添加路由

  - router.addRoutes(routes)
  - 在异步确定用户的权限路由后, 需要动态添加到路由器


```js

```



- 路由守卫与权限校验

  - router.beforeEach()注册全局前置守卫
  - 统一对用户权限进行一系列的校验处理
- history与hash路由的区别和原理

```js
- localhost:4000/xxx ==>  localhost:4000/xxx  ==> 后台没有对应的资源 ==> 404
  - 当请求找不到对应的资源时 ==> 返回index.html  ==>  js ==> 解析路径(当成前台路由路径解析)
- localhost:4000/#/xxx  > localhost:4000 => index.html  ==> js ==> 解析路径(当成前台路由路径解析)
  - 区别:
    - history:  路由路径不#, 刷新会携带路由路径, 默认会出404问题, 需要配置返回首页
      - 404: 
        - history有: 刷新请求时会携带前台路由路径, 没有对应的资源返回
        - hash没有: 刷新请求时不会携带#路由路径
      - 解决: 
        - 开发环境: 如果是脚手架项目本身就配置好 
          ==> webpack ==> devServer: {historyApiFallback : true}
          当使用 HTML5 History API 时, 所有的 404 请求都会响应 index.html 的内容
      - 生产环境打包运行:
        - 配置nginx
              location / {
                try_files $uri $uri/ /index.html; # 所有404的请求都返回index页面
              }
    - hash: 路由路径带#, 刷新不会携带路由路径, 请求的总是根路径, 返回首页, 没有404问题
 
        
- 原理:
- history: 内部利用的是history对象的pushState()和replaceState() (H5新语法)
- hash: 内部利用的是location对象的hash语法
    - 写hash路径
    - 读hash路径
    - 监视hash路径的变化

```



如何让路由跳转后, 滚动条自动停留到起始位置?

```js
new VueRouter({ // 配置对象
  // ...
  scrollBehavior (to, from, savedPosition) {
    // 指定路由跳转后滚条的坐标
    return { x: 0, y: 0 }
  }
})


//返回上个页面定位到底上次访问的位置
scrollBehavior(to,from,savedPosition){
    if(savedPosition){
        return savedPosition;
    }else{
        return {x:0, y:0}
    } 
}

//完善 上面的代码.不是每个页面都有这个需求 搭配使用meta属性
scrollBehaviour(to,from,savedPosition){
    if(savedPosition && to.meta===true){
        return savedPosition
    }else{
        return {x:0,y:0}
    }
}
```

如何实现登陆后, 自动跳转到前面要访问的路由界面

在全局前置守卫中, 强制跳转到登陆页面时携带目标路径的redirect参数

```js
if (userInfo.name) {
  next()
} else {
  // 如果还没有登陆, 强制跳转到login
  next('/login?redirect='+to.path)  // 携带目标路径的参数数据
}
```



在登陆成功后, 跳转到redirect参数的路由路径上

```js
await this.$store.dispatch('login', {mobile, password})
// 成功了, 跳转到redirect路由 或 首页
const redirect = this.$route.query.redirect
this.$router.replace(redirect || '/')
```



####   4) 路由导航守卫的理解和使用

##### 是什么?

```js
导航守卫是vue-router提供的下面2个方面的功能

- 监视路由跳转  -->回调函数
- 控制路由跳转  -->  放行/不放行/强制跳转到指定位置    next()
```



##### 应用

```js
- 在跳转到界面前, 进行用户权限检查限制(如是否已登陆/是否有访问路由权限)
- 在跳转到登陆界面前, 判断用户没有登陆才显示
```



##### 导航守卫分类

1.**全局守卫: 针对任意路由跳转**

全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // ...
})
```

全局后置守卫

router.afterEach((to, from) => {})



2.**路由守卫**

前置守卫

```js
{
	path: '/foo',
	component: Foo,
	beforeEnter: (to, from, next) => {}
},
    
{
	path: '/xxx',
	component: Foo,
  	beforeEnter: (to, from, next) => {}
}
```



3.**组件守卫: 只针对当前组件的路由跳转**

进入

```js
beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
      // 不！能！获取组件实例 `this`
      // 因为当守卫执行前，组件实例还没被创建
    
    next(vm => {
    	// 通过 `vm` 访问组件实例
    	})
  },
 
```



更新

beforeRouteUpdate (to, from, next) {}

离开

beforeRouteLeave (to, from, next) {}

```js
//面试题

1.vuerouter路由跳转传参的方式,路由懒加载实现
传参方式4种:
params参数: 路由注册时需占位接收(冒号+变量形式);跳转传参时路径传参和对象传参两种,注意事项是编程路由导航种params参数只能搭配命名路由name
query参数: 路由注册无需对query声明接收;跳转传参是对象形式;路径形式是?后以&连接的key=value形式; 注意:同时接收params,query,要先声明params参数.

props属性: 3种形式:布尔值->映射params参数,静态数据->只能映射非params和query参数,函数->可传递任意数据.
meta属性: 通过路由的meta的配置来指定包含n个数据的对象, 通过this.$route.meta来访问相应属性

路由懒加载: 代码分别打包,函数延迟执行

2.vue-router中的全局守卫,路由守卫和组件守卫.
vue-router中的3种导航守卫,有监视控制路由跳转的功能,应用在页面跳转的权限和登录页面是否显示上.
全局守卫: 针对任意路由跳转,全局前置守卫beforeEach 全局后置守卫afterEach
路由守卫: 在路由配置上直接定义 beforeEnter 守卫,使用方法和全局前置守卫相同.
组件守卫: 只针对当前组件的路由跳转.beforeRouteEnter beforeRouteUpdate beforeRouteLeave. beforeRouterEnter不能访问this,组件还未创建.使用next函数传入当前组件实例来解决.


3.vue-router的使用和理解
vue-router是vue的一个插件库,是官方路由管理器,简化构建单页面应用.

使用:
引入和暴露对象
路由传参
路由懒加载
缓存路由组件
动态添加路由
路由守卫权限校验
滚动条位置
导航守卫
路由模式
默认显示页面/404


4.vue-router跳转的原理/前端路由的实现/
- history: 内部利用的是history对象的pushState()和replaceState() (H5新语法)
- hash: 内部利用的是location对象的hash语法
    - 写hash路径
    - 读hash路径
    - 监视hash路径的变化

5.hash路由和history路由实现原理

6.vue种$route和$router的区别,query和params的区别

7.vue路由模式的区别

8.vue种路由传参的方式

```



### HashRouter 和 HistoryRouter的区别和原理？

（1）在url显示： hash有#很Low ； history 无#好看

（2）回车刷新： hash 可以加载到hash值对应页面 ； history一般就是404掉了

（3）支持版本： hash支持低版本浏览器和IE浏览器 ； historyHTML5新推出的API

hash模式背后的原理是onhashchange事件,可以在window对象上监听这个事件:

```js
		window.onhashchange = function(event){
		  console.log(event.oldURL, event.newURL);
		  let hash = location.hash.slice(1);
		  document.body.style.color = hash;
		}
```

```scss
window.history 提供了两类API，一类是go(), back(), forward()这种定位到某个浏览历史的记录上；
另外一类是pushState(), replaceState()这种，是操作历史记录的接口（添加和替换历史记录栈）。
history mode就是使用pushState()和replaceState()来实现前端路由，通过这两个方法改变url，页面不会重新刷新。
使用这两个方法更改url后，会触发popstate事件，监听popstate事件，实现前端路由。
window.addEventListener('popstate', function(e) { alert('url 更新') });
当我们访问同域下不同的url时，就能触发popstate事件
```





## Vue 前台项目问题

### 路由跳转与传参相关问题

**面试问题1: 指定params参数时可不可以用path和params配置的组合?**

​	不可以用path和params配置的组合, 只能用name和params配置的组合

​	query配置可以与path或name进行组合使用

**面试问题2: 如何指定params参数可传可不传?**

​	`path: '/search/:keyword?'`

**面试问题3: 如果指定name与params配置, 但params中数据是一个"", 无法跳转**

​	解决1: 不指定params

​	解决2: 指定params参数值为undefined

**面试问题4: 路由组件能不能传递props数据?**

​	可以: 可以将query或且params参数映射成props传递给路由组件对象

```js
//在routes中配置
props: route=>({keyword1:route.params.keyword, keyword2: route.query.keyword })
```

**面试问题5(非常重要): 编程式路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误**

​	面试问题: 在做项目时有没有遇到比较难的问题?(可做回答)

回答步骤：

1. **我的问题**: 我在上一个项目时没有问题, 后面再做一个新的项目时就有了问题

2. **原因分析**: vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise

3. **解决办法**:解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误

   ​				解决2: 修正Vue原型上的push和replace方法 (优秀)

   ```js
   // 缓存原型上的push方法
   const originPush = VueRouter.prototype.push
   VueRouter.prototype.push = function (location, onComplete, onAbort) {
     console.log('push()', location, onComplete, onAbort)
     // this是路由器对象 $router
     // 如果调用push, 传递了成功或者失败的回调函数
     if (onComplete || onAbort) {
       // 让原来的push方法进行处理
       originPush.call(this, location, onComplete, onAbort) // 不用返回, 因为执行的结果返回是undfined
     } else { // 如果调用push, 没传递了成功或者失败的回调函数, 可能会抛出失败的promise, 需要catch一下
       return originPush.call(this, location).catch(() => {
         console.log('catch error')
       })   // 必须返回产生的promise对象
     }
   }
   ```

### **解决在二层及以上的路由路径上刷新, 丢失reset样式的问题**

- 因为history模式的缘故

  页面中引入reset: `<link rel="stylesheet" href="./css/reset.css"> `

- 解决： 

  `<link rel="stylesheet" href="/css/reset.css">`



### 测试调用接口请求函数（跨域问题）

1. 出404的错误

   ​	 axios请求配置的地址: /api/product/getBaseCategoryList'

   ​     当前发请求所在的地址:　http://localhost:8080/

   ​	最终ajax请求的地址: http://localhost:8080/api/product/getBaseCategoryList (没人处理)

2. 解决办法1

   ​	配置baseURL: http://182.92.128.115/api   ==> 成功的前提是后台允许ajax跨域

3. 使用代理服务器转发到目标接口地址 (使用代理解决ajax跨域)

   ​	配置baseURL: /api

   ​	配置代理: vue.config.js中

   ```js
   devServer: {
     proxy: {
       // 配置代理
       "/api": {
         // 只处理以/api开头的请求
         target: "http://182.92.128.115", // 转发的目标地址
         changeOrigin: true, // 支持跨域
       }
     }
   }
   ```

#### vuex的基本使用

- store对象: state, mutations, actions, getters配置store对象: 在vm中配置

#### vuex多模块编程

- 当vuex管理的数据个数很多时使用
- 好处: 每个功能模块的数据单独管理, 更方便, 更有扩展性

#### vuex多模块编程的总state结构

- 要根据具体分出的模块进行调用

```js
{
    user: {
        userInfo: {}
    },
    home: {
        baseCategoryList: []
    }
}
```

#### vuex与api交互

- 异步action: 调用api接口请求函数 ==> 成功之后commit ==> 调用mutation ==> 更新状态数据

### 利用lodash进行函数节流处理

**问题: mouseenter事件频繁触发会导致分类列表更新卡的现象**

- 解决: 使用lodash的throttle函数进行节流处理, 限制更新的次数

#### 优化减小打包文件: 对lodash库实现按需引入 

```js
import _ from 'lodash'  // 引入整体lodash  ==> 打包了没用的工具函数, 打包文件变大
import throttle from 'lodash/throttle'  // 只引入我需要的工具函数   打包文件减少1.4M
```

#### 解决快速移出后可能显示第一个分类的子分类列表的bug

    原因：在最后一个mouseenter事件延迟0.3m才执行更新的回调函数
        在这个0.3s之内可能已经移出去了
    解决: 给currentIndex设计了3个值:
            -2: 在整个大div外面   
            -1: 进入了包含所有分类的大div上
            >=0: 在某个分类上
        在准备更新currentIndex之前, 需要判断currentIndex当前不能为-2





### 3级分类列表卡顿及解决

商品分类鼠标快速移入移出, 浏览器出现卡顿现象. 使用防抖和节流处理.  使用库lodash

lodash是已经存在的依赖包, 可以通过`search_modules`搜索确认

使用lodash时, 只引入所需的函数/功能



#### 函数防抖/节流

##### 函数防抖的应用场景:

连续的事件,只需触发一次的回调的场景有:

* 搜索框搜索输入.只需要用户最后一次输入完,再发请求
* 手机号,邮箱验证码输入监测
* 窗口大小Resize. 只需要窗口调整完成后,计算窗口大小.防止重复渲染

##### 函数节流的应用场景:

间隔一段时间执行一次回调的场景有:

* 滚动加载,加载更多或滚动到底部监听
* 谷歌搜索框,搜索联想功能
* 高频点击提交,表单重复提交.



#### throttle

两种引入形式. 及参数的具体含义

按需引入lodash减少打包体积

解决使用lodash节流后，快速移出后，可能还会显示某个子项
	{ 'trailing': true,leading:false}

'trailing': 是否在时间间隔之后执行函数
leading： 是否在时间间隔之前执行函数

```js
import _ from 'lodash'

methods: {
  moveInItem: _.throttle(function(index) {
    this.currentIndex = index
    console.log(index)
  }, 20, { 'trailing': false})
}

// 
import throttle from 'lodash/throttle'

methods: {
  moveInItem: throttle(function(index) {
    this.currentIndex = index
    console.log(index)
  }, 20, { 'trailing': false})
}
```





### 页面跳转实现的3种方式及选择

#### 实现

页面三级分类列表 和搜索框 跳转, 通过3种方式来跳转

* 每个a标签链接更改为`router-link`
* 将`router-link`改为编程式导航`$router.push({name:'search', query:{}})`
* 使用事件委托 + 自定义属性 来代替多个`$router.push`



#### 存在的问题

当`<a>`标签改为`<router-link>`后, 会出现卡顿现象

##### 原因

渲染组件标签时候, 其本质是通过和标签名绑定好的构造函数,实例化了一个对象, 称作是组件对象.

多层vfor循环中多个\<router-link>标签产生了多个组件, 内存占用大, 卡顿

#### 解决1-编程式导航代替声明式导航

使用编程式导航代替声明式导航

```html
<div
							class="item"
							:class="{ item_on: currentIndex === index }"
							v-for="(c1, index) in categoryListSumIs15"
							v-bind:key="c1.cat_id"
							@mouseenter="moveInItem(index)"
						>
							<h3>
								<!-- <a href="">{{ c1.cat_name }}</a> -->
								<!-- <router-link
									:to="{
										name: 'search',
										query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
									}"
									>{{ c1.cat_name }}</router-link
								> -->

								<a
									href="javascript:;"
									@click="
										$router.push({
											name: 'search',
											query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
										})
									"
									>{{ c1.cat_name }}</a
								>
							</h3>
```





#### 解决2 - 事件委托

每个a标签都添加了点击事件, 内存中会定义很多个函数,内存占用也是比较大,效率虽然比声明式导航大,但是不够好. 使用<u>事件委托</u>来代替



每个分类项都添加事件，事件的回调函数很多，效率也不好
在共同的祖先级元素添加事件监听
		问题：怎么知道点击的是不是a标签
		问题：假设你点击的就是a标签，怎么知道点击的是一级还是二级还是三级
		问题：参数怎么携带，要携带携带哪些个的参数



利用在a标签中添加自定义属性来解决以上问题

##### 自定义属性(data-)

```js
//为html标签添加自定义属性,结构是data-xxx="..."
标签的data-开头的属性，叫做自定义属性,通过它我们可以给标签添加上自定义的属性.
获取:通过事件属性 event.target.dataset来获取这个属性.

注意:Vue会把自定义属性的大写变为小写.

```









### Mock接口数据

    1.新建文件夹 src/mock 准备数据新建文件xxx.json  floor.json banner.json
    2.安装mock模块 yarn add mockjs
    3.创建src/mock/mockServer.js
    	Mock.mock('/mock/banner',{code:200,data:banner}) //第一个参数，代表我们以后请求的路径，第二个参数代表返回的数据
    4.在main.js中引入 import '@/mock/mockServer'
    5.ajax文件中,新建mockAjax.js文件, 复制ajax.js中的内容, 但是基础路径改为/mock  // 不会向后台发送数据

### 使用swiper

- 创建并配置swiper对象: 必须在列表显示显示之后创建 ===> 在mounted()中创建

#### 解决多个swiper效果冲突的问题

​	问题: 针对某个swiper界面创建一个swiper对象, 它会影响了其它界面的swiper界面

​	原因: new Swiper ('.swiper-container'), 类名选择器匹配了页面中所有的swiper界面, 都产生了效果

​	解决: 使用ref技术: 通过ref标识swiper的根div, new Swiper (this.$refs.swiper)

#### 解决swiper动态页面轮播的bug

​	问题: 异步动态获取数据 + 直接在mounted中创建Swiper对象 ===> 没有轮播效果

​	原因: swiper对象创建得太早

​	解决: 使swiper对象在列表数据显示之后创建

​			**办法1**: 使用延迟定时器延迟一定的时间才创建 ==> 不合适, 因为请求获取的时间是不定的

​			**办法2**: watch + $nextTick()

​					通过watch能知道banners有数据了(变化了)

​					通过 $nextTick(callback)知道界面也更新了，那我们就可以在callback中创建swiper对象

**理解nextTick()**

- nextTick()需要在数据更新之后界面更新前我们调用

- 指定的回调函数在这次数据更新导致的界面更新完成后立即执行

#### 解决Floor组件中轮播有问题的bug

问题: banners的轮播可以, 但2个Floor的轮播都没有效果

原因: (在v-for以后轮播组件已经有数据了，不是从空数组变为有数据，所以watch不调用)

​	 	基础理解: 给组件标签传入的属性值是空数组/undefined, 组件对象会创建，如果是通过v-for遍历一个空数组或undefined来产生多个标签, 组件对象不会创建

​		watch默认: 初始创建显示不会执行, 只有在数据变化后才会执行

解决:

​		**办法1**: mounted() + watch回调

​					mounted()中: 判断如果已经有数据了, 立即创建swiper对象

​					watch回调: 判断如果有数据, 延迟创建swiper对象

​		**办法2**: watch

​					给watch指定2个配置

​					handler: 判断如果有数据, 延迟创建swiper对象

​					immediate: 指定为true, 表示在初始显示之前就会调用一次









### 响应式数据对象

#### **添加新属性**

错误方式: 

​		直接添加: this.options.trademark = 'xxx'  ==> 不会自动更新界面

原因: 

​		vue内部没有对添加的属性进行劫持操作(没有对应的setter监视)

正确方式:

​		vm.$set( target, key, value )

​		Vue.set( target, key, value )

​		为响应式对象添加一个属性，确保新属性也是响应式的，并且能够触发视图更新

#### 删除属性

错误方式: 

​		直接添加: delete this.options.trademark  ==> 不会自动更新界面

原因: 

​		vue内部给响应式属性添加的setter, 只能监视属性值的改变, 不能监视属性的删除

正确方式:

​		vm.$delete( target, key )

​		Vue.delete( target, key )

​		删除属性, 同时更新界面

### 自定义分页组件: Pagination

**自定义通用型/复用型组件的基本步骤**

- 实现静态组件: 模板/样式写好

- 设计从外部接收的数据: props

- 设计内部包含的数据: data

- 设计基于props和data的计算属性数据: computed

- 根据props和data数据和computed进行动态显示

  **v-for的优先级高于v-if: 先执行v-for的遍历, 每遍历一个再进行v-if的判断 面试题**

- 更新数据, 更新界面

  用户操作组件界面元素时, 更新当前组件的data数据

  子组件更新data数据的同时, 可能需要通知父组件做一些更新父组件数据的操作(可能异步/同步)

  父组件更新data数据的同时, 可能也要去更新子组件的数据



### 可说性强的点



### 1) 三级分类列表

- 使用编程式导航代替声明式导航

- router-link太多 ==> 创建很多组件对象 ==> 占用内存大, 效率低

  ```js
  1.使用声明式导航 产生的组件过多,内存中组件对象多,卡顿
  2.使用编程式导航代替声明式 click事件. 每个a标签上都添加了点击事件,内存中有很多函数,内存占用大.
  3.使用事件委托
   -如何获取发生事件的元素和属性:event.target 自定义属性和元素的dataset属性
  4.对mouseEnter事件的高频进行节流处理: lodash的节流函数throttle函数+按需引入
  
  import _ from 'lodash'
  import throttle from 'lodash/throttle'
  ```

  

- 优化事件处理效率

  - 利用事件委托: event.target
  - 理解事件委托与事件冒泡

- 如何携带点击的分类的数据?

  - event.target得到a标签  获取发生事件的元素
  - 利用自定义的data标签属性来保存分类信息

- 对mouseEnter高频事件进行节流处理

  - 使用lodash的throttle进行节流处理
  - 对lodash库实现按需引入



```html
<div class="all-sort-list2" @click="toSearch">
  <div
       class="item"
       :class="{ item_on: currentIndex === index }"
       v-for="(c1, index) in categoryListSumIs15"
       v-bind:key="c1.cat_id"
       @mouseenter="moveInItem(index)"
       >
    <h3>
      <a
         href="javascript:;"
         :data-c1Id="c1.cat_id"
         :data-cName="c1.cat_name"
         >{{ c1.cat_name }}</a
        >
      <!-- <router-link
:to="{
name: 'search',
query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
}"
>{{ c1.cat_name }}</router-link
> -->

      <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
})
"
>{{ c1.cat_name }}</a
> -->
    </h3>
    <div class="item-list clearfix">
      <div class="subitem">
        <dl
            class="fore"
            v-for="(c2, index) in c1.children"
            :key="c2.cat_id"
            >
          <dt>
            <a
               href="javascript:;"
               :data-c2Id="c2.cat_id"
               :data-cName="c2.cat_name"
               >{{ c2.cat_name }}</a
              >
            <!-- <router-link
:to="{
name: 'search',
query: { c2Id: c2.cat_id, c2Name: c2.cat_name },
}"
>{{ c2.cat_name }}</router-link
> -->

            <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c2Id: c2.cat_id, c2Name: c2.cat_name },
})
"
>{{ c2.cat_name }}
</a> -->
          </dt>
          <dd>
            <em v-for="(c3, index) in c2.children" :key="c3.cat_id">
              <a
                 href="javascript:;"
                 :data-c3Id="c3.cat_id"
                 :data-cName="c3.cat_name"
                 >{{ c3.cat_name }}</a
                >
              <!-- <router-link
:to="{
name: 'search',
query: { c3Id: c3.cat_id, c3Name: c3.cat_name },
}"
>{{ c3.cat_name }}</router-link
> -->
              <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c3Id: c3.cat_id, c3Name: c3.cat_name },
})
"
>{{ c3.cat_name }}</a
> -->
            </em>
          </dd>
        </dl>
      </div>
    </div>
  </div>
</div>
```



```javascript
		// 事件委派 函数
		toSearch(event) {
			// event是什么 每一次触发事件时,系统(浏览器内核)都会把这一次触发事件相关的所有信息,封装为一个对象. 在浏览器调用回调函数的时候, 自动传递给回调函数的第一个形参
			// 回调函数 自己定义 自己没调用 最后执行了.  所以toSearch在html中可以不用括号 vue中的回调参数顺序可以改变,但原生的不能改
			// event 是浏览器调用函数传递过来的时间对象, 代表你传递的$event, 只能在模板里出现

			let targetNode = event.target; // 获取目标元素
			let data = targetNode.dataset;
			console.log("data", data);
			let { c1id, c2id, c3id, cname } = data;

			if (cname) {
				// cname存在, 证明点击的就是a标签
				let location = {
					name: "search",
				};
				let query = {
					cName: cname,
				};

				// 确定是几级的ID
				if (c1id) {
					query.c1Id = c1id;
				} else if (c2id) {
					query.c2Id = c2id;
				} else {
					query.c3Id = c3id;
				}

				location.query = query;
				// 跳转之前, 要合并原来过来时的params参数
				if (this.$route.params) {
					location.params = this.$route.params
				}

				// 如果是从home页跳search页, 就push
				// 如果是从search页 跳 search 页, 就replace
				if (this.$route.path !== '/home') {
					this.$route.replace(location)
				} else {
					this.$router.push(location);
				}
				
			}
		},

```





### 2) 商品搜索列表

- 准备各种搜索条件
  - category1Id: '', // 一级分类ID
  - category2Id: '', // 二级分类ID
  - category3Id: '', // 三级分类ID
  - categoryName: '', // 分类名称
  - keyword: '', // 关键字
  - trademark: '', // 品牌  "ID:品牌名称"
  - props: [], // 商品属性的数组: ["属性ID:属性值:属性名"] 示例: ["2:6.0～6.24英寸:屏幕尺寸"]
  - order: '1:desc', // 排序方式  1: 综合,2: 价格 asc: 升序,desc: 降序  示例: "1:desc"
  - pageNo: 1, // 当前页码
  - pageSize: 10, // 每页数量
- 添加搜索条件
- 删除搜索条件
  - 删除分类或关键字条件后, 地址栏还有条件参数?
  - 删除关键字条件, 输入框中的关键字没有同步删除?
- 排序处理
  - 根据综合/价格/销量/评价排序
  - 升序/降序
  - 搞清条件数据结构
    - orderFlag:orderType
    - orderFlag: 1: 综合,2: 价格, 3: 销量, 4: 评价
    - orderType:  asc: 升序,desc: 降序

```js
//准备各种搜索条件
1.初始化搜索条件: data中的数据:搜索条件对象, dispatch只能接收一个参数
2.获取条件对象中的各个数据:
 获取对象数据: 从路由对象$route中获取query参数(点击的分类名称及id)和params参数(输入的关键字)
2.1优化条件对象-删除空属性: 对条件对象使用扩展运算符,更新.对象循环遍历Object.keys(obj),删除空属性
2.2处理对象的声明周期, 请求数据的声明周期: beforeMounte, mounted

//删除分类或关键字条件后, 地址栏还有条件参数
1.在搜索页重新输入关键字或者点击类别不会再发送请求，因为mounted只会执行一次，需要监视路由变化
2.解决: 使用watch监视$route,更新参数,重新发请求.

//删除关键字条件, 输入框中的关键字没有同步删除
1.使用自定义事件通知header组件清空关键字
2.重新发送请求this.searchParams.pageNo = 1  this.$router.replace({name:'search', query:this.$roue.query})

//商品排序处理(order:'2:desc')
0.data中初始化数据: order:'2:desc'
1.判断用户点击的是否是原来的排序标志sortFlag是否和原来一样,一样就更改排序类型sortType(asc,desc). 不一样就更改排序标志,排序类型默认.
2.更新页码,重新发送请求(this.getSearchInfo())
3.其他:阿里图标字体库的使用 ;计算属性的引入获取排序标志和类型
```







### 详情页

```js
//图片实现放大镜效果
组件结构:详情页组件, 缩略图组件imgList, zoom大图组件

//缩略图组件imgList
1.引入swiper轮播图组件
2.处理思路: 使用watch监视props属性图片数组imgList,一旦有变化,实例化swiper.但是没有效果,因为页面还没有完全形成,所以需要等页面完全形成后再去实例化swiper,使用$nextTick(最近一次页面更新之后调用)
watch:{
    imgList:{
        immediate:true,
        handler(newValue,oldValue){
            this.$nextTick(()=>{
                new Swiper(this.$refs.imgSwiper,{
                    slidesPerView:4, //一个视图放几张
                    slidePerGroup:4, //切换一组,几张图片
                    navigation:{
                        nextEl:".swiper-button-next",
                        prevEl:".swiper-button-prev"
                    }
                })
            })
        }
    }
}
3.点击的当前图片添加边框
动态类判断当前索引和点击索引是否相同,初始化index数据0,点击后将当前图片索引赋值给初始index. 
4.其他: 缩略图列表和展示图列表同步,使用全局事件总线传递当前图片的index值 this.$bus.$emit('changeDefaultIndex',index)

//右侧大图组件
1.缩略图组件给大图组件传递的index,在mounted中指定全局事件总线接收 //全局事件总线接收,$on后是方法
mounted(){this.$bus.$on('changeDefaultIndex',this.changeDefaultIndex)}
methods:{changeDefaultIndex(index){this.defaultIndex=index}}
1.1 beforeDestroy解绑全局事件总线

2.图片展现问题
使用<img :src="imgList[0].imgUrl"/> 报错:can't read property of undefined
使用<img :src="defaultImg.imgUrl"/> 通过计算属性得到return this.imgList[this.defaultIndex]||[] 来解决


3.蒙版+右侧大图
<div class="spec-preview">
    <img :src="default.imgUrl"/>
    <div class="event" @mousemove="move"></div>
    <div class="big">
        <img :src="defaultImg.imgUrl" ref="bigImg">
    </div>
    <div class="mask" ref="mask"></div>
</div>

move(event){
    //鼠标动,蒙版动,转化为根据鼠标位置求蒙版位置
    //event.clientX 视口 event.pageX页面 event.offsetX元素
    let mask = this.$refs.mask;
    let bigImg = this.$refs.bigImg;
    
    //获取鼠标坐标
    let mouseX = event.offsetX;
    let mouseY = event.offsetY;
    //根据鼠标位置和蒙版宽度计算蒙版位置
    let maskX = mouseX - mask.offsetWidth/2;
    let maskY = mouseY - mask.offsetHeight/2; //offsetWidth: 目标元素的宽度(加边框) 
    
    //设置蒙版位置前需要边界限定
    if(maskX<0){
        maskX=0;
    }else if(maskX>mask.offsetWidth){//因为整体宽度是蒙版的两倍
        maskX = mask.offsetWidth;
    } 
    if(maskY<0){
        maskY=0;
    }else if(maskY>mask.offsetHeight){
        maskY = mask.offsetHeight;
    }
    
    //设置蒙版的位置让蒙版活动
    mask.style.left = maskX + 'px';
    mask.style.top = maskY + 'px';
    
    //蒙版动,大图动  大图是蒙版移动反方向的2倍
    bigImg.style.left = -2*maskX+'px';
    bigImg.style.top = -2*maskY+'px';   
}

//点击切换销售属性值的选中状态
1.排它实现: 第一步,让所有成员变为同一种状态;第二步,让当前点击的这个成员变为另一种状态

//购买数量输入框
1.blur失去焦点还是选择change事件,change事件:触发条件时当前数据和原来的数据不一样
2.使用三元表达式处理负数,非数值等. //这里需要使用大于等于,否则会失效
<input v-model="skuNum" @change="$event.target.value>=1?(skuNum=$event.target.value*1):(skuNum=1)"/>

//加入购物车按钮-需要发请求    
.加入购物车 需要发请求给后台让后台存储信息,请求成功后返回信息,根据这个信息再去跳转.否则,如果添加失败,而又跳转到下个页面,救出问题.
async addShopCart(){
    try{
        await this.$store.dispatch('addOrUpdateShopCart',{skuId:this.skuId,skuNum:this.skuNum});
        alert('添加购物车信息成功');
        sessionStorage.setItem('SKUINFO_KEY',JSON.stringify(this.skuInfo));
        this.$router.poush('/addcartsuccess?skuNum='+this.skuNum)
    }catch(error){
        alert(error.message)
    }
}

```



### 购物车成功页面

```js
//请求需要携带用户临时身份标识,才能获取到数据

//用户临时标识
1.创建保存
 浏览器端创建,每次请求需要携带;
 应用一打开就创建保存在localStorage
 在state中也去保存一份,可以更快获取
2.使用
 请求拦截器每个请求都带上
3.做法
 工具函数去创建保存uuid
 在state中调用这个函数
 ajax发送请求,所有请求头中携带这个标识

//utils/userabout.js
import{v4 as uuid} from 'uuid';
export function getUserTempId(){
    let userTempId = localStorage.getItem('USERTEMPID_KEY');
    if(!userTempId){
        userTempId = uuidv4();
        localStorage.setItem('USERTEMPID_KEY', userTempId)
    }
    return userTempId;
}

//store/user.js
import{getUserTempId} from '@/utils/userabout';



//数据存储到data,方便后期使用

beforeMount(){
    this.skuNum = this.$route.query.skuNum;
    this.skuInfo = JSON.parse(sessionStorage.getItem('SKUINFO_KEY'))
}



```



### 购物车页面

```js
修改数量,修改选中状态,删除商品都需要发请求,请求成功后再请求更新页面数据

//修改购物车数量
<input autocomplete="off" type="text" :value="cart.skuNum" minnum='1' @change="changeCartNum(cart,$event.target.value*1, false)"
@click="changeCartNum(cart,-1,true)"
@click="changeCartNum(cart,1,true)"
async changeCartNum(cart,disNum,flag){
    //获取本身的数量
    let originNum = cart.skuNum;
    if(flag){
        if(originNum+disNum<1){disNum = 1-originNum}
    }else{
        if(disNum<1){
            disNum=1-originNum;  //disNum是变化的值
        }else{
            disNum = disNum - originNum;
        }
    }
    try{
        //发请求修改数量
    	await this.$store.dispatch('addOrUpdateShopCart',{skuId:cart.skuId,skuNum:disNum});
        alert('更改成功');
        //发请求重新获取购物车列表数据
        this.getshopCartInfo();
    }catch(error){
        alert(error.message);
    }
}

//修改购物车的全选状态
利用input标签:checked属性选中与否来决定配置属性isChecked是0还是1

  //使用计算属性读取和更新全选状态
  isCheckAll:{
      get(){
          return this.cartInfoList.every((item)=>{item.isChecked})
      },
      async set(val){
          try{
              const result = await this.$store.dispatch('updateCartIscheckAll', val?1:0);
              alert('修改成功')
              this.getshopCartInfo();
          }catch(error){
              alert(error.message)
          }
      }
  }

//vuex中全选 使用promise.all处理
async updateCartIscheckAll({commit,dispatch,getters}, isChecked){
    let promises=[];
    getters.cartInfo.cartInfoList.forEach(item=>{
        if(item.isChecked===isChecked) return;
        let promise = dispatch('updateCartIscheck', {skuId:item.skuId, isChecked})
        promises.push(promise);
    })
    return Promise.all(promises)
}

//页面数据计算

//统计已选的数量
computed:{
    checkNum(){
        return this.cartInfoList.reduce((prev,item)=>{
            if(item.isChecked){
                prev += item.skuNum;
            }
            return prev;
        },0)
    },
    
    //统计总价
    allMoney(){
        return this.cartInfoList.reduce((prev,item)=>{
            if(item.isChecked){
                prev += item.skuNum*item.skuPrice;
            }
            return prev;
        },0)
    }
}

//删除购物车数据

```



### 注册页面

```js
//点击注册按钮的逻辑
根据请求成功还是失败有后续操作（所以action里面函数要有return，来让vue当中判断成功和失败）
如果请求验证码成功，我们需要把验证码自动添加到页面上，修改data的code为state里面获取的
如果请求验证码失败，提示
async register(){
    //点击完成注册首先对所有的表单项做整体验证，验证通过返回的true,没通过返回的false
    const success = await this.$validator.validateAll();
    if(success){
        //发请求把收集的数据，作为参数传递给后台存储数据库
        let {phone, password, code} = this;
        try{
            await this.$store.dispatch('userRegister',{phone,password,code});
            alert('注册成功');
            this.$router.push('/login')
        }catch(error){
            alert(error.message)
        }
    }
}

main.js中  import '@/utils/validate'  //引入vee-validate相关配置

utils/validate.js
import Vue from 'vue'
import VeeValidate from 'vee-validate'
import zh_CN from 'vee-validate/dist/locale/zh_CN' // 引入中文message
Vue.use(VeeValidate)
```





### 登录页面

```js
//登录按钮回调

登录跳转前,进入到全局路由前置守卫中进行判断.
先判断是否又token:
有->访问的依然是login页面->跳转到首页
有->访问其他页面->再判断是否已经获取用户信息
用户信息有->放行
用户信息没有->dispatch一下请求,获取用户信息(保存到vuex中)


methods:{
    aysnc login(){
        let{phone,password}=this;
        if(phone&password){
            try{
                await this.$store.dispatch('userLogin',{phone,password});
                //登录成功后,跳转到之前前往的页面
                let targetPath = this.$route.query.redirect||'/';
                this.$route.push(targetPath);
            }catch(error){
                alert('登录失败')
            }
        }
    }
}



//路由器对象中配置全局路由守卫
const router = new VueRouter({
    routes,
    scrollBehavior(to,from,savedPosition){
        return {x:0,y:0}
    }
})
//注册全局前置导航守卫，用来对token校验（根据token获取用户信息）
router.beforeEach(async(to,from,next)=>{
    //第一步：守卫拦截住，先去获取用户的token和用户的信息
    let token = store.state.user.token;
    let userInfo = store.state.user.userInfo.name;
    
    if(token){
        //如果token存在,代表用户登录过
        if(to.path==='/login'){
            next('/')
        }else{
            //如果用户已经登录,但跳转的不再是登录页,需要查看用户信息获取了没有
            if(userInfo){
                //如果已经获取
                next()
            }else{
                //用户已经登录,但还没获取用户信息,需要请求用户信息
                try{
                    await store.dispath('getUserInfo') //用户根据token获取信息
                    next();
                }catch(error){
                    //根据token获取用户信息失败，代表token可能过期
          			//把用户的过期token给清理掉，重新跳转到登录页
                    store.dispatch('clearToekn');
                    next('/login')
                }
            }
        }
    }else{
        //用户没有登录,如果用户访问的是 交易相关  支付相关 个人中心相关，那么跳转到登录页面
        let accessPath=['/trade','/center','/pay'];
        let targetPaht = to.path;
        let result = accessPath.some((item)=>{item === targetPath})
        if(result){
            next('/login?redirect='+targetPath)
        }else{
            next();
        }
    }
})


//vuex中 user.js
const actions={
    //请求登录
    async userLogin({commit}, userInfo){
        const reuslt = await reqUserLogin(userInfo);
        if(result.code === 200){
            commit('RECEIVE_TOKEN', result.data.token);
            //自动登录就是需要保存token到localStorage
      	    //保证第一次登录完成，后期的登录都可以免了
            locationStorage.setItem('TOKEN_KEY',result.data.token)
            return 'ok';
        }else{
            return Promise.reject(new Error('failded'))
        }
    }
}

//ajax.js
//登录成功后，需要把token添加到请求头当中，从今往后所有的请求当中都要带上这个token
let token = store.state.user.token;
if(token){
    config.headers.token = token;
}

//用户临时标识和token区别
userTempId  未登录状态下的用户身份识别标识
token       登录状态下的用户身份识别标识 
如果没登陆，请求头当中只带了临时标识，添加的购物车信息是和临时身份标识对应的信息
如果登录了，那么我们同时在请求头添加临时标识和登录后标识，
那么此时后台会把临时标识对应的数据，转移到真正登录的标识数据里面，而临时标识对应的数据就不见了
两个标识都存在的话，后台会合并临时id对应的信息到token对应的信息上 token是老大
```







### 支付界面

```js
//支付流程
1.结算按钮 提交订单信息(push页面的时候,query参数传递订单编号)
2.根据接收的订单编号请求商品信息(支付url,金额)
3.支付1: 根据支付url生成支付二维码,引入qrcode
4.支付2: 扫码支付
5.支付3:使用定时器setInterval轮询请求支付状态
 5.1 支付成功: 存储支付状态->消息提示->关闭定时器(clearInterval,null)->跳转页面




//点击提交订单的逻辑
1.根据订单id获取支付信息 awati this.$API.reqPayInfo(this.orderNum)
2.可以根据支付信息获取支付url和金额
3.支付
3.1 根据支付url生成支付二维码图片显示 使用插件qrcode
3.2 扫码支付
3.3 轮询请求获取订单状态


async pay(){
    try{
        //第一步：根据支付信息当中codeUrl生成二维码进行弹框展示
    let imgUrl = await QRCode.toDataURL(this.payInfo.codeUrl);
    //生成的二维码图片链接进行展示
    this.$alert(`<img src="${imgUrl}" />`, '请使用微信扫码支付',{
        dangerouslyUseHTMLString:true,
        showClose:false,
        showCancelButton:true,
        cancelButtonText:'支付遇到问题',
        confirmButtonText:'我已支付成功',
        center:true,
        beforeClose:(action,instance,done)=>{
            //action代表用户点击的是哪个按钮 'confirm确定按钮', 'cancel取消'或'close关闭'；
            if(action==='confirm'){
                //判断如果没有支付
                if(!this.payStatus){
                    this.$message.info('请确保支付成功,成功后自动跳转支付页面')
                }
            }else if(action==="cancel"){
                //1.提示
                this.$message.warning('支付遇到问题请练习客服');
                //2.清除定时器
                clearInterval(this.timer);
                this.timer = null;
                //3.关闭消息盒子
                done();
            }
        }
    }).then(()=>{}).catch(()=>{});
     //.then() 是对应点击确定按钮之后的操作 .catch();是对应点击取消按钮之后的操作
     //如果采用这两个去操作，都会强制关闭我们的弹出框msgBox,而我们现在并不是要直接关闭，是需要判断用户是不是支付了，才决定关闭不关闭
    
    //轮询 隔2秒发一个请求， 为了让后台给我返回这个订单的支付状态
    //用以判断用户到底是支付了还是没支付
    if(!this.timer){
        this.timer = setInterval(async()=>{
            const result = await this.$API.reqPayStatus(this.orderNum);
            if(result.code === 200){
                //1、把成功的标志存储起来用于用户点击按钮的时候进行判断
                this.payStatus = 200;
                //2、提示支付成功
                this.$message.success('支付成功');
                //3、把定时器清除
                clearInterval(this.timer);
                this.timer = null;
                //4,自动跳转到支付成功页面
                this.$msgbox.close(); //强制关闭弹出框
                this.$router.push('/paysuccess');
                
            }
        },2000)
    }
    }catch(error){
        //生成二维码图片失败 提示
        this.$message.error(error.message)
    }
}

```





### 个人中心页面

```js
//路由权限控制
全局路由守卫: 隐私页面(个人中心,交易及支付相关页面)没登录情况下需要先登录,之后会自动跳转到个人中心页面


```



### 路由守卫在项目中使用

```js
//只有从购物车页面才能跳转到交易页面

//只有从交易页面才能跳转到支付页面

//只有从支付页面才能跳转到支付成功页面, 且需要携带必要的参数订单号,商品信息
```





### 补充

```js
//代码优化
1.图片懒加载:在图片界面没有进入到可视范围前不加载, 在没有得到图片前先显示loading图片
import  lazyload from 'vue-lazyload';
import loading from '@/assets/images/loading.gif'
Vue.use(VueLazyload, { // 内部自定义了一个指令lazy
  loading,  // 指定未加载得到图片之前的loading图片
})

<img v-lazy="goods.defaultImg" />
    
//2.路由懒加载
通常路由组件使用import..from..方式同步将所有路由组件一次性打包在一个文件中.(体积大,加载效率低).
路由懒加载是使用动态import分别打包文件,浏览器请求哪个组件再去加载哪个组件(效率高)

形式: const Home = ()=>import('@/pages/home');
{
    name:'Home',
    component:()=>import('@/pages/home')
}
//3.第三方插件按需引入
element-ui  lodash

//4.大数组优化: 冻结列表+虚拟列表

//5.事件销毁
全局事件总线在beforeDestroy(){this.$bus.$off('eventname')}

//webpack优化

```





### 3) 下单支付流程

- 去结算 ==> 获取订单交易数据
- 提交订单 ==>提交下单请求, 得到订单ID
- 根据订单ID获取支付信息
  - 金额
  - 支付url
- 支付
  - 根支付Url生成支付二维码图片显示, 使用qrcode
  - 扫码支付
  - 轮询请求获取订单状态
- 分页显示订单列表

### 4) 注册流程

- 前台: 输入注册需要的相关信息(用户名/密码/...), 进行前台表单校验, 如果不通过, 提示错误
- 前台: 发送注册的ajax请求(post), 携带注册接口需要的相关数据(用户名/密码/...)

- 后台: 获取到注册请求携带的参数, 去数据库中判断是否已经存在
  - 如果已经存在, 返回提示此用户已存在的提示信息
  - 如果不存在, 保存到数据库, 返回成功的数据
- 前台: 接收到响应
  - 如果是不成功的数据, 提示
  - 如果是成功的数据, 自动跳转到登陆页面

### 5) 登陆流程

- 前台: 输入登陆需要的相关信息(用户名/密码),  进行前台表单校验, 如果不通过, 提示错误
- 前台: 发送登陆的ajax请求(post), 携带登陆接口需要的相关数据(用户名/密码)
- 后台: 获取到登陆请求携带的参数, 去数据库中查询看是否存在
  - 如果不存在, 返回登陆失败的信息
  - 如果存在, 生成一个新的token字符串, 将token与用户信息一起返回
- 前台: 接收到响应
  - 如果是不成功的数据, 提示
  - 如果是成功的数据, 
    - 将用户信息和token都保存到vuex中
    - 将token保存到localStorage中   ==> 不保存用户信息
    - 跳转到首页或redirect页面

### 6) 自动登陆流程

- 简单说: 页面一加载时, 发送请求根据token获取用户信息
- 利用全局前置守卫:
  -  一旦发再当前没有登陆, 但前面登陆过(有token, 没有用户信息)
  -  发送请求根据token获取用户信息
     - 成功了, 保存用户信息及token
     - 失败了(说明token过期了): 清除token, 强制跳转到登陆页面

### 7) 购物车模块

- 购物车数据是保存在后台的, 标识是什么?
  - 未登陆: 标识为用户临时ID(userTempId)
    - 第一次访问时前台利用uuid库生成的唯一字符串, 保存保存在local中
    - 每次请求时通过请求头自动携带它(利用请求拦截器)
  - 登陆: 登陆用户对应的token
    - 用户请求登陆时, 服务器端生成并返回给浏览器, 浏览器收到后自动保存到local中
    - 每次请求时通过请求头自动携带它(利用请求拦截器)
- 添加购物车 / 修改购物项数量
  - 提交请求时, 携带商品的skuid和数量
  - 这2个操作是同一个接口, 也就是数量有可能是负数
- 获取购物车列表
  - 请求获取时不需要携带额外参数, 会自动携带标识: userTempId / token
  - 一旦用户登陆上, 后台会将关联在usertempId上的购物车数据合并到token对应用户关联的购物车数据
- 删除购物项(一个/多个)
  - 请求接口, 携带一个skuId或多个skuId的数组
- 勾选购物项(一个/多个)
  - 请求接口, 携带一个skuId或多个skuId的数组 和 是否勾选的标识数据(0/1)



## Vue 后台项目的重要点

实现element-ui的按需打包

深度作用选择器修改第三方UI组件的内部样式

利用深拷贝解决修改不能取消的问题

利用nextTick与set实现: 动态显示输入框并自动获得焦点

 对Form表单前台校验, 减少无用请求

Upload组件管理图片上传: 限制图片大小和文件类型

路由权限: 路由全局前置守卫 + 动态添加路由: addRoutes()

路由组件懒加载: import()

路由跳转的loading处理: nprogress

登陆成功自动跳转到redirect参数路由

使用各种组件间通信技巧:

​	![后台项目_组件间通信.png](https://i.loli.net/2021/04/10/3vNkhMfDx1cy94T.png)

高复用组件:

![复用组件.png](https://i.loli.net/2021/04/10/gZP1iphXS9TLvOf.png)



## vue项目优化
> [Vue 项目性能优化 — 实践指南](https://juejin.cn/post/6844903913410314247)
> [🔥 2022 前端性能优化最佳实践 - SegmentFault 思否](https://segmentfault.com/a/1190000041753539)
> [聊一聊前端性能优化 - 掘金 (juejin.cn)](https://juejin.cn/post/6911472693405548557)

#### 代码层面的优化
v-if 和 v-show 区分使用场景
computed 和 watch  区分使用场景
v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
长列表性能优化
事件的销毁
图片资源懒加载
路由懒加载
第三方插件的按需引入
* babel-plugin-component
优化无限列表性能
*  vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表
服务端渲染 SSR or 预渲染
* 使用 prerender-spa-plugin添加预渲染

#### Webpack 层面的优化
Webpack 对图片进行压缩
* 插件image-webpack-loader
减少 ES6 转为 ES5 的冗余代码
提取公共代码
* Webpack内置插件 CommonsChunkPlugin
模板预编译
* 预编译模板最简单的方式就是使用单文件组件; vue-template-loader
提取组件的 CSS
优化SourceMap
构建结果输出分析
* Vue 项目中用到的分析工具：webpack-bundle-analyzer. 
Vue项目的编译优化

### 基础的Web技术的优化
开启 gzip 压缩
浏览器缓存
CDN 的使用
使用Chrome Performance查找性能瓶颈

## Vue3

### Proxy 与 Object.defineProperty 优劣对比
Proxy 的优势如下:
Proxy 可以直接监听对象而非属性；
Proxy 可以直接监听数组的变化；
Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

Object.defineProperty 的优势如下:
兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。



### 3.0 特性
#### 监测机制的改变
3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了Vue2当中基于 Object.defineProperty 的实现所存在的很多限制：
* 只能监测属性，不能监测对象
* 检测属性的添加和删除；
* 检测数组索引和长度的变更；
* 支持 Map、Set、WeakMap 和 WeakSet。

新的observer还提供了以下特性：
* 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。
* 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。
* 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。
* 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。
* 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。

#### 模板
模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。
同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。

#### 对象式的组件声明方式
vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。
此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。
#### 其它方面的更改
vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：

支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。
支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。
基于 treeshaking 优化，提供了更多的内置功能。


## vue开发中踩过最大的坑

### '就地复用'的问题
> vue在用v-if v-else渲染两个相同的按钮，一个绑定了事件，另外一个没有绑定事件。当渲染状态切换的时候，会导致未绑定事件的按钮也绑定上了事件。原因是有的vue版本在没给条件渲染的元素加上key标识时候会默认复用元素提升渲染能力，导致事件被错误的绑定上另一个按钮。解决方案：更换高版本vue，加上key标识两个按钮。






## 性能优化





### 性能优化本质

**展示更快**、**交互响应快**、**页面无卡顿情况**。

更详细的说，就是指，在用户输入url到站点完整把整个页面展示出来的过程中，通过各种优化策略和方法，让页面加载更快；在用户使用过程中，让用户的操作响应更及时，有更好的用户体验。

### 性能优化指标

1.性能评估 Chrome Performance选项卡 / Lighthouse 生成性能检测报告 

2.值得关注的性能指标

(1)LCP (Largest Contentful Paint 最大内容绘制 ) 

(2)首屏渲染时间（也叫白屏时间） 

(3)FCP (Fitst Contentful Paint 首先内容绘制 ) 

(4)可交互时间 (Time to Interactive TTI)

 (5) Network请求时间(jax,js等) 

3.浏览器开发者工具什么都能看得到，可以调用性能监测API 或建立 前端监控系统(无痕埋点) 



### 性能优化手段

前端性能优化分为两类，一类是文件加载更快，另一类是文件渲染更快。 

* 加载更快的方法： 
  * 让传输的数据包更小（压缩文件/图片）：图片压缩和文件压缩 
  * 减少网络请求的次数：雪碧图/精灵图、节流防抖 
    * 雪碧图的应用场景一般是项目中不常更换的一些固定图标组合在一起，比如logo、搜索图标、切换图标等
    * 电商项目中最常用到的懒加载，一般在查看商品展示的时候通常下拉加载更多，因为商品数据太多，一次性请求过来数据太大且渲染的时间太长。
  * 减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等） 
* 渲染更快的方法： 
  * 提前渲染：ssr服务器端渲染 
  * 避免渲染阻塞：CSS放在HTML的head中 JS放在HTML的body底部 
  * 避免无用渲染：懒加载 
  * 减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签 



### JS中的性能优化

#### 1.不要覆盖原生方法

#### 2.事件委托(简化DOM操作)

#### 3.JS动画

#### 4.节流与防抖



### 页面渲染优化

#### 1.避免CSS, JS堵塞

CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。**尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化）**

实际使用时，可以遵循下面3个原则：

- **CSS 资源优于 JavaScript 资源引入**
- **JS 应尽量少影响 DOM 的构建**

改变JS阻塞方式

##### defer（延缓）模式

`defer` 方式加载 script, 不会阻塞 HTML 解析，等到 DOM 生成完毕且 script 加载完毕再执行 JS。

##### async（异步）模式

`async` 属性表示异步执行引入的 JS，加载时不会阻塞 HTML解析，但是加载完成后立马执行，此时仍然会阻塞 load 事件。

从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 `async`；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用`defer`。



#### 2.使用字体图标iconfont代替图片图标

字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。



#### 3.降低CSS选择器复杂性

浏览器读取选择器，遵循的原则是从选择器的右边到左边读取

1. 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素
2. 关注可以通过继承实现的属性，避免重复匹配重复定义
3. 尽量使用高优先级的选择器，例如 ID 和类选择器。
4. 避免使用通配符，只对需要用到的元素进行选择



#### 4.减少重绘和重排(回流)

**回流必将引起重绘，重绘不一定会引起回流，回流比重绘的代价要更高。**

如何避免?

**CSS**

- 避免使用table布局。
- 尽可能在DOM树的最末端改变class。
- 避免设置多层内联样式。
- 将动画效果应用到position属性为absolute或fixed的元素上。
- 避免使用CSS表达式（例如：calc()）。

**JavaScript**

- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
- 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。



#### 5.使用flexbox布局



#### 6.图片资源优化

##### 使用雪碧图

雪碧图的作用就是减少请求数，而且多张图片合在一起后的体积会少于多张图片的体积总和

##### 图片压缩

压缩方法有两种，一是通过在线网站进行压缩，二是通过 webpack 插件 image-webpack-loader。它是基于 [imagemin](https://link.segmentfault.com/?enc=OIHazSW1xgE0eJv1ufzlhg%3D%3D.50sTefI%2FunQpQnTLFGGC2iHdYBRXLANOzcn9%2BnYmSIMvSsZ2MxqDRBV%2F%2BgM8jZ3hfnNCnY2A6GBe0w8Jx7FIk7eCSR1knYAy2lBQYNu45s4%3D) 这个 Node 库来实现图片压缩的。

##### 图片拉加载

在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。

##### 使用CSS3代替图片



##### 使用webp格式的图片

小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。












###  Vue代码层面优化

####  1) v-for 遍历列表

指定非下标的唯一key

不同时使用 v-if



#### 合理使用watch computed

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行**异步**或**开销较大**的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。



#### 长列表性能优化

Vue 会通过 `Object.defineProperty` 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 `Object.freeze` 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

```javascript
export default {
  data: () => ({
    users: {}
  }),
  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
};
```



#### 优化无线列表性能: 虚拟列表

如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 [vue-virtual-scroll-list](https://link.segmentfault.com/?enc=RwGR6yk1CBddLI%2Bu8vtszQ%3D%3D.dlCkBYR4PA%2B55K3tT%2FQw8n0NYgopqNuyAiHiOl%2BmqkEbvSEXfwJzLmiOlCKtzroQt8eQCA8Nhva3W4K0YZ%2B%2FqtpzzMo6urAt17%2F52bgtgue87rsur8bCDAKfgfIWQNni) 和 [vue-virtual-scroller](https://link.segmentfault.com/?enc=VUESvmfK3cEynJ2TsRaDtw%3D%3D.BJ5wA7H4OmMcXokRRU59qGLNEEnNcyBtrSbVUK4mD9Dx8n1PY3Ug0ZqP05IZgBQjewtZNwuUGdg0J9VPr%2FVEGmAMU0cO94XO2a%2FeHYKtnDDlsvX9R2pFCY2p2kTTalwi) 来优化这种无限列表的场景的。



#### 事件的销毁

Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 JS 内使用 `addEventListener` 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：

```javascript
created() {
  addEventListener('click', this.click, false)
},
beforeDestroy() {
  removeEventListener('click', this.click, false)
}
```





#### 图片资源懒加载

如使用v-lazyload

##### 页面大量图片，如何优化加载，优化用户体验

1. 图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
2. 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
3. 如果图片为css图片，可以使用CSSsprite，SVGsprite等技术。
4. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
5. 如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。



#### 路由组件懒加载

```js
https://blog.csdn.net/fanjianglin/article/details/113430620
```

>  **Vue动态加载组件主要有两类方式，即import方式和require方式**, 

const Home = () => import('./pages/Home')

#### 第三方插件的按需引入

如: element-ui / vant 



#### 服务端渲染SSR / 预渲染

具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《 [Vue SSR 踩坑之旅](https://link.segmentfault.com/?enc=Hf%2BIPuMRv2K%2BeUWhiiDh1w%3D%3D.3jDS1JNzAA3uTddj1k%2FbKUkxDfmUV66bvM0o0VlBp7p4tnJIH%2F%2FCoaWInurEjB3S) 》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要**预渲染**，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 [prerender-spa-plugin](https://link.segmentfault.com/?enc=0VzVqkIFywisus2tXadNQA%3D%3D.idXZ937QutVTXXQ7wd01EK5OzIiISu2XSekHrv7pF9FQiDAmnD%2BWfxWCnx3amR%2FY1GwMIYYXtSDhO1lW0mWFyN7OTrA%2BbYHHgPsQzzqGblwB1SWoyI0BnBBKo7se13rh) 就可以轻松地添加预渲染 。



### webpack配置层面优化

#### 1) 兼容性处理

- JS

  - babel-loader: presets: ['@babel/preset-env'] 问题就是只能编译/转换简单语法
  - @babel/polyfill: 做复杂语法(新的APi)兼容，问题是体积太大了
  - core-js: 在@babel/preset-env基础上，增加了useBuiltIns: 'usage'来实现按需打包

- CSS  

  - postcss-loader  

  - 内部使用autoprefixer插件, 给C3样式自动添加厂商前缀

    ![preview](https://segmentfault.com/img/remote/1460000014782566/view)

  - 在package.json中指定browserslist来指示postcss-loader兼容性做到什么程度

#### 2) 拆分打包与压缩

对第三方JS包, css进行拆分打包

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2130fabf53ec430b9d103ae8b8009eca~tplv-k3u1fbpfcp-watermark.image)

#### 3) 资源预加载(prefetch)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a896fd6ab9e4e3b9479ea018aae8b49~tplv-k3u1fbpfcp-watermark.image)

#### 4) 生产环境时不生成 SourceMap

productionSourceMap: false

减少打包文件

#### 5) 文件名hash化=>利用浏览器缓存

对打包文件名用上contenthash ==> 某个bundle对应的模块文件内容发生改变文件名才会变化 ===> 利用浏览器缓存

#### 6) 代码Tree Shaking

效果: 打包时'摇掉'模块中没有被使用的代码

条件: 必须是ES6模块化导出且进行代码压缩时



### 基础的Web技术层面的优化

#### 1) 开启 Gzip

- 下载: yarn add compression-webpack-plugin --dev

- vue.config.js

```
var CompressionWebpackPlugin = require('compression-webpack-plugin');
...
configureWebpack: config => {
  config.plugins.push(
      new CompressionWebpackPlugin({
          test: new RegExp('\\.(js|css)$'),
          threshold: 8192,
          minRatio: 0.8
      })
 )
```

- nginx.conf中

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6749ab642da04d578181cc30d6f114e7~tplv-k3u1fbpfcp-watermark.image)

#### 2) 静态资源(css/js/img)使用CND引入

浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。

![image-20201119221157741.png](https://i.loli.net/2021/04/09/c2ZFgNI75WtVAze.png)



### 缓存优化 ??

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。



- HTML：使用协商缓存。
- CSS、JS和图片：使用强缓存，文件命名带上hash值



### 其他

#### vue-cli3 已有优化

> https://juejin.cn/post/6844904083858407438

webpack4中，`mode`为`production`时会自动开启**代码压缩**和`Tree Shaking`















## React

### 基础

- JSX语法最终都会经过babel编译，编译成JS语法
- 组件名首字母必须大写，JSX一旦标签首字母小写就会当做html元素解析，但是html中没有这个元素就会报错
- 内部返回虚拟DOM对象元素必须有结束符
- 必须要保证更新的数据是一个全新数据（不能push unshift等）
- Fragment  能作为多个虚拟DOM元素的根节点    优点：不会生成真实DOM元素   简写方式<></>

#### 通信方式

- props

  用PropTypes限制传入类型

- refs

  xxx = React.createRef()，再作用在标签上

- 消息订阅(subscribe)-发布(publish)机制

  import PubSub from 'pubsub-js' //引入

  PubSub.subscribe('delete', function(msg,data){ }); //订阅

  PubSub.publish('delete', data) //发布消息

- context  内部包含两个组件

  context.Provider 提供者（负责向后代组件提供数据）

  context.Consumer 消费者（负责消费数据，使用父（爷）组件提供的数据）

- forwardRef，获取工厂/纯函数组件的ref

  函数组件通过第二个参数接收ref

- render props

  本质上是一个组件，将B组件渲染到A组件内部，同时A组件传递必要的props（往往是属性数据，而不是方法）

  ```react
  <A render={(count) => {return <B count={count} />;}}/>
  ```

- 总结：

  触发事件元素和要收集数据元素是同一个元素，就e.target

  触发事件元素和要收集数据元素不是同一个元素，就用refs

#### 生命周期函数

**始化流程**

- constructor
- componentWillMount    将要挂载
- render     开始执行
- componentDidMount     挂在完成

**更新流程（三种方式触发）**

1. 父组件this.setState导致子组件重新渲染，子组件会触发：

   componentWillReceiveProps	将要接收数据

   shouldComponentUpdate	

   componentWillUpdate

   render

   componentDidUpdate	更新完成

2. 父组件this.setState, 父组件触发：

   shouldComponentUpdate

   componentWillUpdate

   render

   componentDidUpdate

3. 父组件this.forceUpdate, 父组件触发：

   componentWillUpdate

   render

   componentDidUpdate 

**卸载**

- componentWillUnmount 

  直接将之前插入到指定容器的DOM结构直接移除

  页面上没有该内容  

**即将废弃的生命周期**

- componentWillMount
- componentWillUpdate

**新的生命周期**

- static getDerivedStateFromProps(props, state){}

  用来取代willMount和willUpdate

  render 方法之前调用，并且在初始挂载及后续更新时都会被调用

  返回一个对象来更新 state，如果返回 null 则不更新任何内容

#### 重要生命周期函数

- componentDidMount

  发送请求、设置定时器、绑定事件等一次性任务

- shouldComponentUpdate    做性能优化

  返回值 true 要更新

  返回值 false 不更新

- componentWillUnmount

  取消请求、清除定时器、解绑事件等收尾工作

#### 高阶组件：HOC

- 本质上是一个函数：执行函数接受一个组件作为参数，返回值是一个新组件
- 给高阶组件命名 --> displayName优先级最高
- 可用高阶函数的形式传参
- 可用装饰器语法调用

#### Hooks（钩子）

- 本质就是函数，能让你使用React组件的状态和生命周期函数...

- 作用：让代码更加可复用，不用在定义繁杂的HOC

- 使用：

  - 让工厂函数组件拥有状态数据state

    `const [状态数据（初始化为defaultValue）, 更新状态数据的方法] = React.useState(defaultValue)`

  - 让工厂函数组件拥有生命周期函数（componentDidMount componentDidUpdate componentWillUnmount）

    ```react
    React.useEffect(() => {
        return () => {
          PubSub.unsubscribe("MSG");
        };
    },[])
    ```

#### react-router

- **Hash 模式** 

  兼容性好

  缺点带#

  刷新页面时只会把#前面地址发请求

- **History 模式**

  兼容性稍差

  地址很干净

  刷新页面时会把所有地址带上发请求（导致开发时刷新浏览器404问题）

  解决方法：

  ​		出现404，就直接返回 index.html

  ​		webpack配置devServer historyApiFallback: true

  问题：引入资源（css/js）路径问题

  ​		webpack配置output publicPath: "/"

  ​		index.html --> "/bootstrap.css"

- **API**

  ```react
  import {
    BrowserRouter,HashRouter,Link,NavLink,Route,Redirect,Switch,
  } from "react-router-dom";
  ```

- **路由组件三大属性（都在props上）**

  location     pathname 当前路由地址    state 

  history       push/replace/goBack/goForward/listen 等方法，用来操作浏览历史记录

  match        params 参数
  
- **特点**

  1. 默认是模糊匹配，如果想要精准匹配，需要给Route标签添加一个属性 exact
  2. 默认每次匹配都会匹配所有注册路由
  3. 性能优化相关： Switch, 一旦有匹配成的路由就停止匹配

- **路由传参**

  1. params传参

     ```react
     <Route path='/home/:id' component={Home}></Route>
     ```

  2. props 传参

     ```react
     <Route path='/personal' render={() => <Personal num={123}/>}></Route>
     ```

     

### 面试

#### 工厂函数组件和ES6类组件的区别

1. this不一样

   工厂函数没有this，ES6类组件函数中有this

2. 功能不一样

   工厂函数没有this，有些功能默认实现不了；ES6类组件有this，所以可以实现 

- 总结

  工厂函数组件一般用来定义功能简单组件

  ES6类组件一般用来定义功能复杂组件

#### 函数柯里化

- 是闭包的典型应用

```react
// 普通函数
function fn(a, b) { return a + b}
// 经过函数柯里化处理的函数
function fn(a) {
  return function (b) {
    return a + b;
  }
}
```

#### 性能优化

- 减少render调用次数，从而减少diff比较和重新渲染次数

1. 自己编写shouldComponentUpdate（nextProps, nextState）函数进行优化

2. PureComponent：组件内部实现了一种类似shouldComponentUpdate的比较

   ```react
   import { PureComponent } from "react";
   export default class Index extends PureComponent {}
   ```

- shouldComponentUpdate 和 PureComponent 同时存在只会生效 shouldComponentUpdate

#### Portals

- Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
- 通常情况下不会使用，一般用于Modal组件 
- 防止组件卸载/重新创建过程中创建多个div

#### 如何遍历显示子路由

- 没有通过Route加载，所以没有路由组件三大属性

- 解决：react-router-dom有一个高阶组件withRouter，withRouter内部保存路由组件的三大属性，会给被包装组件传递三大属性

- 判断routes中哪个配置匹配上当前路径

  forEach 一般写代码推荐forEach，语义化更好，一般用于要全部遍历的场景

  for循环 一般写库或框架，追求极致性能使用。性能好，一般用于遍历可中断的场景

- 判断 当前路径是否以一级菜单开头：

  String.prototype.startsWith()

  正则表达式

注意：

​		如果Route组件不加exact属性（严格模式），则会默认匹配以该路径开头的组件

#### 虚拟DOM的diff算法

**diff 策略**

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

- 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。

**tree diff**

- 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。

- 即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

- 如果出现了 DOM 节点跨层级的移动操作，性能不好!

**component diff** 

- 如果是同一类型的组件，按照原策略继续tree diff。

* 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。

* 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。

**element diff**

- 允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！

- 通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动

- 在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

### 深入理解setState

- **setState()更新状态的两种写法:**

  setState(stateChange,[callback])--------对象式的setState

  setState(updater,[callback])---------函数式的setState

- **setState()更新状态的动作是同步还是异步的**？（setState()执行的位置对其后续动作的影响）

  在由react所控制的回调函数中更新的动作是【异步】的，如：生命周期钩子 / react所监听的事件

  在非react控制的异步回调函数中更新的动作是【同步】的，如：定时器的回调 / 原生事件监听回调 /Promise所指定的成功、失败回调 / ajax所指定的成功或失败的回调

- **关于异步的setState()连续多次调用的问题**

  1. 多次调用，如何处理？

     若是对象式的setState，多次更新状态的动作合并为一次(只以最后一次为准),所以就调用一次render

     若是函数式的setState，每次更新的动作都会生效(更新的动作不合并)，但是只会调用一次render

  2. 注意：

     若函数式setState和对象式setState混用的时候，要把函数式写在最后

  3. 如何得到异步更新后的状态？

     在setState第二个参数的回调里





## 移动端

### 基础知识

- 1英寸(inch) = 2.54厘米(cm)

-  IPhone 6 的屏幕分辨率为 750 * 1334  设备独立像素为 375 * 667

- 物理像素：由屏幕制造商决定，屏幕生产后无法修改

- css像素：单位是px，它是为 Web 开发者创造的

- 设备独立像素的出现，使得即使在【**高清屏**】下，也可以让元素有正常的尺寸，让代码不受到设备的影响，它是设备厂商根据屏幕特性设置的，无法更改。

- 1个位图像素对应1个物理像素，图片才能得到完美清晰的展示

- pc端视口：默认宽度和浏览器窗口的宽度一致，也被称为初始包含块`document.documentElement.clientWidth`

- 移动端视口:

  - 布局视口：一般是**<span style='color:red'>980px</span>**左右，布局视口经过压缩后，横向的宽度用css像素表达就不再是375px了，而是980px

  - 视觉视口：用户可见的区域，它的绝对宽度永远和设备屏幕一样宽

  - 理想视口：布局视口宽度 与 屏幕等宽（设备独立像素），靠meta标签实现

    ```html
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    ```

### 适配

#### 1.viewport 适配

- 方法：拿到设计稿之后，设置布局视口宽度为设计稿宽度，然后直接按照设计稿给宽高进行布局即可。
- 一般适用于：计图稿宽度 < 375

```js
<meta name="viewport" content="width=375">
```



#### <span style="color:#ee0b41">2.rem适配</span>

- 方案一：（百度）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小 = **( 当前设备横向独立像素值 *100) / 设计稿宽度**</span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / 100** </span>
  4. 增加 JS 代码进行实时适配
- 方法二：（淘宝、搜狐、唯品会）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小  = **当前设备横向独立像素值 / 10** </span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / (设计稿宽度 / 10)**</span>
  4. 增加 JS 代码进行实时适配

#### 3.vw适配

vw和vh是两个相对单位

- 1vw = 等于布局视口宽度的1%
- 1vh = 等于布局视口高度的1%

#### 4.1px物理像素边框

高清屏幕下 1px 对应更多的物理像素，所以 1 像素边框看起来比较粗，解决方法如下

##### 方法一

使用媒查询：

```css
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo{
        border: 0.5px solid black;
    }
}
或
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo2::after{
        transform:scaleY(0.5);
    }
}
```

##### 方法二

根据dpr扩大布局视口，例如dpr为n则布局视口改为原来的n倍，则元素尺寸均变为原来的n分之一，为了保证元素尺寸比例不变，扩大根字体为原来的n倍，但整个过程中边框一直用px作为单位，不用rem。

1. rem 页面布局

2. 元素的边框设置为 1px

3. 通过 viewport 中的 initial-scale 将布局视口扩大n倍，这样页面元素就比原来缩小了n倍

```js
var viewport = document.querySelector('meta[name=viewport]')
var scale = 1 / window.devicePixelRatio
viewport.setAttribute('content', 'width=device-width,initial-scale=' + scale);
```

4. 重新设置根元素字体

```js
var fontSize = parseInt(document.documentElement.style.fontSize);
document.documentElement.style.fontSize = fontSize * window.devicePixelRatio + 'px'
```

### 移动端事件

* touchstart   元素上触摸开始时触发
* touchmove   元素上触摸移动时触发
* touchend   手指从元素上离开时触发
* touchcancel   触摸被打断时触发

### 移动端中touchstart,touchend,click执行顺序

- touchstart
- touchend
- click，浏览器在 click 后会等待约300ms去判断用户是否有双击行为，如果300ms内没有再一次click，那么就判定这是一次单击行为

### 点击穿透

- touch 事件结束后会默认触发元素的 click 事件

  方法一：阻止默认行为

  方法二：使背后元素不具备click特性，用touchXxxx代替click

  方法三：让背后的元素暂时失去click事件，300毫秒左右再复原，属性`pointer-events: none;`

  方法四：让隐藏的元素延迟300毫秒左右再隐藏

### getComputedStyle

- 可读取到非内联样式上的属性
- 可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式



### viewport

#### 设备像素(device pixel)

又名物理像素, 从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为`pt`

#### 设备独立像素

设备独立像素简称 DIP （device-independent pixel），又称：**屏幕密度无关像素**。表示*与设备无关的逻辑像素*，<span style="color:blue">代表可以通过程序控制使用的虚拟像素</span>。是一个总体概念，包括了`css`像素。可以理解为：<span style="color:blue">`CSS像素 = 设备独立像素 = 逻辑像素`。</span>在`iOS`、`Android`和`React Native`开发中样式单位其实都使用的是设备独立像素。

出现的原因?

更高分辨率的屏幕诞生.理论上来讲，在白色手机(分辨率320\*480)上相同大小的图片和文字，在黑色手机(分辨率640\*960)上会被缩小一倍，因为它的分辨率提高了一倍。

获取

在`javaScript`中可以通过`window.screen.width/ window.screen.height` 查看

#### 设备像素比

##### 是什么

设备像素比dpr(device pixel ratio), 单一方向上【设备像素】除以【设备独立像素】的比值，用于描述整个渲染环境在硬件设备上的缩放程度。

##### 获取

`window.devicePixelRatio`来帮助我们获取`dpr`。



#### 布局视口

获取

`document.documentElement.clientWidth / clientHeight`

设置

如果显式设置布局视口,可以使用HTML中的meta标签

```javascript
<meta name='viewport' content="width=400"
```

布局视口使移动端浏览器屏幕宽度与视口完全独立开来. CSS将根据它来进行计算,并被它约束.



#### 视觉视口

视觉视口(`visual viewport`)：用户通过屏幕真实看到的区域。

视觉视口默认等于当前浏览器的窗口大小<span style="background: #ccc">（包括滚动条宽度）</span>。

用户可以通过缩放操作视觉视口,同时不会影响布局视口.

<u>获取:</u>

```javascript
window.innerwidth / innerHeight
```



#### 理想视口

调用`screen.width / height`来获取理想视口大小。

上面在介绍`CSS像素时`曾经提到`页面的缩放系数 = CSS像素 / 设备独立像素`，实际上说`页面的缩放系数 = 理想视口宽度 / 视觉视口宽度`更为准确。????

所以，当页面缩放比例为`100%`时，`CSS像素 = 设备独立像素`，`理想视口 = 视觉视口`。

移动设备一般具有固定的DPR,即在缩放100%时, 用多少个物理像素显示一个逻辑像素,在CSS中就是用多少个物理像素来显示一个CSS像素.

> 理想视口宽度 = 移动设备横向分辨率 / DPR



#### 视口设置

移动设备默认的`viewport`是`layout viewport`，也就是那个比屏幕要宽的`viewport`，但在进行移动设备网站的开发时，我们需要的是`ideal viewport`。那么怎么才能得到`ideal viewport`呢？这就该轮到`meta`标签出场了。

借助`meta`元素的`viewport`来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maxium-scale=1, user-scalable=no">
```



`viewport`配置的具体含义：

| name          | 可能值                | 描述                                                         |
| :------------ | :-------------------- | :----------------------------------------------------------- |
| width         | 正整数或device-width  | 以pixels（像素）为单位， 定义布局视口的宽度。                |
| height        | 正整数或device-height | 以pixels（像素）为单位， 定义布局视口的高度。                |
| initial-scale | 0.0 - 10.0            | 定义页面初始缩放比率。This parameter sets the initial zoom level, which means **1 CSS pixel** is equal to **1 viewport pixel**. |
| minimum-scale | 0.0 - 10.0            | 定义缩放的最小值；必须小于或等于maximum-scale的值。          |
| maximum-scale | 0.0 - 10.0            | 定义缩放的最大值；必须大于或等于minimum-scale的值。          |
| user-scalable | 布尔值（yes或者no）   | 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。      |






## 小程序

### 1) 小程序特点

1. 体积小，压缩包的体积不能大于2M
2. 没有DOM对象
3. 基于组件化开发
4. 小程序环境不同于浏览器环境
   1. 浏览器环境中全局对象： window
   2. 小程序环境中全局对象：wx
   3. 小程序环境中没有window对象

### 2)小程序适配

1. 小程序适配单位： rpx(responsive px) 响应式单位
2. 小程序中规定所有的机型中页面宽度都是750rpx
3. iphone6: 1物理像素 = 0.5px = 1rpx ---> 1px = 2rpx
4. 小程序底层已经做了viewport适配

### 3) 小程序相关语法

1. 数据绑定

   1. 单项数据流: Model ---> view
   2. 修改状态数据： this.setData() 同步行为
   3. 页面中的数据均来自于data中，使用data中的数据的时候记住使用表达式{{}}
   
2. 事件绑定

   1. 事件分类： 冒泡事件 || 非冒泡事件
   2. 绑定的方式： bind + 事件名  || catch + 事件名
   
3. 路由跳转

   1. wx.navigateTo() || wx.redirectTo()
   
4. 本地存储
   1. 语法： 
      1. wx.setStorage() || wx.setStorageSync()
      2. wx.getStorage() || wx.getStorageSync()
   2. 注意点
      1. 单个key上限是1M
      2. 整体上限是10M
   
5. 全局传参

   app.js中可定义全局参数globalData

### 4) 向事件对象传参

1. 语法
   1. id=value
   2. data-key=value
2. 获取
   1. id: event.target.id || event.currentTarget.id
   2. data-key: event.target.dataset.key || event.currentTarget.dataset.key
3. 使用场景
   1. id：通常需要向event对象传递单一且唯一的标识
   2. data-key:   需要向event对象传递多个标识数据

### 5) 小程序获取用户唯一标识（openId）

1. 客户端先通过wx.login(获取code
2. wx.request()发送code给服务器
3. 服务器端发送请求携带参数(code, appSecret（开发密钥）, appId)给微信服务器获取openId
4. 微信返回openId给服务器后，服务器进行加密再返回给前端
5. 前端进行本地储存，下次发送请求时携带参数

### 6) 小程序支付流程

1. 用户在小程序客服端下单(包含用户及商品信息)
2. 小程序客户端发送下单支付请求给商家服务器
3. 商家服务器同微信服务器对接获取唯一标识openID
4. 商家服务器根据openId生成商户订单(包含商户信息)
5. 商家服务器发送请求调用统一下单API获取预支付订单信息
6. 商家对预支付信息签名加密后返回给小程序客户端
7. 用户确认支付（鉴权调起支付）
8. 微信服务器返回支付结果给小程序客户端
9. 微信服务器推送支付结果给商家服务器端


### 7) 面试问题

- Iphone6的dpr为多少？Iphone6Plus比Iphone6显示图像清晰吗？

  视网膜屏幕是分辨率超过人眼识别极限的高分辨率屏幕，Iphone4的dpr = 2; 人类肉眼分辨的极限
  
- 生命周期函数实际测试和官网描述有差

- wx.setStorage()，单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB

- 性能优化

  一个页面一次只有一个video标签，其余的使用image代替
  
- 请求相关

  小程序为了安全起见只支持Https请求

  wx.request最大并发限制10个

- 如何使用组件

  先创建组件，在对应的json文件下设置component: true

  到使用组件页面的json文件中，注册组件填写相应的路径

- 使用npm包

  下载后，勾选使用npm模块，再构建npm，会将node_modules中的包打包到miniprogram_npm中

- 分包相关

  分包后可解决2M限制，并且能分包加载内容，提高性能

  分包后单个包的体积不能大于2M，所有包的体积不能大于16M

  1. 常规分包

     加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容

     分包的页面可以访问主包的文件，数据，图片等资源

  2. 独立分包

     独立分包可单独访问分包的内容，不需要下载主包

     独立分包不能依赖主包或者其他包的内容

     通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页 || 活动页

  3. 分包预下载

     在加载当前包的时候可以设置预下载其他的包

     缩短用户等待时间，提高用户体验

### 7)-2小程序开发遇到的问题

```js
1.页面通信方式及注意事项
通信方式: 路由传参+storage
 路由传参只能通过query形式(原生小程序对query参数有长度限制,如果长度过长会自动截取.且会对query参数自动进行类型转换)
 wx.getStorage('cookies')

2.本地存储 有上限

3.请求
 协议: https请求
 并发数:10个
 
4.分包
4.1原因:程序要求压缩包体积小于2M;提高用户体验, 提高页面的加载速度
4.2形式
4.3特点:

5.性能优化:
5.1 视频优化 图片封面
5.2 
```



### 8) 开发相关

- setData行为始终是同步的
- H5中实现滑块功能，推荐大家使用：better-scroll

### 9) 封装

- 封装函数：

  1. 功能点明确

  2. 函数内部保留静态的数据

  3. 将动态的数据抽取出来作为形参，由使用者根据场景不同动态传入实参

- 封装组件：

  1. 功能点明确 || 呈现效果

  2. UI组件 || js组件

  3. 组件内部保留静态的数据

  4. 将动态的数据抽取出来作为 props属性，由使用者根据场景不同动态以标签属性的形式导入

  5. 封装良好的组件应该规定传入props数据的必要性还有数据类型 propsType

## express

### 基本使用

```js
// 引入
let express = require('express');
// 1. 生成应用实例
const app = new express(); // app: application 代表整个应用

// 3. 注册路由
app.get('/', (request, respone) => {
  console.log('1111');
  // 返回数据
  respone.end('success data');
});

app.get('/login', (req, res) =>  {
  console.log('2222');
  res.end('login data');
});

app.post('/register', (req, res) =>  {
  console.log('4444');
  res.end('register data');
});

// 2. 绑定监听(设置当前项目的端口号)
app.listen('3001', (err) => {
  if(err){
    console.log('服务器启动失败');
    console.log(err);
  }else {
    console.log('服务器启动成功');
    console.log('服务器地址： http://localhost:3001');
  }
})

```

### 2. 路由

1. 路由分类
   1. 前端路由
   2. 后端路由
2. 前端路由
   1. 发请求不需要走网络传输层
   2. 需要由前端指定的js库解析(vue-router, react-router-dom)
   3. 应用： SPA（single page application）
3. 后端路由
   1. 发请求需要走网络传输层
   2. 需要由服务器端解析
   3. 应用： 前后端交互

### 3. 路由参数

1. get请求
   1. params参数： 
      1. 请求： url/:id ==> url/参数
      2. 获取： req.params
   2. query参数:
      1. 请求：url?key=value&key2=value2
      2. 获取: req.query
   3. 总结:
      1. params参数只能有一个参数，适用于参数为标识数据
      2. query参数可以有多个
2. post请求
   1. params参数
   2. query参数
   3. body参数
      1. 相对安全
      2. 获取req.body，但是不能直接获取，需要使用中间键

### 4. res常用方法

1. res.end() 返回响应: 直接返回数据
2. res.send() 根据数据类型不同，自动做出判断处理，再返回，如：中文的话会自动设置content-type
3. res.set() 设置响应头的方法
4. res.json() 返回的数据一定是json数据，直接返回
5. res.cookie() 设置cookie
6. res.status() 设置状态码
7. res.redirect() 返回的是新地址，状态码通常是302，浏览器接收到响应以后会跳转至新的地址
8. res.download()  返回的文件信息，浏览器会自动下载该文件

### 5. 中间件

1. 本质
   1. 就是一个函数
2. 作用
   1. 处理请求，返回响应数据
   2. 获取，修改请求的参数及响应数据
   3. 执行下一个中间键
3. 体现形式
   1. (req, res, next) => {}
   2. req: 请求对象
   3. res: 响应对象
   4. next：是一个方法，用来调用下一个中间键
4. 注意
   1. 连续使用多个中间键的时候返回数据的动作应该放在最后且只有一次
   2. 路由对应的回调 也是中间键函数
   3. 如果请求方法和中间键共存的情况下，只能匹配一个，谁在前就匹配谁（满足匹配条件情况下）

## 问题

### 如何做到修改url参数页面不刷新

HTML5引入了 `history.pushState()` 和 `history.replaceState()` 方法，它们分别可以添加和修改历史记录条目。

```js
let stateObj = {
    foo: "bar",
};

history.pushState(stateObj, "page 2", "bar.html");
```

假设当前页面为 `foo.html`，执行上述代码后会变为 `bar.html`，点击浏览器后退，会变为 `foo.html`，但浏览器并不会刷新。



### 请用js去除字符串空格

去除所有空格

```text
str.replace(/\s/g, '')
```

去除两边空格

```text
str.replace(/^\s+|\s+$/g, '')
// 原生方法
str.trim()
```



### 格式化金钱，每千分位加逗号

```javascript
function format(str) {
    let s = ''
    let count = 0
    for (let i = str.length - 1; i >= 0; i--) {
        s = str[i] + s
        count++
        if (count % 3 == 0 && i != 0) {
            s = ',' + s
        }
    }
    return s
}


function format(str) {
    return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,')
}
```



### 服务端渲染

服务器端生成HTML直接返回给浏览器、减少网络传输、首屏渲染快、对搜索引擎友好 标准回答 SSR是Server Side Render简称；页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的html就可以了。和它对应的是，CSR是Client Side Render简称；客户端在请求时，服务端不做任何处理，直接将前端资源打包后生成的html返回给客户端，此时的html中无任何网页内容，需要客户端去加载执行js代码才能渲染生成页面内容，同时完成事件绑定，然后客户端再去通过ajax请求后端api获取数据更新视图。 

服务端渲染的优势：减少网络传输，响应快，用户体验好，首屏渲染快，对搜索引擎友好，搜索引擎爬虫可以看到完整的程序源码，有利于SEO。 

在Vue项目中实现服务端渲染方法：Vue在客户端渲染中也是采用一定方法将虚拟DOM渲染为真实DOM的，那么服务端的渲染流程也是通过虚拟DOM的编译来完成的，编译虚拟DOM的方法是renderToString。在Vue中，vue-server-renderer 提供一个名为 createBundleRenderer 的 API，这个API用于创建一个 render，并且自带renderToString方法。 

加分回答 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 

- 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 
- 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 

- 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。



### 保持前后端实时通信

保持前后端实时通信的方法有以下几种： 

轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。

* 优点就是实现简单，无需做过多的更改。
* 缺点是轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担  

长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，如果没有新消息，就一直等待。有新消息，才会返回给客户端。

* 在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。
* 优点是做了优化，有较好的时效性。
* 缺点是保持连接会消耗资源; 服务器没有返回有效数据，程序超时。

iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。

* 优点是消息能够实时到达；浏览器兼容好。
* 缺点是服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。 

WebSocket是类似Socket的TCP长连接的通讯模式，一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。缺点是浏览器支持程度不一致，不支持断开重连。 SSE(Server-Sent Event)是建立在浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。

SSE 是单向通道，只能服务器向浏览器发送，因为 streaming 本质上就是下载。 优点是SSE 使用 HTTP 协议，现有的服务器软件都支持。SSE 属于轻量级，使用简单；SSE 默认支持断线重连； 

轮询适用于：小型应用，实时性不高 长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天 iframe适用于：客服通信等 WebSocket适用于：微信、网络互动游戏等 SSE适用于：金融股票数据、看板等










## 自我介绍

```md
// 时间1分钟30秒左右

您好,面试官. 我叫xxx, 我面试的岗位是前端开发.
个人目前涉及的技术包括:
 vue2及vuex,vuerouter全家桶系列, UI框架包括elementUI, antUI, vantUI.
 熟悉原生JavaScript;
 了解react,python,SEO/SEM.搭建过Django博客,做过搜索引擎关键字排名及网站推广.
 同时个人也在github上翻译英文仓库.
 
个人做过的项目有:
	商城网站前后台
	国网APP下一个微应用
	
	商城网站用来为客户提供商品的展示和购买服务,使用vue2+elementUI,个人负责及参与的页面包括首页,详情页及支付购买页面.
	国网APP的微应用是是便于国网基层员工对用电单位进行多维度的信息普查工具,使用vue2+vant, 个人负责的是基本信息普查模块.
	
最后,我希望在新的工作岗位上能有更多项目历练及技术提升的机会.
```

