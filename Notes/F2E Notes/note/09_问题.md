## 资料来源

> https://gitee.com/zxfjd3g/review-211227/tree/master
>
> [Trivia questions in front end interviews | Front End Interview Handbook](https://www.frontendinterviewhandbook.com/zh/trivia/)
>
> 

## 标题大纲

[toc]











## HTML

### 资料收集

> [50道CSS基础面试题（附答案）](https://segmentfault.com/a/1190000013325778)
>
> 

### 标签语义化

什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。

#### 好处

- 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
- 方便其他设备解析，如盲人阅读器根据语义渲染网页
- 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。



### doctype有什么用

doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。

声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。 声明必须是HTML文档的第一行，位于html标签之前。

浏览器本身分为两种模式，<u>一种是标准模式，一种是怪异模式</u>，浏览器通过doctype来区分这两种模式，doctype在html中的作用就是触发浏览器的标准模式，如果html中省略了doctype，浏览器就会进入到Quirks模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而html标准和dom标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在html开头使用doctype。



### 行内元素和块级元素有哪些

#### 行内元素

一个行内元素只占据它对应标签的边框所包含的空间
一般情况下，行内元素只能包含数据和其他行内元素

```text
b span sup sub button input label select textarea


b, big, i, small, tt
abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var
a, bdo, br, img, map, object, q, script, span, sub, sup
button, input, label, select, textarea
```

#### 块级元素

占据一整行，高度、行高、内边距和外边距都可以改变，可以容纳块级标签和其他行内标签

```text
header,form,ul,ol,table,article,div,hr,aside,figure,canvas,video,audio,footer
```



### label标签有什么作用

`label` 标签通常是写在表单内，它关联一个控件，使用 `label` 可以实现点击文字选取对应的控件。

```html
<input type="checkbox" id="test">
<label for="test" >test</label>
```





### 写页面结构应该注意的

1. 尽可能少的使用没有语义的 div 和 span 元素
2. 块级元素和内联元素的嵌套一定要符合 web 标准，比如内联元素就是不能嵌套块级元素

### HTML5 新特性

1. 新的语义化元素：article 、footer 、header 、nav 、section
2. 表单增强，新的表单控件：calendar 、date 、time 、email 、url 、search
3. 新的 API：音频(用于媒介回放的 video 和 audio 元素)、图形（绘图 canvas 元素）
4. 新的 API：离线，通过创建 cache manifest 文件，创建应用程序缓存
5. 新的 API：本地存储，localStorage-没有时间限制的数据存储，sessionStorage-session 数据存储（关闭浏览器窗口数据删除）
6. 新的 API：实时通讯，设备能力

```js
1.新的语义化标签: header nav section article aside footer
2.  新增表单属性: input表单输入属性: 禁用disabled 非空验证required 自动获取autofocus 自动补全autocomplete
2.1.新增表单类型 Email url number month data
4.视频video音频audio,绘画的canvas
5.本地离线存储 
其他:
1.汉字加拼音 <ruby>汉字<rt>拼音</rt></ruby>
2.展开收起组件 <details open><summary>前端开始知识进阶</summary>lorem</detials>  //open默认展开
3.原生进度条和度量 progress  <progress vlaue='22' max='100'></progress>

```



### 遍历A节点的父节点下的所有子节点

```text
<script>
    var b=document.getElementById("a").parentNode.children;
    console.log(b)
</script>
```



### 为什么最好把 CSS 的`<link>`标签放在`<head></head>`之间？为什么最好把 JS 的`<script>`标签恰好放在`</body>`之前，有例外情况吗？

**把`<link>`放在`<head>`中**

把`<link>`标签放在`<head></head>`之间是<u>规范要求</u>的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。

**把`<script>`标签恰好放在`</body>`之前**

脚本在下载和执行期间会阻止 HTML 解析。把`<script>`标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。

例外情况是当你的脚本里包含`document.write()`时。但是现在，`document.write()`不推荐使用。同时，将`<script>`标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，`<script>`使用`defer`属性，放在`<head>`中。



### defer 与 async区别

html文件都是按顺序执行的，script标签中没有加defer和async时，浏览器在解析文档时遇到script标签就会停止解析阻塞文档解析，先加载JS文件，加载完之后立即执行，执行完毕后才能继续解析文档。 

而在script标签中写入defer或者async时，就会使JS文件异步加载，即html执行到script标签时，JS加载和文档解析同时进行，而async是在JS加载完成后立即执行JS脚本，阻塞文档解析，而defer则是JS加载完成后，在文档解析完成后执行JS脚本



## CSS



### css3新特性

```js
https://www.cnblogs.com/sunshinezjb/p/9335028.html

1.CSS3的选择器: 伪类选择器
2.@Font-face 特性
3.圆角
4.多列布局 （multi-column layout）
5.阴影（Shadow） 
6.CSS3 的渐变效果 
7.css弹性盒子模型

```



### 什么是渐进式渲染（progressive rendering）？

渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。

在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。

一些举例：

- 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。
- 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听`DOMContentLoaded`/`load`事件加载其他资源和内容。
- 异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。更多相关细节可以在[这里](http://link.zhihu.com/?target=http%3A//www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/)找到。





### link 与 @import 的区别

就结论而言，强烈建议使用`link`标签，慎用`@import`方式。

> https://segmentfault.com/a/1190000015950516

区别

**1.从属关系区别**
`@import`是 CSS 提供的语法规则，只有导入样式表的作用；`link`是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

**2.加载顺序区别**
加载页面时，`link`标签引入的 CSS 被同时加载；`@import`引入的 CSS 将在页面加载完毕后被加载。

**3.兼容性区别**
`@import`是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；`link`标签作为 HTML 元素，不存在兼容性问题。

**4.DOM可控性区别**
可以通过 JS 操作 DOM ，插入`link`标签来改变样式；由于 DOM 方法是基于文档的，无法使用`@import`的方式插入样式。

**5.权重区别(该项有争议，下文将详解)**
`link`引入的样式权重大于`@import`引入的样式。





### viewport

#### 设备像素(device pixel)

又名物理像素, 从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为`pt`

#### 设备独立像素

设备独立像素简称 DIP （device-independent pixel），又称：**屏幕密度无关像素**。表示*与设备无关的逻辑像素*，<span style="color:blue">代表可以通过程序控制使用的虚拟像素</span>。是一个总体概念，包括了`css`像素。可以理解为：<span style="color:blue">`CSS像素 = 设备独立像素 = 逻辑像素`。</span>在`iOS`、`Android`和`React Native`开发中样式单位其实都使用的是设备独立像素。

出现的原因?

更高分辨率的屏幕诞生.理论上来讲，在白色手机(分辨率320\*480)上相同大小的图片和文字，在黑色手机(分辨率640\*960)上会被缩小一倍，因为它的分辨率提高了一倍。

获取

在`javaScript`中可以通过`window.screen.width/ window.screen.height` 查看

#### 设备像素比

##### 是什么

设备像素比dpr(device pixel ratio), 单一方向上【设备像素】除以【设备独立像素】的比值，用于描述整个渲染环境在硬件设备上的缩放程度。

##### 获取

`window.devicePixelRatio`来帮助我们获取`dpr`。



#### 布局视口

获取

`document.documentElement.clientWidth / clientHeight`

设置

如果显式设置布局视口,可以使用HTML中的meta标签

```javascript
<meta name='viewport' content="width=400"
```

布局视口使移动端浏览器屏幕宽度与视口完全独立开来. CSS将根据它来进行计算,并被它约束.



#### 视觉视口

视觉视口(`visual viewport`)：用户通过屏幕真实看到的区域。

视觉视口默认等于当前浏览器的窗口大小<span style="background: #ccc">（包括滚动条宽度）</span>。

用户可以通过缩放操作视觉视口,同时不会影响布局视口.

<u>获取:</u>

```javascript
window.innerwidth / innerHeight
```



#### 理想视口

调用`screen.width / height`来获取理想视口大小。

上面在介绍`CSS像素时`曾经提到`页面的缩放系数 = CSS像素 / 设备独立像素`，实际上说`页面的缩放系数 = 理想视口宽度 / 视觉视口宽度`更为准确。????

所以，当页面缩放比例为`100%`时，`CSS像素 = 设备独立像素`，`理想视口 = 视觉视口`。

移动设备一般具有固定的DPR,即在缩放100%时, 用多少个物理像素显示一个逻辑像素,在CSS中就是用多少个物理像素来显示一个CSS像素.

> 理想视口宽度 = 移动设备横向分辨率 / DPR



#### 视口设置

移动设备默认的`viewport`是`layout viewport`，也就是那个比屏幕要宽的`viewport`，但在进行移动设备网站的开发时，我们需要的是`ideal viewport`。那么怎么才能得到`ideal viewport`呢？这就该轮到`meta`标签出场了。

借助`meta`元素的`viewport`来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maxium-scale=1, user-scalable=no">
```



`viewport`配置的具体含义：

| name          | 可能值                | 描述                                                         |
| :------------ | :-------------------- | :----------------------------------------------------------- |
| width         | 正整数或device-width  | 以pixels（像素）为单位， 定义布局视口的宽度。                |
| height        | 正整数或device-height | 以pixels（像素）为单位， 定义布局视口的高度。                |
| initial-scale | 0.0 - 10.0            | 定义页面初始缩放比率。This parameter sets the initial zoom level, which means **1 CSS pixel** is equal to **1 viewport pixel**. |
| minimum-scale | 0.0 - 10.0            | 定义缩放的最小值；必须小于或等于maximum-scale的值。          |
| maximum-scale | 0.0 - 10.0            | 定义缩放的最大值；必须大于或等于minimum-scale的值。          |
| user-scalable | 布尔值（yes或者no）   | 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。      |









### 盒模型

#### 是什么?

实质上是一个包围每个 HTML 元素的框。它包括：外边距、边框、内边距以及实际的内容。

#### 分类?

标准盒模型
替代(IE)盒模型

#### 差异

标准盒模型: 在标准模型中，如果你给盒设置 `width` 和 `height`，实际设置的是 *content's box*。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。
IE盒模型: 使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。



#### 切换

默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。
所有元素都使用替代模式，而且确实很常用，设置 box-sizing 在 `<html>` 元素上，然后设置所有元素继承该属性.

```css
html {
  box-sizing: border-box;
}

*, *::before, *::after {
  box-sizing: inherit;
}
```



页面渲染时，dom 元素所采用的 **布局模型**。可通过`box-sizing`进行设置。根据计算宽高的区域可分为：

- `content-box` (W3C 标准盒模型)
- `border-box` (IE 盒模型)
- `padding-box`
- `margin-box` (浏览器未实现)



#### 盒模型内部显示类型(了解)

css的box模型有一个外部显示类型，来决定盒子是块级还是内联。
同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 正常文档流 布局，也意味着它们和其他块元素以及内联元素一样(如上所述).

更改盒模型内部显示类型?

以通过使用类似 flex 的 display 属性值来更改内部显示类型。 该盒子的所有直接子元素都会成为flex元素，会根据 弹性盒子（Flexbox ）规则进行布局

#### 块级盒子 (block box) 和 内联盒子 (inline box)特点

盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽
每个盒子都会换行
width 和 height 属性可以发挥作用
内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”

如果一个盒子对外显示为 inline，那么他的行为如下:
盒子不会产生换行。
width 和 height 属性将不起作用。
垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。
水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。





### BFC

#### 描述一下


**Box**
Box 是 CSS 布局的对象和基本单位， 就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），
　

**Formatting context**
Formatting context 是是页面中的一块渲染区域，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。

最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC).CSS2.1 中只有 BFC和 IFC, CSS3 中还增加了 GFC和 FFC。

**BFC定义**
BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。



**CSS中的盒子类型**
block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；
inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；
run-in box: css3 中才有， 这儿先不讲了



#### 布局规则:

- 属于同一个 BFC 的两个相邻 Box 垂直排列
- 属于同一个 BFC 的两个相邻 Box 的上下 margin 会发生重叠 
- BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)即使存在浮动也是如此
- BFC 的区域不会与 float 的元素区域重叠
- 计算 BFC 的高度时，浮动子元素也参与计算 - 文字层不会被浮动层覆盖，环绕于周围

#### 生成BFC的元素

- 根元素
- 浮动元素: float属性不为none
- 绝对定位元素: position为absolute或fixed
- display
  - 行业块元素 `inline-block`
  - 表格单元格 `table-cell`
  - 表格标题 `table-caption`
  - 匿名表格单元格元素 `table` `table-row` `table-row-group`  `table-header-group` `table-footer-group` `inline-table`
  - 弹性元素 `flex` `inline-flex`
  - 网格元素 `grid` `inline-grid`
  - 多列容器 `column-count`或 `column-width`值不为`auto`

- overflow不为visible, clip的块元素

#### 应用:

- 阻止`margin`重叠
- 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个`div`都位于同一个 BFC 区域之中)
- 自适应两栏布局
- 可以阻止元素被浮动元素覆盖

```js
//https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context
//外边距塌陷
描述: 嵌套关系的两个块元素, 第一个子元素向上的外边距(margin-top),父元素会跟着掉下来,形成外边距塌陷(第二个不会出现塌陷)
解决方案:
 1.父元素设置开启BFC:浮动 float:left;父元素设置overflow:hidden;
 2.父元素设置上边框: border-top:1px solid red;
 3.子元素设置浮动: 两个子元素都需要设置浮动
 
 //浮动布局造成的父元素高度塌陷
 描述:浮动元素由于是脱离标准流状态,父元素在不设置固定高度时,会造成高度塌陷(高度0), 原因是父元素认为子元素没有占位置
 解决方案: 
 1.父元素设定固定高度
 2.父元素开启BFC: 父元素设置overflow:hidden/auto;或元素元设置float;...
 3.空盒子标签: 父元素最后设置一个块元素空盒子,设置clear属性清除浮动
 4.父元素调用clearFix类名
 .clearFix::after{
     content:'';
     /*相当于在父元素最后添加一个空盒子 after元素默认是一个行内元素 所以需要display转换成块元素 */
     display:box;
     clear:both;
 }
```







### 重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？

- **重置（Resetting）**： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像`margin`、`padding`、`font-size`这些样式全部置成一样。你将必须重新定义各种元素的样式。
- **标准化（Normalizing）**： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。

当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。





### 选择器优先级

#### 什么是选择器

是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式



#### CSS发生冲突遵循的原则

* 顺序 当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则
* 优先级  浏览器是根据优先级来决定当有不同选择器对应相同的元素的时候需要使用哪个规则
* 继承 
  * 后代元素可以继承父元素设置的**<font color="red">文本的属性</font>**
  * **不能继承**: <font color="red">父辈元素的width, height, 背景图,背景色等其他</font>
  * 继承的权重为0,优先继承离自己最近的父辈元素. 即使祖先元素使用 **!important**



#### 优先级

优先级就是 CSS 声明的一个<u>权重</u>，它由 匹配的选择器中的 <u>每一种选择器类型</u>的 数值 决定。

#### 计算优先级

<span style="color:blue">一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：</span>

1. **千位**： 如果声明在 [`style`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style) 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。
2. **百位**： 选择器中包含<u>ID选择器</u>则该位得一分。
3. **十位**： 选择器中包含<u>类选择器、属性选择器、伪类</u>则该位得一分。
4. **个位**：选择器中包含<u>元素、伪元素选择器</u>则该位得一分。

**注**: <span style="color:blue">通配符选择器 (`*`)，组合符 (`+`, `>`, `~`, ' ')，和否定伪类 (`:not`) 不会影响优先级。</span>



#### !important

有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算

覆盖 `!important` 唯一的办法就是另一个 `!important` 具有 相同*优先级* 而且顺序靠后，或者更高优先级。

最佳实践: 强烈建议除了非常情况不要使用它



### 浮动

#### 阐述float定位的工作原理

`float` CSS 属性指定一个元素应沿其容器的左侧或右侧放置，允许<u>文本和内联元素</u>环绕它。该元素从网页的正常流动（文档流）中移除，尽管仍然保持部分的流动性（与[绝对定位](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#absolute_positioning)相反）。

**浮动元素**是 `float` 的计算值非 `none` 的元素。

CSS 的`clear`属性通过使用`left`、`right`、`both`，让该元素向下移动（清除浮动）到浮动元素下面。

#### 浮动作用

* 设置浮动的图片，可以实现文字环绕图片;

* 设置了浮动的块级元素可以排列在同一行;

* 设置了浮动的行内元素可以设置宽高，同时可以按照浮动设置的方向对齐排列盒子。 

#### 设置浮动元素的特点

* 设置了浮动，该元素脱离标准文档流。元素不占位置 

* 浮动可以进行模式转换（行内块元素） 浮动造成的影响，使盒子脱离文档流，如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候父级盒子的高度就塌陷了，同时也会造成父级盒子后面的兄弟盒子布局受到影响。如果浮动元素后面还有其他兄弟元素，其他兄弟元素的布局也会受到影响。



#### 清除浮动

如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。

* `.clearfix::after` 给父元素添加一个类
* 空`<div>` + `clear:both` 
* 父元素开启bfc
  * 浮动
  * overflow
  * 其他等等



```css
.clearfix {
  content: '',
  display: block;
  clear:both;
}
```



### 阐述`z-index`属性，并说明如何形成层叠上下文（stacking context）

CSS 中的`z-index`属性控制重叠元素的垂直叠加顺序。`z-index`只能影响`position`值不是`static`的元素。

没有定义`z-index`的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。



### 解决不同浏览器样式兼容问题

- 在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。
- 使用已经处理好此类问题的库，比如 Bootstrap。
- 使用 `autoprefixer` 自动生成 CSS 属性前缀。
- 使用 Reset CSS 或 Normalize.css。



### 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？

- `visibility: hidden`：元素仍然在页面流中，并占用空间。
- `width: 0; height: 0`：使元素不占用屏幕上的任何空间，导致不显示它。
- `position: absolute; left: -99999px`： 将它置于屏幕之外。
- `text-indent: -9999px`：这只适用于`block`元素中的文本。
- Metadata： 例如通过使用 [http://Schema.org](http://link.zhihu.com/?target=http%3A//Schema.org)，RDF 和 JSON-LD。
- WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。



### 编写高效的 CSS 应该注意什么？

浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。

选择器匹配语句链越短，浏览器的匹配速度越快。

避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。

原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。

搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。



#### 去除浮动影响，防止父级高度塌陷

- 通过增加尾元素清除浮动
  - `:after / <br> : clear: both`

- 创建父级 BFC
- 父级设置高度

### `display`的属性值都有哪些？

- `none`, `block`, `inline`, `inline-block`, `table`, `table-row`, `table-cell`, `list-item`.

### `inline`和`inline-block`有什么区别？

|                              | `block`                                                     | `inline-block`                             | `inline`                                                     |
| ---------------------------- | ----------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 定位                         | 从新的一行开始，并且不允许旁边有 HTML 元素（除非是`float`） | 与其他内容一起流动，并允许旁边有其他元素。 | 与其他内容一起流动，并允许旁边有其他元素。                   |
| 能否设置`width`和`height`    | 能                                                          | 能                                         | 不能,设置会被忽略                                            |
| 可以使用`vertical-align`对齐 | 不可以                                                      | 可以                                       | 可以                                                         |
| 边距(margin)和填充(padding)  | 各个方向都存在                                              | 各个方向都存在                             | 只有水平方向存在。垂直方向会被忽略。 尽管`border`和`padding`在`content`周围，但垂直方向上的空间取决于'line-height' |
| 浮动（float）                | -                                                           | -                                          | 就像一个`block`元素，可以设置垂直边距和填充                  |

  

### 行内元素、块级元素区别

行内元素：和其他元素都在一行上，高度、行高及外边距和内边距都不可改变（边距上下方向不可改变，左右方向可以改变），文字图片的宽度不可改变，只能容纳文本或者其他行内元素；其中img是行元素

块级元素：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素；行元素转换为块级元素方式：display：block；



### `relative`、`fixed`、`absolute`和`static`四种定位有什么区别？

经过定位的元素，其`position`属性值必然是`relative`、`absolute`、`fixed`或`sticky`。

- `static`：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。
- `relative`：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。
- `absolute`：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。
- `fixed`：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。
- `sticky`：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 `table` 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。`position: sticky` 对 `table` 元素的效果与 `position: relative` 相同。



### 响应式设计与自适应设计比较

响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。

自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。



### display:none、visibile:hidden、opacity:0的区别

|                 | 是否隐藏 | 是否在文档中占用空间 | 是否会触发事件 |
| --------------- | -------- | -------------------- | -------------- |
| display: none   | 是       | 否                   | 否             |
| visible: hidden | 是       | 是                   | 否             |
| opacity: 0      | 是       | 是                   | 是             |



### 用css实现瀑布流

利用column-count和break-inside这两个CSS3属性即可

<iframe src="https://codesandbox.io/embed/staging-frog-598uwu?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="css3 瀑布流"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
   







### CSS 预处理器(Sass/Less/Postcss)

CSS 预处理器的原理: 是将类 CSS 语言通过 **Webpack 编译** 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能:

- 嵌套
- 变量
- 循环语句
- 条件语句
- 自动前缀
- 单位转换
- mixin 复用

```js
//less
0.嵌套 &代表当前选择器的父级.使用嵌套（nesting）代替层叠或与层叠结合使用

1.变量声明 @+变量名称=值
2.使用变量 
 2.1作为属性值
 2.2作为属性名 @{变量名称}
 2.3作为选择器 #@{变量名称} @{#变量名称}
 2.4


3.循环语句
4.条件语句

5.自动前缀




7.混入mixin
混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。
```



### **单行文本溢出**

```css
overflow: hidden;
white-space: nowrap;
text-overflow: ellipsis;
```

### **多行文本溢出**

```css
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2; // 最多显示几行
-webkit-box-orient: vertical;
```



### 利用伪元素画三角形

```css
.info-tab {
    position: relative;
}
.info-tab::after {
    content: '';
    border: 4px solid transparent;
    border-top-color: #2c8ac2;
    position: absolute;
    top: 0;
}
```



### 已知父级盒子的宽高，子级img宽高未知，想让img铺满父级盒子且图片不能变形

需要用到`css`的`object-fit`属性

```css
div {
    width: 200px;
    height: 200px;
}
img {
    object-fit: cover;
    width: 100%;
    height: 100%;
}
```



### css hack是什么

> [css中hack是什么 - 范仁义 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Renyi-Fan/p/9006084.html)

由于不同的浏览器，比如Internet Explorer 6,Internet Explorer 7,Mozilla Firefox等，对CSS的解析认识不一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。

这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。

这个针对不同的浏览器写不同的CSS code的过程，就叫CSS hack,也叫写CSS hack。



### 去除inline-block元素间间距的方法

> [去除inline-block元素间间距的N种方法 « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-去除间距/)

- 移除空格
- 使用margin负值
- 使用font-size:0
- letter-spacing
- word-spacing







### flex布局 //todo

#### 是什么?

Flexbox 是 CSS 弹性盒子布局模块（[Flexible Box Layout](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout) Module）的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。

该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。
试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。

#### 实现

只需要在想要进行 flex 布局的父元素上应用`display: flex` ，所有直接子元素都将会按照 flex 进行布局。

设为Flex布局以后，子元素的块级特性会消失;行内元素也可以设置flex布局;webkit内核的浏览器,必须加上`-webkit`前缀.

#### 容器6属性

- **flex-direction** : row | row-reverse | column | column-reverse; 该属性定义了 子元素排列方向
- **flex-wrap：**nowrap | wrap | wrap-reverse; 该属性称"轴线"  不换行/换行/换行(第一行在下方)
- **flex-flow：** || ; `flex-direction`和`flex-wrap`的简写形式，默认值为`row nowrap`
- **justify-content:** flex-start | flex-end | center | space-between | space-around; 该属性定义了子元素在主轴上的对齐方式。
  - `flex-start`（默认值）：左对齐
  - `flex-end`：右对齐
  - `center`： 居中
  - `space-between`：两端对齐，项目之间的间隔都相等。
  - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
- **align-items: flex-start | flex-end | center | baseline | stretch; \定义项目在交叉轴上如何对齐。**
  - `flex-start`：交叉轴的起点对齐
  - `flex-end`：交叉轴的终点对齐。
  - `center`：交叉轴的中点对齐。
  - `baseline`: 项目的第一行文字的基线对齐。
  - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度
- **align-content: ** flex-start | flex-end | center | space-between | space-around | stretch; 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用



#### 元素6属性

* order 定义项目的排列顺序。数值越小，排列越靠前，默认为0
* flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大;如果都为1，等分剩余空间
* flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小;如果都为1，等分剩余空间
* flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
* flex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选
* align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性





### 圣杯布局和双飞翼布局 //???

```js
//口述

双飞翼:
1.结构: 
<div class="box">
    <div class="center">
        <div class="content">lorem</div>
	  </div>
	<div class="left">左侧</div>
	<div class="right">右侧</div>
</div>

2.样式
box高600 
center宽高占满box+左浮动,content的padding左右200px
left宽200高600+左浮动+左外边距-100%
right宽200高600+左浮动+左外边距-200px

圣杯:
1.结构
<div class="box">
  <div class="center">lorem</div>
	<div class="left">左侧</div>
	<div class="right">右侧</div>
</div>

2.样式:
box高600,左右外边距200px
center高600宽100%,左浮动
left宽200高600,左浮动+相对定位+left:-200px,margin-left:-100%
right宽200高600,左浮动+相对定位+left:200px,margin-left:-200px
```



### chrome浏览器中支持汉字最小像素是12px,如何显示更小的字体

```js
//之前webkit内核的浏览器是支持设置小于12px的，用这个-webkit-text-size-adjust:none;但是新版的webkit内核浏览器版本已经不再支持这个属性，实在要把字体设置小于12px，只能用css3的

-webkit-transform:scale(0.5)  

//html代码
<div class="minfontsize">最小字体</div>
//css代码
.minfontsize{
    -webkit-transform:scale(0.5);
}
```



### div水平垂直居中的 5 种方法

* flex
* position+left/top+margin
* position+left/top+transform
* position+(left/right/top/bottom) + margin
* tabel-cell + vertical-align



### css水平、垂直居中的写法，请至少写出4种？

*水平居中*

- 行内元素: `text-align: center`
- 块级元素: `margin: 0 auto`
- position:absolute +left:50%+ transform:translateX(-50%)
- `display:flex + justify-content: center`

*垂直居中*

- 设置line-height 等于height
- position：absolute +top:50%+ transform:translateY(-50%)
- `display:flex + align-items: center`
- display:table+display:table-cell + vertical-align: middle;



### reflow repaint

#### Reflow

当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。

#### Repaint

当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。

#### 引起Repaint和Reflow的一些操作

- 调整窗口大小
- 字体大小
- 样式表变动
- 元素内容变化，尤其是输入控件
- CSS伪类激活，在用户交互过程中发生
- DOM操作，DOM元素增删、修改
- width, clientWidth, scrollTop等布局宽高的计算

#### Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：

- 避免逐条更改样式。建议集中修改样式，例如操作className。
- 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置display:none的元素上操作，最后显示出来。
- 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。
- 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流



### href 与 src 区别

- href
  href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系
  若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。
- src
  src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。
  <u>当浏览器解析到src ，会暂停其他资源的下载和处理</u>（图片不会暂停其他资源下载），直到将该资源加载、编译、执行完毕，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。











## JS基础和高级

### 事件绑定方式

- 嵌入dom

```js
<button onclick="func()">按钮</button>
```

- 直接绑定

```js
btn.onclick = function(){}
```

- 事件监听

```js
btn.addEventListener('click',function(){})
```



### 事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

```javascript
<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>凤梨</li>
</ul>

// good
document.querySelector('ul').onclick = (event) => {
  let target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
  }
}

// bad
document.querySelectorAll('li').forEach((e) => {
  e.onclick = function() {
    console.log(this.innerHTML)
  }
})
```



### 事件循环

事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。



### 事件模型

- DOM0
  直接绑定

```js
<input onclick="sayHi()"/>

btn.onclick = function() {}
btn.onclick = null
```

- DOM2
  DOM2级事件可以冒泡和捕获 通过addEventListener绑定 通过removeEventListener解绑

```js
// 绑定
btn.addEventListener('click', sayHi)
// 解绑
btn.removeEventListener('click', sayHi)
```

- DOM3
  DOM3具有更多事件类型. DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：

```text
UI事件，当用户与页面上的元素交互时触发，如：load、scroll
焦点事件，当元素获得或失去焦点时触发，如：blur、focus
鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup
滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel
文本事件，当在文档中输入文本时触发，如：textInput
键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress
合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart
变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified
```

[https://www.jianshu.com/p/3acdf5f71d5b](http://link.zhihu.com/?target=https%3A//www.jianshu.com/p/3acdf5f71d5b)



### 如何自定义事件

> [创建和触发 events - 事件参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/Events/Creating_and_triggering_events)



初始化事件 

* const eventName = new Event('xxx')
* const evnetName = new CustomEvent('xxx', {'detail': elem.dataset.xxx})

绑定事件 elem.addEventListener('xxx', () =>{})

触发事件 elem.dispatchEvent(event)

#### 创建自定义事件

```
var event = new Event('build');

// Listen for the event.
elem.addEventListener('build', function (e) { ... }, false);

// Dispatch the event.
elem.dispatchEvent(event);
```

#### CustomEvent()

```javascript
var event = new CustomEvent('build', { 'detail': elem.dataset.time });


```



### target 与 currentTarget区别

event.currentTarget( ) 会返回当前触发事件的元素；

event.target( ) 会返回触发事件触发的源头元素。









### var, const, let的区别

- const定义常量, let/var定义变量
- const和let相对于var
  - 有块作用域
  - 没有变量提升
  - 不会添加到window上
  - 不能重复声明



### **执行上下文**

#### 是什么

当 JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

每个执行上下文都有3个属性:

* 变量对象(Variable object，VO)
* 作用域链(Scope chain)
* this

#### 变量对象 是什么

变量对象是与执行上下文相关的<span style="color:red">数据作用域</span>，存储了在上下文中定义的变量和函数声明。

全局上下文中的变量对象就是全局对象

函数上下文中的变量对象(活动对象)是进入函数上下文时被创建的

#### 执行过程中变量对象的3条规则

执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：

1. 进入执行上下文
2. 代码执行

当进入执行上下文时，这时候还没有执行代码，

变量对象会包括：

1. 函数的所有形参 (如果是函数上下文)
   - 创建由名称和对应值组成的一个变量对象的属性
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 创建由名称和对应值（函数对象(function-object)）组成一个变量对象的属性
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 创建由名称和对应值（undefined）组成一个变量对象的属性
   - <span style="color:blue">如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</span>

以下为了解的内容: 

```javascript
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：

```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```



#### 代码执行

在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值

还是上面的例子，当代码执行完后，这时候的 AO 是：

```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```





### 作用域

#### 产生的背景

将变量引入程序带来的问题: 变量存储在哪里? 程序需要的时候如何找到它们?

#### 是什么

存储变量和查找变量的规则.



#### 变量查找案例 (`var a = 2`)

以`var a = 2`为例:

* 首先, 编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。
* 遇到`var a`，<span style="color:blue;">编译器会询问作用域</span>是否在同作用域集合中存在同名变量
  * 是 编译器会忽略该声明，继续进行编译；
  * 否 它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a
* 编译器为引擎运行生成所需的代码,用来处理a=2这个赋值操作.  <span style="color:blue;">引擎运行时会首先询问作用域</span>，在当前的作用域集合中是否存在一个叫作`a`的变量。
  * 是, 引擎就会使用这个变量
  * 否, 引擎会继续查找该变量
    * 找到, 就会将2赋值给它;
    * 没找到, 引擎就会举手示意并抛出一个异常！???

#### 引擎查找变量 两套 规则

查找变量的两种查询方式:

- LHS查询  “赋值操作的目标是谁（LHS） 一般出现在赋值操作的左侧
- RHS查询  “谁是赋值操作的源头（RHS）”  一般出现在赋值操作的右侧

#### 查询未声明变量的处理过程

在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。具体表现如下:

- RHS查询遍寻不到所需的变量,引擎会抛出`ReferenceError`异常
- LHS查询遍寻不到所需变量,
  - 非严格模式: 全局作用域会创建一个具有该名称的变量,并返还给引擎(非'严格模式'下)
  - 严格模式: 抛出同RHS查询失败时类似的`ReferenceError`异常
- RHS查询找到一个变量,但对变量进行不合理操作(例如,对函数类型进行调用,引用null/undefined值中的属性), 引擎抛出`TypeError`.

> `ReferenceError` 同作用域判别失败相关
>
> `TypeError` 代表作用域判别成功了，但是对结果的操作是不合法的



#### 作用域的类型

作用域共有两种主要的工作模型。

- 词法作用域: 最为普遍的，被大多数编程语言所采用的。<span style="color:blue;">词法作用域就是定义在词法阶段的作用域</span>。
- 动态作用域，仍有一些编程语言在使用（比如Bash脚本、Perl中的一些模式等）



#### JS中的作用域类型

* 全局作用域
* 函数作用域
* 块作用域

#### JS函数作用域的特点(位置/调用/独立/局部/提升)

> 在某个位置独立调用,将会局部提升

* 函数的作用域由函数的<u>定义位置决定</u>,和函数的调用位置无关
* 函数作用域在函数调用时<u>创建</u>，在调用结束时<u>销毁</u>  
* 函数每次调用都会产生一个<u>新的</u>函数作用域，函数作用域之间<u>相互独立</u>
* 在函数作用域中声明的变量是 <u>局部变量</u>,只能在函数内部访问; 省略var或let，则变量默认会成为<u>全局</u>变量(不希望出现的情况)
* 在函数内部，使用var声明的变量和使用function开头的函数也会被<u>提升</u>



#### JS中的块作用域有哪些?

<u>with</u>

用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。

<u>try...catch</u>

其中声明的变量仅在catch内部有效

<u>let</u>

let关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说，let为其声明的变量<span style="color:blue;">隐式地劫持了所在的块作用域</span>



#### JS块作用域 作用

1.垃圾收集

让引擎清楚地知道没有必要继续保存某些数据

```javascript
function process(data) {
  //...
}
{ //在这个块中定义的内容完事可以销毁
	var someReallyBigData = {};
	process(someReallyBigData);
}

//
```

<u>2.let循环</u>

<span style="color:blue">for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</span>

下面通过另一种方式来说明每次迭代时进行重新绑定的行为：

```javascript
{
  let j;
  for (j=0; j<10; j++) {
    let i=j; //每个迭代重新绑定
    console.log(i);
  }
}

//说明了几件事情?
//1. for循环内存在块作用域
//2. let声明的变量会绑定到循环的每一次迭代中
```

<u>3.创建块作用域变量</u>

可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。





#### 作用域的使用

> 基于作用域隐藏变量和函数





#### 作用域嵌套

是什么?

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。

查找规则?

引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。



#### 作用域链

定义

由多个执行上下文的<u>变量对象</u>构成的链表叫做作用域链. 当查找变量时,会,就会,全局....



### 执行上下文栈

#### 是什么

执行上下文栈（Execution context stack，ECS）来管理执行上下文
当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。





### 闭包

#### 定义

一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。

也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。



#### 如何产生

- 嵌套的内部函数引用了外部函数的变量, 当调用外部函数时就会产生闭包
- 闭包不是在调用内部函数时产生, 而是在定义内部函数对象时产生



#### 闭包作用

- 私有化变量, 延长局部变量的生命周期



#### 产生闭包/使用闭包/释放闭包

- 产生闭包: 内部函数对象创建时产生, 包含那个被引用的变量的容器(不是js对象)
- 使用闭包: 执行内部函数
- 释放闭包: 让内部函数对象成为垃圾对象, 断开指向它的所有引用



#### 应用

在<span style="color:red">定时器, 事件监听器,Ajax请求,跨窗口通信,Web Works或者其他的异步(或同步)任务</span>中,<span style="color:blue;"> 只要使用了回调函数,实际上就是在使用闭包.</span>



##### IIFE是闭包吗?

```javascript
var a = 2;
(function IIFE() {
  console.log(a);
})();
```

以上代码并不是严格的闭包:

* 因为函数（示例代码中的IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行
* a是通过普通的词法作用域查找而非闭包被发现的。



##### 循环和闭包

```javascript
for (var i=1; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i*1000)
}
```

延迟函数的回调会在循环结束时才执行. 即使每个迭代中执行的setTimeout(..., 0), 所有的回调函数依然是在循环结束后才被执行.

**代码的问题:**

我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。<u>但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。</u>

解决:

IIFE解决方案:

```javascript
//正确代码
for (var i=1; i<=5; i++) {
  (function() {
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j*1000)
  })()
}
//改进
for (var i=1; i<=5; i++) {
  (function() {
    setTimeout(function timer() {
      console.log(i);
    }, i*1000)
  })(i);
}
```



使用let代替IIFE

使用let声明来代替IIFE创建新的作用域

```javascript
for (var i=1; i<=5; i++) {
  let j=i; //闭包的块作用域
  setTimeout(function timer() {
    console.log(j);
  }, j*1000);
}
```



##### 模块

通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。



* 接收参数
* 命名将要作为公共API返回的对象

```javascript
var foo = (function CoolModule(id) {
  function change() {
    //修改公共API
    publicAPI.identify = identify2;
  }
  
  function identify1() {
    console.log(id);
  }
  
  function identify2() {
    console.log(id.toUpperCase());
  }
  
  var publicAPI = {
    change: change,
    identify: identify1
  };
  
  return publicAPI;
})('foo module');

foo.identify(); //'foo module'
foo.change();
foo.identify(); //'FOO MODULE'
```



其他后续内容, 笔记中记录的比较详细, 面试就说到这里吧





#### 缺点

* 内存泄露
* 内存溢出






#### 实例

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```

简要复述其执行过程:

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2. 全局执行上下文初始化
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
4. checkscope 执行上下文初始化，创建变量对象、作用域链、this等
5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
7. f 执行上下文初始化，创建变量对象、作用域链、this等
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

问题:

当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

<span style="color:red"> f 执行上下文维护了一个作用域链</span>：



#### 有一个函数，参数是一个函数，返回值也是一个函数，返回的函数功能和入参的函数相似，但这个函数只能执行3次，再次执行无效，如何实现

```javascript
function sayHi() {
    console.log('hi')
}

function threeTimes(fn) {
    let times = 0
    return () => {
        if (times++ < 3) {
            fn()
        }
    }
}

const newFn = threeTimes(sayHi)
newFn()
newFn()
newFn()
newFn()
newFn() // 后面两次执行都无任何反应
```



### 实现add函数,让add(a)(b)和add(a,b)两种调用结果相同

```javascript
function add(a, b) {
  if (b === undefined) {
    return function(x) {
       return a + x
    }
  }
  
  return a + b
}
```





### this

#### 介绍

* 执行上下文的一个属性
* 是在运行时进行绑定的,和函数声明的位置无关.



#### 使用原因

* 显式传递上下文对象会让代码越来越混乱
* 调用函数时候不用传递上下文对象, this隐式传递一个对象引用,API简洁易于复用



#### 绑定规则

* 默认绑定
  * 非严格模式下,函数直接调用,this绑定到window/globalThis; 严格模式下,this是undefined
* 隐式绑定
  * 调用位置上是否有上下文对象或者说是否被某个对象拥有或包含.(注意: 函数不属于对象,从作用域上来解释)
  * 规则:
    * 当函数引用有上下文对象时,隐式规则会把这个函数调用中的this绑定到这个上下文对象
    * <span style="color:red">对象属性引用链中只有最后一层在调用位置中起作用</span>
  * 存在的问题: 隐式丢失
    * 丢失绑定对象,会应用默认绑定.
  * 隐式丢失 几种情况
    * 将`对象.方法`赋值给变量,调用这个变量
    * 参数传递, 将函数是通过参数传递进函数
    * 把函数传入语言内置的函数
  * 隐式绑定存在问题
    * 隐式丢失中,无法控制回调函数的执行方式,也就无法控制调用位置以得到期望的值
    * 如何解决？ 固定this

* 显式绑定
  * 不想在对象内部包含函数引用，而想在某个对象上强制调用函数。  使用call/apply/bind
  * 如果call/apply第一个参数传入原始值？？
    * 装箱  基本类型转成它的对象形式
  * 显示绑定存在的问题（理解）
    * 虽然call和apply可以在任意地方调用,但是它是直接进行调用送的.设想,如果在某个第三方库中,其异步的回调函数需要改变this,如果这个时候使用call/apply会立即调用并更改this,异步在不知道完成与否的情况下,异步回调直接运行了.
* new绑定

使用new来调用函数,或者说发生构造函数调用时,会自动执行下面的操作:

1. 内存中新建一个对象
2. 将新建对象的隐式原型[[prototype]]指针赋值为构造函数的原型prototype
3. 这个新对象会绑定到函数调用的this
4. 如果函数返回非空对象,则返回;否则,返回新建对象.

```javascript
//隐式绑定丢失
//把函数传如语言内置的函数
function foo() {
  console.log(this.a)
}

var obj = {
  a:2,
  foo: foo
}

var a = 'oops, global!'
setTimeout(obj.foo, 100); //'oops, global'
//js内置的setTimeout函数和下面的伪代码类似
functionsetTimeout(fn, delay) {
  //delay
  fn()
}
```









### this在不同场景下的取值?

- 常规情况下, 函数中的this取决于执行函数的方式
  - fn(): 直接调用  ==> **this是?**  window
  - new fn(): new调用 ==> **this是?**  新建的对象
  - obj.fn(): 通过对象调用 ==> **this是?**  obj
  - fn.call/apply(obj): 通过函数对象的call/apply来调用 ==> **this是?**  obj

- 特殊情况:
  - bind(obj)返回的函数  ==> **this是?**  obj
  - 箭头函数 ==> **this是?**  外部作用域的this
  - 回调函数
    - 定时器/ajax/promise/数组遍历相关方法回调  ==> **this是?**  window 或 当前的事件源
    - vue控制的回调函数  ==> **this是?**  组件的实例
    - React控制的生命周期回调, 事件监听回调  ==>  **this是?**  组件对象 / undefined

- 如何控制函数的this?  
  - 利用函数的bind()
  - 利用箭头函数
  - 也可以用外部保存了this的变量

### 原型对象

#### 定义

每一个JavaScript对象(null除外)在创建的时候就会<u>与之关联另一个对象</u>，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。



### 原型链

#### 是什么

由相互关联的原型组成的<span style="color: blue">链状结构</span>

#### 原型链查找规则概述

- 当我们要获取一个对象的属性时,浏览器会先在对象自身中寻找
- 如果有则直接使用,如果没有则去对象的原型中寻找
- 找到了则使用,没有则去原型的原型里去寻找.以此类推, 直到找到Object的原型,如果依然没有找到则返回undefined
- Object的原型是所有对象的原型,它的原型没有原型



#### 原型链图例

![chian prototype](https://programmer.help/images/blog/d59acf5d5aca9dad1461354443dd7c17.jpg)








### 继承





#### **原型链继承**

> 子类原型 = 父类实例



缺点: 

 1.引用类型的属性被所有实例共享.(基本类型的值更改后不会被共享, 因为其他实例初始化后,)

 2.子类不能向父类中传参



#### **借用构造函数继承**

> 在子类构造函数中,通过call()/apply()调用父类构造函数

优点:

* 避免原型链继承中引用类型的属性被所有实例共享
* 可以在子类中向父类传参

缺点:

* 方法都在父类构造函数中定义,每次创建实例都会创建一遍方法

* 只能继承父类的实例属性和方法,不能继承其原型的属性/方法



#### 组合继承

> 原型继承 + 借用构造函数继承



优点: 融合原型链继承和构造函数的优点

缺点: 会调用两次父类的构造函数: 一次在子类的构造函数中call方法执行了一遍; 一次在在子类原型实例化为父类的实例时执行了一遍



```js
//方式一: 基于构造函数的继承: 原型链 + 借用构造函数的组合式继承
- 借用父类型构造函数: Person.call(this, name, age)
- 让子类的原型为父类的实例: Student.prototype = new Person()
- 让子类型原型的构造构造函数为子类型: Student.prototype.constructor = Student

// 父类型
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.fn = function () { console.log('aaa')}
Person.prototype.sayHello = function () {
  console.log(`我叫{this.name},年龄{this.$age}`);
}

// 子类型
function Student(name, age, price) {
  Person.call(this, name, age);
  this.price = price;
}
// 让子类原型为父类的实例
Student.prototype = new Person();
// 让原型对象的构造器为子类型
Student.prototype.constructor = Student;

Student.prototype.sayHello = function () {
  console.log(`名字${this.name},年龄${this.age},身价${this.price}`);
}

const s = new Student('tom', 12, 100)
s.sayHello();
s.fn();

//方式二: 基于class/类的继承
- 子类 extends 父类: class Teacher extends Person2
- 子类构造器中调用父类的构造: super(name, age)
 

class Teacher extends Person2 {
    constructor (name, age, course) {
      super(name, age)
      this.course = course
      Teacher.prototype.count++
    }
```



#### 原型式继承

> 将传入的对象赋值给临时构造函数的原型，然后返回这个临时构造函数的一个实例。
>
> 本质上，是对传入的对象执行了一次浅复制.

```javascript
function object(o) {
  function F()
  F.prototype = o
  return new F()
}
```



缺点:

跟原型链继承一样., 包含引用类型的属性值始终都会被所有实例共享



#### 寄生式继承

> 创建一个仅用于封装继承过程的函数,该函数在内部来增强对象(例如添加方法),最后返回对象



```javascript
function createObj(o) {
  let clone = Object.create(o)
  clone.sayName = function() {
    console.log('hi')
  }
  
  return clone;
}
```

缺点: 

跟借用构造函数模式一样,每次创建对象都会创建一遍方法



#### 寄生组合式继承

> 原型继承 + 借用父类构造函数 + 原型

组合式继承的最大缺点是会调用两次父构造函数. 一次是设置子类型实例的原型时;一次是创建子类实例时.

如何避免在子类构造函数中的重复调用呢?

```javascript
function Parent(name) {
  this.name = name;
  this.corlors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  console.log(this.name);
}

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

//关键步骤
function F() {}
F.prototype = Parent.prototype;
Child.prototype = new F();

let child1 = new Child('kevi', '18');
```

封装下这个方法

```javascript
function object(o) {
  function F() {};
  F.prototype = o;
  return new F();
}

function prototype(child, parent) {
  let prototype = object(parent.prototype);
  prototype.constructor = child;
  child.prototype = prototype;
}
```

> 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。





### 面向对象的3特征

- 封装:
  - 将可复用的代码用一个结构包装起来, 后面可以反复使用
  - js的哪些语法体现了封装性: 函数 ==> 对象 ==> 模块 ==> 组件 ==> 库
  - 封装都要有个特点: 不需要外部看到的必须隐藏起来, 只向外部暴露想让外部使用的功能或数据
- 继承
  - 为什么要有继承? 复用代码, 从而减少编码
  - js中的继承都是基于原型的继承: ES6的类本质也是
  - 编码实现: 原型链+借用构造函数的组合 / ES6的类继承
- 多态: 多种形态
  - 理解
    - 声明时指定一个类型对象, 并调用其方法,
    - 实际使用时可以指定任意子类型对象, 运行的方法就是当前子类型对象的方法
  - JS中有多态:
    - 由于JS是弱类型语言, 在声明时都不用指定类型
    - 在使用时可以指定任意类型的数据 ==> 这已经就是多态的体现了





### 防抖节流原理及应用



#### 使用背景

如果是复杂的回调函数或是 ajax 请求呢? 假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。出现防抖和节流两种方案.

(高频操作导致一定时间内不能实现函数的全部功能,进而导致卡顿)

#### 应用场景

函数防抖:连续的事件,只需触发一次回调场景:搜索框输入,只能用户最后一次输入完,再发请求;浏览器窗口大小变化
函数节流:间隔一段事件执行一次的场景:滚动加载;高频点击提交,表单的重复提交; 多级分类列表



#### 防抖原理

* 在事件<span style="color:red">触发 n 秒后才执行</span>;

* 如果你在一个事件触发的 n 秒内又触发了这个事件，以新的事件的时间为准，n 秒后才执行.

```javascript
function debounce(fn, wait) {
  let timeId
  return function() {
    clearTimeout(timeId)
    timeId = setTimeout(fn, wait)
  }
}

//2 version  修复this 与 事件对象传递
function debounce2(fn, wait) {
  let timeId
  return function() {
    if (timeId) clearTimeout(timeId)
    let thisArg = this
    let args = arguments
    timeId = setTimeout(() => fn.apply(thisArg, args), wait)
  }
}

//3 version 立即执行  
function debounce3(fn, wait, immediate) {
  let timeId
  return function() {
    let thisArg = this, args = arguments
    
    if (timeId) clearTimeout(timeId)
   	
    if (immediate) {  //这个立方总是理解不好
      let callNow = !timeId
      timeId = setTimeout(() => {timeId = null} , wait)
      if (callNow) fn.apply(thisArg, args)
    } else {
      timeId = setTimeout(() => {fn.apply(thisArg, args)}, wait)
    }
  }
}


//其他
/* 
实现函数防抖的函数
*/
function debounce(callback, delay) {
  return function (event) {
    console.log('debounce 事件...')
    
    // 清除待执行的定时器任务
    if (callback.timeoutId) {
      clearTimeout(callback.timeoutId)
    }
    // 每隔delay的时间, 启动一个新的延迟定时器, 去准备调用callback
    callback.timeoutId = setTimeout(() => {
      callback.call(this, event)
      // 如果定时器回调执行了, 删除标记
      delete callback.timeoutId
    }, delay)
  }
}



//使用案例
<span>节流input表单:</span><input id="inputNode" />
    
let inputNode = document.getElementById('inputNode');
function ajax(content){console.log('ajax request'+content)};

function debounce(callback,delay){
    //n秒内又触发,则会重新计时
    if(callback.timeoutId){ 
        clearTimeout(callback.timeoutId)
    }
    callback.timeoutId = setTimeout(()=>{
        callback(event);
        //callback.call(this,event)
        delete callback.timeoutId;
    },delay);  
}

let debounceAjax = debounce(ajax, 3000);
inputNode.addEventListener('keyup',function(e){
    debounceAjax(e.target.value)
})
```



#### 节流原理

<span style="color:red">每隔一段时间只执行一次事件</span>。

节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。



```js
//时间戳
function throttle(fn, wait) {
  let ctx, args;
  let start = 0
  return function() {
    let now = +new Date()
    ctx = this
    args = arguments
    
    if (now - start > wait) {
      fn.apply(ctx, args)
      start = now
    }
  }
}
//定时器
function throttle(fn, wait) {
  let timeId, start = 0
  return function() {
    let thisArg = this
    let args = arguments
    
    if (!timeId) {
      timeId = setTimeout(() => {
        timeId = null
        fn.apply(thisArg, args)
      }, wait)
    }
  }
}

//比较两个方法：

//1. 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行
//2. 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件

//时间戳 + 定时器方案


/* 
实现函数节流的函数
*/

function throttle(callback, delay) {
  let start = 0 // 必须保存第一次点击立即调用
  return function (event) { // 事件回调函数
      // this是发生事件的dom元素
    console.log('throttle 事件')
    const current = Date.now()
    if (current - start > delay) { // 从第2次点击开始, 需要间隔时间超过delay
      callback.call(this, event)
      // 将当前时间指定为start, ==> 为后面的比较做准备
      start = current
    }
  }
}

<span>节流input表单:</span><input id="inputNode" />
    
let inputNode = document.getElementById('inputNode');
function ajax(content){console.log('ajax request'+content)}

function throttle(callback,delay){
    let start = 0;
    return function(event){
        let current = Date.now();
        if(current-start>delay){
            callback.call(this,event);  //用不用call, 不用
            start = current;
        }
    }
}

let throttleAjax = throttle(ajax,2000);
inputNode.addEventListener('keyup', function(e){
    throttleAjax(e.target.value)
})

```



### 白屏时间

白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。

Performance 接口可以获取到当前页面中与性能相关的信息,该类型的对象可以通过调用只读属性 Window.performance 来获得。

performance.timing.navigationStart: PerformanceTiming.navigationStart 是一个返回代表一个时刻的 unsigned long long 型只读属性，为紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。

所以将以下脚本放在 `</head>` 前面就能获取白屏时间。

```html
<script>
	new Date() - performance.timing.navigationStart
</script>
```



### 模块化

ES6模块的暴露和引入语法

暴露: 分别暴露, 暴露对象, 默认暴露

```javascript
// 分别暴露
export const a = 'a'
export const b = 'b'

//暴露对象
const c = 'c'
const d = 'd'
export {
	c,
  d as dd
}

//默认暴露
export default function foo() {}

```

引入: 通用引入; 解构赋值形式引入; 简便导入

```javascript
import * as m1from './m1'

//解构赋值形式引入
import {default as aaa} from 'xx.js'

//简便导入
import _ from 'lodash'
```







## 3. 异步相关

### 事件循环

#### 单线程非阻塞

* 单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。
* 单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。
* 非阻塞则是当代码需要进行一项异步任务的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调



#### 是什么


1.js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。

2.当一个异步事件返回结果后，js会将这个事件加入到<u>事件队列</u>。

3.当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。

3.1如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...

4.如此反复，这样就形成了一个无限的循环。

这就是这个过程被称为“事件循环（Event Loop）”的原因。



#### 宏任务和微任务

执行顺序:

**当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行**。

宏任务有:  定时器，Dom事件，ajax事件

微任务有：promise的回调、MutationObserver 的回调 ,process.nextTick

### 界面渲染流程

```js
//界面第一次渲染:
初始化同步任务->所有微任务->渲染界面->执行第一个宏任务->所有微任务->渲染界面->执行第一个宏任务

//界面更新渲染:
所有微任务->渲染界面->执行第一个宏任务.
总结:清空微队列中的所有微任务->渲染界面(UI线程)->执行宏队列中的第一个宏任务

```



### 实例

```html
<ul>
    <li>aaa</li>
    <li>bbb</li>
    <li>ccc</li>
</ul>
<button id="test">test</button>
<div id="content">
    aaaaaaa
</div>
<script>
    Promise.resolve().then(() => { // 微任务
        alert('promise1')
    }) 
    Promise.resolve().then(() => { // 微任务
        alert('promise2')
    }) 
    setTimeout(() => {// 宏任务
        alert(document.getElementById('content').innerHTML) 
    }, 0)
    document.getElementById('test').onclick = () => {// 宏任务
        document.getElementById('content').innerHTML = 'xxxx'  // dom渲染  
        Promise.resolve().then(() => { // 微任务
            alert('promise3')
        }) 
        setTimeout(() => {// 宏任务
            alert(document.getElementById('content').innerHTML) 
        }, 0);
    }
</script>
```









### 宏任务与微任务

- 宏任务: setTimeout, setInterval, Ajax, DOM事件监听
- 微任务: Promise, async/await, mutationobserver(H5)

### 宏队列与微队列

- 宏队列: 用来保存n个宏任务的队列容器
- 微队列: 用来保存n个微任务的队列容器

### event loop2(宏任务 & 微任务)

- js-web中的dom事件回调, 定时器回调与ajax回调异步执行, 都是基于event loop   ===> 宏任务
- H5新的MutationObserver也基于event loop   ==> 微任务
- promise成功和失败的回调也是异步执行的, 也是基于event loop  ==> 微任务
- 执行顺序:
  - 第一步: 先执行script下的所有同步代码
  - 第二步: 再依次取出微列中的所有微任务执行
  - 第三步: 再取出宏队列中第一个宏任务执行
  - 再循环第二步与第三步



### Promise的理解

#### 概述

> Promise 是异步编程的一种解决方案，比传统的回调函数和事件更好。
>
> 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，可以获取异步操作的消息。
>
> 

#### 优点

- ES6推出的新的更好的异步编程解决方案(相对于纯回调的方式)
  - 指定回调函数的时机更加灵活: 在异步操作启动前或完成后, 指定回调函数得到异步结果
  - promise链式调用解决嵌套回调的回调地狱问题 



- promise对象有3种状态
  - pending 
  - fulfilled 
  - rejected
- promise状态的2种变化
  - pending --> fulfilled
  - pending --> rejected
  - 注意:  变化是不可逆

### promise的then()的理解

- then()总是返回一个新的promise
- 新promise的结果状态由then指定的回调函数执行的结果决定
  - 抛出错误
  - 返回失败的promise
  - 返回成功的promise
  - 返回其它任何值



### Promise-API实现

| 静态方法                     | 作用                                                         | 其他 |
| ---------------------------- | ------------------------------------------------------------ | ---- |
| Promise.all(iterable)        | * 传入一个可迭代对象,返回一个promise<br/>* 当所有promise都resolve的时候, 新的 promise 才会 resolve，并且其结果数组将成为新 promise 的结果。<br/>* 当其中一个promise被reject, 立即返回这个reject,忽略其他promise |      |
| Promise.allSettled(iterable) | * 返回一个在所有给定的 promise 都已经`fulfilled`或`rejected`后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。<br/>* 适用于多个彼此不依赖的异步任务settled时, 或想知道每个promise的结果时 |      |
| Promise.any()                | 接收一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)可迭代对象，只要其中的一个 `promise` 成功，就返回那个已经成功的 `promise` 。 |      |
| Promise.race                 | 返回一个Promise,一旦迭代器中的某个promise解决或拒绝,返回的promise就会解决或拒绝. |      |
|                              |                                                              |      |





#### Promise.all

```javascript
//20220724
Promise.prototype.all = function (promises) {
	return new Promise((resolve, reject) => {
		// 判断是否为可迭代对象
		if (!Array.isArray(promises)) {
			throw new TypeError('promises must be an iterable object')
		}

		let resultArr = []
		promises.forEach((promise, idx) => {
			promise.then(
				value => {
					resultArr[idx] = value
					idx === (promises.length - 1) && resolve(resultArr)
				 },
				error => { 
					reject(error)
				}
			)
		})
	})
}
```



#### Promise.allSettled

```javascript
function allSettled(promises) {
  if (promises.length === 0) return Promise.resolve([])
  
  const _promises = promises.map(
    item => item instanceof Promise ? item : Promise.resolve(item)
    )
  
  return new Promise((resolve, reject) => {
    const result = []
    let unSettledPromiseCount = _promises.length
    
    _promises.forEach((promise, index) => {
      promise.then((value) => {
        result[index] = {
          status: 'fulfilled',
          value
        }
        
        unSettledPromiseCount -= 1
        // resolve after all are settled
        if (unSettledPromiseCount === 0) {
          resolve(result)
        }
      }, (reason) => {
        result[index] = {
          status: 'rejected',
          reason
        }
        
        unSettledPromiseCount -= 1
        // resolve after all are settled
        if (unSettledPromiseCount === 0) {
          resolve(result)
        }
      })
    })
  })
}
```



#### Promise.any

```javascript
function any(promises) {
  // return a Promise, which resolves as soon as one promise resolves
  return new Promise((resolve, reject) => {
    let isFulfilled = false
    const errors = []
    let errorCount = 0
    promises.forEach((promise, index) => promise.then(
      (data) => {
      if (!isFulfilled) {
        resolve(data)
        isFulfilled = true
      }
    }, 
      (error) => {
      errors[index] = error
      errorCount += 1

      if (errorCount === promises.length) {
        reject(new AggregateError('none resolved', errors))
      }
    }))
  })
}

//https://github.com/azl397985856/fe-interview/issues/125
Promise.any = ps => new Promise((resolve, reject) => {
  ps.forEach((p, idx) => p.then(resolve)).catch(err => idx === (ps.length - 1) && reject(new Aggregate('none resolved')))
})
```



#### Promise.race

```javascript
Promise.race2 = function(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach(promise => Promise.resolve(promise).then(resolve, reject))
  })
}
```



### async/await与promise的关系

- async/await是消灭异步回调的最终方法
- 简化promise对象的使用, 不用再使用then/catch来指定回调函数. 但和Promise并不互斥
- 执行async函数, 返回promise对象,  
  - await相当于promise的then
  - try...catch可捕获异常, 相当于promise的catch




### aysnc/await 概述

* `async`用来描述`async`函数的.函数的返回值为promise对象.
* promise对象的结果和状态由`async`函数的返回值决定. 返回规则和then方法回调返回结果是一样的.
  * 如果返回结果是非promise类型的值,则返回值是成功的promise
  * 抛出一个错误, 函数的状态为失败状态rejected, 错误值为函数返回值.
  * 如果返回结果是promise类型的值, 则promise的状态和值决定了async这个promise的状态和返回
* await右侧的表达式一般为promise对象, 但也可以是其它的值
    * 如果表达式是promise对象, await返回的是promise成功的值.如果是失败的值,await会把promise的异常抛出, 我们可以使用try..catch捕获错误.
    * 如果表达式是其它值, 直接将此值作为await的返回值

* await...后面的代码相当于放到成功的回调中





### 综合性执行流程题

```js
setTimeout(() => {
    console.log("0")
  }, 0)
  new Promise((resolve,reject)=>{
    console.log("1")
    resolve()
  }).then(()=>{        
    console.log("2")
    new Promise((resolve,reject)=>{
      console.log("3")
      resolve()
    }).then(()=>{      
      console.log("4")
    }).then(()=>{       
      console.log("5")
    })
  }).then(()=>{  
    console.log("6")
  })

  new Promise((resolve,reject)=>{
    console.log("7")
    resolve()
  }).then(()=>{         
    console.log("8")
  })
T	1	7
W	2 3	 8  4  6  5	
H	0
```





### 问题总结

#### 如何改变Promise的状态

```js
//3种方法
1.resolve() 状态由pending变为fulfilled
2.reject()  状态由pending变为rejected
3.抛出异常   状态由pending变为rejected
```



#### Promise状态改变和指定回调函数(then)谁先谁后

```js
1.都有可能. 正常时先指定回调再改变状态
2.先改变状态再指定回调的方法//同步
 2.1 直接调用resolve()/reject()
 2.2 延迟更长时间才调用then()
    let p = new Promise((resolve, reject)=>{
        setTimeout(()=>{resolve('ok')},1000);
    })
    setTimeout(()=>{p.then(value=>{console.log(value)})},3000)
 
3.先指定回调(先调用then方法)再改变状态//执行器种直接异步调用resolve()/reject()
   let p = new Promise((resolve,reject) => {
        setTimeout(function(){
            resolve('ok')
        },1000)
     })
     p.then(value => {
         console.log(value);
     })

4.什么时候得到数据?
4.1 如果先指定的回调函数,当状态发生改变时,调用回调函数,得到数据
4.2 如果先改变的状态,在指定回调函数时,回调函数就会调用,得到数据
```



#### Promise.then()返回新的Promise的结果状态由什么决定

```js
//then方法的返回结果是一个promise对象
(1)	简单表达: 由then()指定的回调函数执行的结果决定(执行结果就是函数的返回值)
(2)	详细表达:                                    
①	如果抛出异常, 新promise变为rejected, reason为抛出的异常/throw抛出的值
②	如果返回的是非promise的任意值, 新promise变为fulfilled(resolved) 值为返回值
③	如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果,其值也会为then方法的返回值.
```



#### Promise异常穿透

```js
(1)	当使用promise的then链式调用时, 可以在最后指定失败的回调 
(2)	前面任何操作出了异常, 都会传到最后失败的回调中处理



```



#### Promise中断链条

```js
//返回一个pending状态的promise对象  return new Promise(()=>{})
//传一个错误的promise对象值,会被catch捕获,如果没有catch方法会报错
```





### 案例

```js
//执行器函数是同步执行的
//then catch是异步执行的队列
setTimeout(() => {
    console.log("0")
  }, 0)
  new Promise((resolve,reject)=>{
    console.log("1")
    resolve()
  }).then(()=>{        
    console.log("2")
    new Promise((resolve,reject)=>{
      console.log("3")
      resolve()
    }).then(()=>{      
      console.log("4")
    }).then(()=>{       
      console.log("5")
    })
  }).then(()=>{  
    console.log("6")
  })

  new Promise((resolve,reject)=>{
    console.log("7")
    resolve()
  }).then(()=>{         
    console.log("8")
  })
T	1	7
W	2 3	 8  4  6  5	
H	0
```







## 4. Web API

### 事件(了解)

**事件是文档或者浏览器窗口中发生的，特定的交互瞬间。**

事件是用户或浏览器自身执行的某种动作，如click,load和mouseover都是事件的名字。

事件是javaScript和DOM之间交互的桥梁。

### 事件流

#### 概述

事件流描述的是从页面中接收事件的顺序

#### 两种事件流模型

事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流

**冒泡型事件流**：事件的传播是从**最特定**的**事件目标**到最不特定的**事件目标**。即从DOM树的叶子到根。**【推荐】**

**捕获型事件流**：事件的传播是从**最不特定**的**事件目标**到最特定的**事件目标**。即从DOM树的根到叶子。



#### DOM事件流

DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束

DOM标准规定事件流包括三个阶段：事件捕获阶段、处理目标阶段和事件冒泡阶段。

- 事件捕获阶段：**实际目标**（\<div>）在捕获阶段**不会接收事件**。也就是在捕获阶段，事件从document到\<html>再到\<body>就停止了。上图中为1~3.
- 处于目标阶段：事件在\<div>上发生并处理。**但是事件处理会被看成是冒泡阶段的一部分**。
- 冒泡阶段：事件又传播回文档。









### 事件冒泡与事件委托

#### 1) 事件冒泡的流程

- 基于DOM树形结构
- 事件在目标元素上处理后, 会由内向外(上)逐层传递
- 应用场景: 事件代理/委托/委派

#### 2) 事件委托

- 减少内存占用(事件监听回调从n变为1)
- 动态添加的内部元素也能响应
- 不直接给多个子元素绑定多个事件监听, 而是给它们共同的父元素绑定一个监听
- 当操作任意子元素时, 事件会冒泡到父元素上处理
- 在事件回调中通过event.target得到发生事件的目标元素, 并进行相关处理





### window.onload和$(document).ready()区别

- window.onload是在待网页中所有内容加载完毕之后（包括图片）回调
- 而$(documetn).ready()内部使用的是DOMContentLoaded监听, 在文档内容加载完成, 但图片还未加载加完前回调



### 封装一个绑定事件监听的函数

> [封装事件监听函数_巴拉巴拉小魔仙_的博客-CSDN博客](https://blog.csdn.net/m0_66637749/article/details/122708615)

```js
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
  </head>
  <body>
    <div>
      <button id="btn">按钮</button>
      <ul id="divBox">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
      </ul>
    </div>
    <script>
      function bindEvent(ele, type, selector, fn) {
        if (fn == null) {
          fn = selector
          selector = null
        }

        ele.addEventListener(type, event => {
          const target = event.target
          if (selector) {
            // 代理绑定
            if (target.matches(selector)) {
              fn.call(target, event)
            }
          } else {
            // 普通绑定
            fn.call(ele, event)
          }
        })
      }


      // 普通绑定
      const btn = document.getElementById('btn')
      bindEvent(btn, 'click', function(e) {
        e.preventDefault();
        console.log(this)
        alert(this.innerText)
      })

      // 代理绑定
      const div = document.getElementById('divBox')
      bindEvent(div, 'click', 'li', function(e) {
        e.preventDefault()
        alert(this.innerText)
      })
    </script>
  </body>
</html>

```



### 前台数据存储

#### 存储方式

- cookie

- sessionStorage

- localStorage

  注意: session后台数据存储

#### 区别 localStoarge与sessionStorage

- 相同点:
  - 浏览器不能禁用, 请求时不会自动携带
  - 纯浏览器端存储, 大小不受限制
  - 只能保存文本, 如果是对象或数组, 需要转换为JSON
  - API相同:
    - setItem(key, value)
    - getItem(key, value)
    - removeitem(key, value)
- 不同点(关闭浏览器是否会被删除):
  - localStorage保存在本地文件中, 除非编码或手动删除, 否则一直存在
  - sessonStorage数据保存在当前会话内存中, 关闭浏览器则清除



#### 区别cookie 与 localStorage和sessionStorage

- 容量:  cookie小
- 请求时是否自动携带:  cookie自动携带
- API易用性:  cookie的操作语法不方便
- 浏览器是否可禁用: cookie可禁用

#### 区别cookie与session

- cookie保存在浏览器端(前台可以操作)
- session保存在服务器端(前台不能操作)
- session依赖于cookie(session的id以cookie的形式保存在浏览器端)



### Ajax

Ajax(asynchronous JavaScript and XML) 是客户端上创建异步 Web 应用的一种 Web 开发技术。

借助 Ajax，Web 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为。通过将数据交换层与表示层分离，Ajax 允许网页和扩展 Web 应用程序动态更改内容，而无需重新加载整个页面。

XMLHttpRequest API 经常用于异步通信。此外还有最近流行的fetch API。

```javascript

```

#### 使用Ajax的优缺点分别是什么

**优点**

- 交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。
- 减少与服务器的连接，因为脚本和样式只需要被请求一次。
- 状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。
- 基本上包括大部分 SPA 的优点。

**缺点**

- 动态网页很难收藏。
- 如果 JavaScript 已在浏览器中被禁用，则不起作用。
- 有些网络爬虫不执行 JavaScript，也不会看到 JavaScript 加载的内容。
- 基本上包括大部分 SPA 的缺点。

[https://github.com/yangshun/front-end-interview-handbook/blob/master/questions/javascript-questions.md](http://link.zhihu.com/?target=https%3A//github.com/yangshun/front-end-interview-handbook/blob/master/questions/javascript-questions.md)

#### Ajax和Fetch区别

- ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。
- 使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。
- 在默认情况下，fetch不会接受或者发送cookies
- fetch没有办法原生监测请求的进度，而XMLHttpRequest可以
- fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
- fetch由于是ES6规范，兼容性上比不上XMLHttpRequest





#### xhr.status: 响应状态码

- 2XX: 表示成功处理请求, 
  - 200: 成功
  - 201: 添加数据成功
- 3XX: 需要生定向, 浏览器直接跳转, 
  - 302: 自动重定向到指定url
- 4XX: 客户端请求错误, 如:  
  - 401: 没有访问的权限
  - 404 : 访问的资源不存在
- 5XX: 服务器端错误
  - 500: 服务器端程序运行出错了

#### 区别ajax请求与一般HTTP请求

- ajax请求是一种特别的http请求:  只有<span style="color:red">XHR或fetch</span>发出的才是ajax请求, 其它所有的都是非ajax请求
- 对服务器端来说, 没有任何区别, 区别在浏览器端
- 浏览器端接收到响应
  - 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面
  - ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据

#### 封装一个简易的ajax异步请求函数

##### 简洁版(必须)

```js
const xhr = new XMLHttpRequest();
xhr.open('get',url);
xhr.send(body);
xhr.onreadystatechange=function(){
  if(xhr.readyState===4){
    console.log(xhr.responseText)
  }
}



/* 
xhr + promise 封装一个异步ajax请求的通用函数  简洁版
*/
function ajax(url) {
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const xhr = new XMLHttpRequest()
    // 初始化一个异步请求(还没发请求)func
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function () {
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (xhr.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (xhr.status>=200 && xhr.status<300) {
        // 指定promise成功及结果值
        resolve(JSON.parse(xhr.responseText))
      } else { // 请求失败了
        // 指定promise失败及结果值
        reject(new Error('request error staus '+ request.status))
      }
    }
    xhr.send(null)
  })
}
```

##### 加强版(可选)

```js
/* 
xhr + promise 封装一个异步ajax请求的通用函数  加强版
  返回值: promise
  参数为配置对象
    url: 请求地址
    params: 包含所有query请求参数的对象
    data: 包含所有请求体参数数据的对象
    method: 为请求方式
*/
function axios({url, params={}, data={}, method='GET'}) {
  // 返回一个promise对象
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const request = new XMLHttpRequest()
    
    // 根据params拼接query参数
    let queryStr = Object.keys(params).reduce((pre, key) => {
      pre += `&${key}=${params[key]}`
      return pre
    }, '')
    if (queryStr.length>0) {
      queryStr = queryStr.substring(1)
      url += '?' + queryStr
    }
    // 请求方式转换为大写
    method = method.toUpperCase()
    
    // 初始化一个异步请求(还没发请求)
    request.open(method, url, true)
    // 绑定请求状态改变的监听
    request.onreadystatechange = function () {
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (request.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (request.status>=200 && request.status<300) {
        // 准备响应数据对象
        const responseData = {
          data: JSON.parse(request.response),
          status: request.status,
          statusText: request.statusText
        }
        // 指定promise成功及结果值
        resolve(responseData)
      } else { // 请求失败了
        // 指定promise失败及结果值
        const error = new Error('request error staus '+ request.status)
        reject(error)
      }
    }

    // 如果是post/put请求
    if (method==='POST' || method==='PUT' || method==='DELETE') {
      // 设置请求头: 使请求体参数以json形式传递
      request.setRequestHeader('Content-Type', 'application/json;charset=utf-8')
      // 包含所有请求参数的对象转换为json格式
      const dataJson = JSON.stringify(data)
      // 发送请求, 指定请求体数据
      request.send(dataJson)
    } else {// GET请求
      // 发送请求
      request.send(null)
    }
  })
}
```



#### 跨域

- 什么是跨域(同源策略)
- JSONP
- CORS
- 代理服务器



#### 同源策略

- 同源: 协议, 域名, 端口, 三者都相同
- ajax请求时, 浏览器要求当前网页和Server必须同源(安全), 否则会抛出跨域的错误
- 加载image/link/script不受同源策略限制



### Ajax跨域解决方案

#### JSONP原理

- 前台:

  - `<script src="目标url?callback=fn" />`

  - 接收响应数据的函数: function fn (data) {}

- 后台

  - 处理请求, 产生需要返回的数据data
  - 读取callback请求参数得到前台处理响应数据的函数名fn
  - 返回执行函数fn的js代码: 'fn && fn(data)'

- 不足

  - 只能处理GET请求
  - 每个请求在后台都要做处理, 麻烦

  ```js
  // 发送jsonp请求的函数
  function jsonp() {
      var script = document.createElement('script')
      script.type = 'text/javascript'
      // 传参并指定回调执行函数为backFn
      script.src = 'http://localhost:4000/getUserInfo?id=100&callback=cbFn'
      document.body.appendChild(script)
  }
  
  // 回调函数, 接收响应数据
  function cbFn(data) {
  	console.log(data)
  }
  ```

  

#### CORS原理

后台: 返回允许浏览器在某个域上发送跨域请求的相关响应头

```js
// 使用cors, 允许跨域, 且允许携带跨域cookie
app.use(function (req, res, next) {
  // console.log('----')
  // 允许跨域的地址
  res.header('Access-Control-Allow-Origin', 'http://localhost:5500')  // 不要是*
  // 允许携带凭证(也就是cookie)
  res.header('Access-Control-Allow-Credentials', 'true')
  // 允许跨域的请求头
  res.set("Access-Control-Allow-Headers", "Content-Type")
  // 放行
  next()
})
```

- 前台: 不需要做特别任何处理

```js
axios.defaults.withCredentials = true // 允许携带cookie
xhr.withCredentials = true
```

#### 代理服务器

- 开发环境: 利用webpack-dev-server中的http-proxy-middle  进行正向代理
  - vue脚手架项目: vue.config.js
  - react脚手架项目: package.json
- 生产环境: 利用nigix  进行反向代理
- https://www.cnblogs.com/taostaryu/p/10547132.html



### axios

#### 使用axios发送ajax请求

```js
// 发请求的基本语法
axios(url)
axios({
    method: '',
    url: '',
    params: {},
    data: {}
})
axios.get(url, {配置})
axios.post(url, data, {配置})
axios.put(url, data, {配置})
axios.delete(url, {配置})

// 创建新的axios
const instance = axios.create({
    baseURL: '',
    timeout: 20000,
})

// 添加请求拦截器
instance.interceptors.request.use((config) => {
   	// 添加请求头
    config.headers['token'] = token值
    return config // 必须返回config
})

// 添加响应拦截器
instance.interceptors.response.use(
    response => {
        // return response
        return response.data
    },
    error => {
        
    }
)

// 请求某个具体的接口
instance({
  url: '/xxx'
}).then(data => {
    
})

```



#### axios整体执行流程

- 请求拦截器的回调函数
- xhr发请求
- 响应拦截器成功/失败的回调
- 具体请求成功/失败的回调



#### 对axios进行二次封装（面试必说）

1. 配置通用的基础路径和超时: 

   ​	axios.create({baseURL, timeout})

2. 显示请求进度条

   ​	显示: 准备发请求前显示, 在请求拦截器中执行NProgress.start()

   ​	隐藏: 请求结束隐藏, 在响应拦截器成功/失败回调中NProgress.done()

3. 携带token数据

   ​	在请求拦截器中, 将token添加到请求头中

4. 成功返回的数据不再是response, 而直接是响应体数据response.data

   ​	响应拦截器成功的回调中: return response.data

5. 统一处理请求错误, 具体请求也可以选择处理或不处理

   ​	在响应拦截器失败的回调中: alert提示错误信息, return Promise.reject(error)

```js
//
import axios from 'axios';
import Nprogress from 'nprogress';
import 'nprogress/nprogress.css'

const service = axios.create({
    baseURL:'/api',
    timeout:20000
})

service.interceptors.request.use(
  (config)=>{
    Nprogress.start();
    //临时数据标识  token
    let userTempId = store.state.user.userTempId;
    if(userTempId){
        config.headers.userTempId = userTempId;
    }
    let token = store.state.user.token;
    if(token){
        config.headers.token = token;
    }
    return config;
},
  
(error)=>{
    alert(error.message)
 }                                 
)

service.interceptors.response.use(
    (response)=>{
    Nprogress.done();
    return response.data;
	},
    (error)=>{
        Nprogress.done();
        //return new Promise(()=>{})
        return Promise.reject(new Error('请求失败'))
    }
)

export default service;
```









### Restless API 与 Restful API

- Restless API  

  - 传统的API, 把每个url当作一个功能操作      /updateUser
  - 同一个url, 后台只进行CRUD的某一种操作
  - 请求方式不决定请求的CRUD操作
  - 一个请求路径只对应一个操作
  - 一般只有GET/POST

- Restful API 

  - 新式的API, 把每个url当作一个唯一资源   /user/2
  - 同一个url, 可以通过不同类型的请求对后台资源数据进行CRUD四种操作
  - 请求方式来决定了请求在后台进行CRUD的哪种操作
    - GET: 查询
    - POST: 添加
    - PUT: 更新
    - DELETE: 删除
  - 同一个请求路径可以进行多个操作
  - 请求方式会用到GET/POST/PUT/DELETE

- 测试: 可以使用json-server快速搭建模拟的rest api 接口



### 重排和重绘

#### 哪些操作导致重排

- 元素位置和尺寸发生改变的时候
- 新增和删除可见元素
- 内容发生改变（文字数量或图片大小等等）
- 元素字体大小变化。
- 激活CSS伪类（例如：:hover）。
- 设置style属性
- 查询某些属性。比如说： offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight



#### 哪些操作会导致重绘

- 更新元素的部分属性(影响元素的外观，风格，而不会影响布局)，比如 visibility、outline、背景色等属性的改变。



#### 如何减少重排次数

- 更新节点的样式， 尽量通过类名而不是通过style来更新



### post常用的数据格式,form-data和json的区别

- application/json: json格式文本
- application/x-www-form-urlencoded: 形如query参数(name=tom&age=12)的文本
- multipart/form-data: 文件上传





### 图片懒加载原理,如何实现

- 先将img标签中的src链接设置为空，将真正的图片链接放在自定义属性（data-src），
- 当js监听到图片元素进入到可视窗口的时候，将自定义属性中的地址存储到src中，达到懒加载的效果





### 图片懒加载原理

```js
https://segmentfault.com/a/1190000010744417?utm_source=sf-similar-article
原理:在图片没有进入可视区域时，先不给<img>的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。

方法一: 
方法二: 通过getBoundingClientRect()方法来获取元素的位置, 与window.innerHeight-100比较
方法三: IntersectionObserver可以自动观察元素是否在视口内。
```



> https://segmentfault.com/a/1190000038413073



### 实现文件断点续传

在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。

前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。

当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。 有了HTML5 的 File api之后切割文件比想想的要简单的多的多。

只要用slice 方法就可以了

```javascript
let packet = file.slice(start, end)
```

参数start是开始切片的位置，end是切片结束的位置 单位都是字节。通过控制start和end 就可以是实现文件的分块

如

```text
file.slice(0,1000);
file.slice(1000,2000);
file.slice(2000,3000);
// ......
```

在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。 如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。







## 5. 手写代码(也可能让你说)

### 深拷贝

#### 是什么

深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**。



#### 深拷贝实现方式

- JSON.parse(JSON.stringfy(obj)) 
  -  ===> 问题: 方法/函数会丢失
  -  ===> 问题2: 循环引用会出错(死循环)
- 递归遍历
  - 如果是基本类型与函数直接返回, 函数就不会丢失也不会拷贝
  - 如果是对象/数组创建拷贝对象/数组
  - 问题: 循环引用会出错的问题(死循环)
- 使用Map缓存拷贝对象
  - 如果发现一个对象已经产生拷贝对象, 直接返回这人拷贝对象
  - 使用Map存储 ==> key为源对象, value是拷贝产生的对象  (不能用对象来存储, 因为对象的key为字符串)

```js
/* 
1). 大众乞丐版
    问题1: 函数属性会丢失   原因: json字符串数据是不存在函数, 函数属性就会丢失
    问题2: 循环引用会出错   原因: 转换为json字符串是会产生死循环查找, 报错
利用JSON转换成json字符串, 再解析回来
*/
deepClone1 (target) {
  if (target!==null && typeof target==='object' ) {
    return JSON.parse(JSON.stringify(target))
  } else {
    return target
  }
},
```







```javascript
//作者：神三元
//链接：https://juejin.cn/post/6844903986479251464
const getType = obj => Object.prototype.toString.call(obj);

const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

const canTraverse = {
  '[object Map]': true,
  '[object Set]': true,
  '[object Array]': true,
  '[object Object]': true,
  '[object Arguments]': true,
};
const mapTag = '[object Map]';
const setTag = '[object Set]';
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}

const handleNotTraverse = (target, tag) => {
  const Ctor = target.constructor;
  switch(tag) {
    case boolTag:
      return new Object(Boolean.prototype.valueOf.call(target));
    case numberTag:
      return new Object(Number.prototype.valueOf.call(target));
    case stringTag:
      return new Object(String.prototype.valueOf.call(target));
    case symbolTag:
      return new Object(Symbol.prototype.valueOf.call(target));
    case errorTag: 
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}

const deepClone = (target, map = new WeakMap()) => {
  if(!isObject(target)) 
    return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return handleNotTraverse(target, type);
  }else {
    // 这波操作相当关键，可以保证对象的原型不丢失！
    let ctor = target.constructor;
    cloneTarget = new ctor();
  }

  if(map.get(target)) 
    return target;
  map.set(target, true);

  if(type === mapTag) {
    //处理Map
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key, map), deepClone(item, map));
    })
  }
  
  if(type === setTag) {
    //处理Set
    target.forEach(item => {
      cloneTarget.add(deepClone(item, map));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop], map);
    }
  }
  return cloneTarget;
}
```



#### 复述一下深拷贝的操作流程:

* 定义函数,  参数(target, map=new WeakMap())
* 判断是否是对象(判断条件), 非对象直接返回
* 获取具体的对象类型
* 判断是否是 5种 可遍历的对象 (可遍历对象5个: Array/Object/Set/Map/Arguments)
  * 如果是不可遍历的对象, 声明外部函数`handleNotCanTraverse(target, type)`来处理
    * 一类: 调用原型上的`valueOf`方法获取原始值, 再使用`new Object()`生成包装类对象 (string / number / boolean /symbol )
    * 一类: 默认调用原型上的构造函数,生成新的对象 (date error)
    * 一类: 调用独立的方法来处理( 正则表达式, 函数)
  * 如果是可遍历的对象
    * 首先是:  通过`target.constructor`属性获取其构造函数, 调用构造函数生成相应的实例对象
    * 如果存在对象引用 , 会提前在函数的参数中添加`map = new WeakMap()` (这个地方不熟悉的话可以省略不说)
      * 存在对象引用: 直接返回这个对象; 
      * 当前对象不存在引用, 将当前对象添加进map集合中 `map.set(target, true)`
    * 如果是map类型
      * `cloneTarget.set(deepClone(key, map), deepClone(item, map))`
    * 如果是set类型
      * `cloneTarget.add(deepClone(item , map))`
    * 如果是对象 / 数组 类型, 使用`for...in`循环来处理
      * `cloneTarget[key] = deepClone(target[key], map)`











### 数组相关

#### 判断数据类型是否为数组的方案  7 种

* [] instanceof Array
* [].\_\_proto\_\_ === Array.prototype
* [].constructor === Array
* Array.prototype.isPrototypeOf([])
* Object.getPrototypeOf([]) === Array.prototype
* Object.prototype.toSTring.call([]).slice(8, -1)
* Array.isArray([])







#### 数组扁平化 7种

* toString + split
* flat
* JSON.stringify + replace + split
* JSOn.stringify + replace + 字符串 +  JSON.parse
* 递归
  * for ...of
  * reduce

* 扩展运算符 + some 



```javascript
//toString + split

arr.toString().split(',')

//flat
arr.flat(Infinity)

//JSON + replace+split
//JSON.stringify(arr.replace(/\[|\]/g, '')).split(',')
JSON.stringify(arr).replace(/\[|\]/g, '').split(',')

//JSON + replace + JSON.parse
let res = JSON.stringify(arr).replace(/\[|\]/g, '')
let newArr = JSON.parse('[' + res + ']')

//递归+for/reduce
let res = []
function flat(arr) {
  for (let i=0; i<arr.length; i++) { 
    if (Array.isArray(arr)) {
    	flat(arr[i])
  	} else {
      res.push(arr[i])
    }
  }
}
//
function flat(arr) {
  return arr.reudce((pre, crt) => {
    return pre.concat(Array.isArray(crt) ? flat(crt) : crt
  }, [])
}
                    

//扩展运算符
while(arr.some(Array.isArray)) {
    arr = [].concat(...arr)  // arr = [].concat(arr) 加不加扩展运算符都一样的 多循环一次
  }
```



#### 实现flat

```javascript
//递归
// arguments.callee指向argumetns对象所在函数的指针, 实现函数名与逻辑的解耦
function flat(arr) {
  let res = []
  arr.forEach(item => {
    if (Array.isArray(item)) {
      res = res.concat(arguments.callee(item)) 
      // res.push(...arguments.callee(item))
    } else {
      res.push(item)
    }
  })
  
  return res
}

//reduce
const flat = arr => {
  return arr.reduce((acc, crt) => {}, [
    return acc.concat(Array.isArray(crt) ? flat(crt) : crt)
  ])
}

//其他方法
```







#### 数组去重 7 种

* for + for / 新数组
* for + indexOf / includes
* reduce + indexOf/includes
* filter + indexOf / sort()
  * indexOf存在的问题
  * sort排序的问题  sort()排序有漏洞, 并不适用于特殊类型的排序. !!!!???
* sort快慢指针
* object键值对 + map键值对
  * object键值对存在的问题: 不能去重正则表达式
* new Set()



```javascript
let arr = [1,2,3,1,1,4,3,2,5,6,7];
// for + for 

for (let i=0; i<arr.length; i++) {
  for (let j=i+1; j<arr.length; j++) {
    arr.splice(j, 1)
    j--
  }
}

//for + 新数组

let newArr = []
let j;

for (let i=0; i<arr.length; i++) {
  for (j=0; j<newArr.length; j++) {
    if (arr[i] === newArr[j]) {
      break
    }
  }
  if (j === newArr.length) {
    newArr.push(arr[i])
  }
}

let newArr = []
for (let i=0, len=arr.length; i<len; i++) {
  for (let j=0, len=newArr.length; j<len; j++) {   //这里如果不采用变量形式,会出现死循环
    if (arr[i] === newArr[j]) {
      break
    }
    
    if (j === newArr.length) {
      newArr.push(arr[i])
    }
  }
}
```



```javascript
//for + indexOf / includes

let res = []
for (let i=0; i<arr.length; i++) {
  if (res.indexOf(arr[i] === -1)) { // !res.includes(arr[i])
    res.push(arr[i])
  }
}
```



```javascript
// reduce + indexOf / includes

arr.reduce((pre, crt) => pre.includes(crt) ? pre : pre.concat(crt), [])
arr.reduce((pre, crt) => pre.indexOf(crt) === -1 ? pre.concat(crt) : pre, [])
```



```javascript
//filter + indexOf

arr.filter((item, idx, arr) => arr.indexOf(item) == idx)
//存在的问题
1.arr.indexOf(NaN)的结果是-1,所以会忽略NaN这个值.
2.对象不去重

arr.concat().sort().filter((item, idx, arr) => !idx || item !== arr[idx - 1])
```



```javascript
//sort快慢指针


//https://juejin.cn/post/6844904202162929671

function unique(arr) {
  arr.sort((a, b) => a - b);
  let left = 0,
      right = 1;
  
  while(right < arr.length) {
    if (arr[left] === arr[right]) {
      right++;
    } else {
      arr[left + 1] = arr[right];
      left++;
      right++;
    }
  }
  return arr.slice(0, left+1);
}

//https://juejin.cn/post/7033275515880341512
function unique2(arr) {
  arr.sort((a, b) => a - b);
  let slow = 1,
      fast = 1;
  
  while(fast < arr.length) {
    if (arr[fast - 1] !== arr[fast]) {
      arr[slow++] = arr[fast];
    }
    ++fast;
  }
  arr.length = slow;
  return arr;
}
```



```javascript
//object键值对

// 考虑到 `JSON.stringify` 任何一个正则表达式的结果都是 `{}`，所以这个方法并不适用于处理正则表达式去重。

let obj = {}
arr.filter( v => obj.hasOwnProerpty(v) ? false : (obj[typeof v + JSON.stringify(v)] = true))
```



```javascript
//map键值对

let map = new Map()
arr.fitler((item, idx, arr) => !map.has(item) && map.set(item, true))
```



```javascript
// set

let res = (arr) => [...new Set(arr)]
```

#### 数组去重存在的问题

重点关注下 对象 和NaN 的去重

| 方法                                                         | 结果                                                         | 说明                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------- |
| for循环(双for+新数组)                                        | [1, "1", null, undefined, String, String, /a/, /a/, NaN, NaN] | 对象和 NaN 不去重                       |
| indexOf(作者用的是新数组+for循环+indexOf方法)                | [1, "1", null, undefined, String, String, /a/, /a/, NaN, NaN] | 对象和 NaN 不去重                       |
| sort<br />结论是数字1不去重,没有勘误.不知道是哪个数字1,是包装类的吗? | [/a/, /a/, "1", 1, String, 1, String, NaN, NaN, null, undefined] | 对象和 NaN 不去重 <br />数字 1 也不去重 |
| filter+indexOf                                               | [1, "1", null, undefined, String, String, /a/, /a/]          | 对象不去重 NaN 会被忽略掉               |
| filter+sort                                                  | [/a/, /a/, "1", 1, String, 1, String, NaN, NaN, null, undefined] | 对象和 NaN 不去重 数字 1 不去重         |
| 优化后的键值对方法                                           | [1, "1", null, undefined, String, /a/, NaN]                  | 全部去重                                |
| Set                                                          | [1, "1", null, undefined, String, String, /a/, /a/, NaN]     | 对象不去重 NaN 去重                     |






#### 数组翻转

1. 使用原型中的reverse方法

   ```js
   let array = [1, 2, 3, 4, 5]
   array.reverse() 
   ```
   
2. 循环

   ```js
   for(var i = 0; i < arr.length; i++){
       var temp = arr[i];
       arr[i] = arr[arr.length - 1 - i]
       arr[arr.length - 1 - i] = temp;
   }
   ```

   


#### 排序算法

##### 简单排序: 冒泡 / 选择 / 插入

```js
/* 
冒泡排序的方法
*/
function bubbleSort (array) {
  // 1.获取数组的长度
  var length = array.length;

  // 2.反向循环, 因此次数越来越少
  for (var i = length - 1; i >= 0; i--) {
    // 3.根据i的次数, 比较循环到i位置
    for (var j = 0; j < i; j++) {
      // 4.如果j位置比j+1位置的数据大, 那么就交换
      if (array[j] > array[j + 1]) {
        // 交换
        // const temp = array[j+1]
        // array[j+1] = array[j]
        // array[j] = temp
        [array[j + 1], array[j]] = [array[j], array[j + 1]];
      }
    }
  }

  return arr;
}

/* 
选择排序的方法
*/
function selectSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 从0位置开始取出数据, 直到length-2位置
  for (var i = 0; i < length - 1; i++) {
    // 3.内层循环: 从i+1位置开始, 和后面的内容比较
    var min = i
    for (var j = min + 1; j < length; j++) {
      // 4.如果i位置的数据大于j位置的数据, 记录最小的位置
      if (array[min] > array[j]) {
        min = j
      }
    }
    if (min !== i) {
      // 交换
      [array[min], array[i]] = [array[i], array[min]];
    }
  }

  return arr;
}

/* 
插入排序的方法
*/
function insertSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后
  for (var i = 1; i < length; i++) {
    // 3.记录选出的元素, 放在变量temp中
    var j = i
    var temp = array[i]

    // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环
    while (j > 0 && array[j - 1] > temp) {
      array[j] = array[j - 1]
      j--
    }

    // 5.将选出的j位置, 放入temp元素
    array[j] = temp
  }

  return array
}
```



##### 快速排序(选择性)

```js
function quickSort(arr) {
  // 递归结束的条件
  if(arr.length < 2){
    return arr
  }
  // 获取中间值
  let flag = Math.floor(arr.length / 2);
  let flagValue = arr.splice(flag, 1)[0];
  
  let leftArr = [];
  let rightArr = [];
  for (var i = 0; i < arr.length; i++) {
    var arrItem = arr[i];
    
    if(arrItem > flagValue){
      rightArr.push(arrItem)
    }else {
      leftArr.push(arrItem)
    }
  }
  
  leftArr = quickSort(leftArr);
  rightArr = quickSort(rightArr);
  return [...leftArr, flagValue, ...rightArr]
}
```





### 函数相关

#### 函数的call() / apply() / bind()

```javascript

//call

Function.prototype.call2 = function(...items) {
  let obj = items.shift() || globalThis
  let tempFn = Symbol()
  obj[tempFn] = this
  
  let res = obj[tempFn](...items)
  delete obj[tempFn]
  
  return res
}

// 不建议使用arguments
Function.prototype.myCall = function() {
  let obj = [].shift.call(arguments) || globalThis;
  obj.tempFn = this
  
  let res = obj.tempFn(...[...arguments]);
  delete obj.tempFn;
  return res;
}



//apply
Function.prototype.apply2 = function(...items) {
  let obj = items.shift() || globalThis
  obj[tempFn] = this
  let res = obj[tempFn](items)
  delete obj[tempFn]
  
  return res
}

//bind

//1 version
Function.prototype.bind = function(cxt) {
  let fn = this
  let argsOut = [].slice.call(arguments)
  return function() {
    let argsInner = [].slice.call(arguments)
    fn.apply(cxt, argsOut.concat(argsInner))
  }
}

//

//2 version  避免实例通过原型链更改函数原型上的属性,使用空函数中转 + 可以使用new调用
Function.prototype.bind = function () {
	let fn = this
  let argsOut = [].slice.call(arguments, 1)
  let fNOP = function() {}
  let fbound = function () {
    let argsInner = [].slice.call(arguments)
    return fn.apply(this instanceof fNOP ? this : crt, argsOut.concat(argusInner))
  }
  
  fNOP.prototype = this.prototype
  fbound.prototype = new fNOP()
  return fbound
}
```



```js
/* 
自定义函数对象的call方法
*/
function call (fn, obj, ...args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
自定义函数对象的apply方法
*/
function apply (fn, obj, args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
  自定义函数对象的bind方法
  重要技术:
    高阶函数
    闭包
    call()
    三点运算符
*/
function bind (fn, obj, ...args) {
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  
  return function (...args2) {
    call(fn, obj, ...args, ...args2)
  }
}
```



### 字符串处理

```js
/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/

/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
*/
function reverseString(str) {
  // return str.split('').reverse().join('')
  // return [...str].reverse().join('')
  return Array.from(str).reverse().join('')
}

/* 
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
*/
function palindrome(str) {
  return str === reverseString(str)
}

/* 
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/
function truncate(str, num) {
  return str.length > num ? str.slice(0, num) + '...' : str
}
```



### instanceof内部原理和实现

instanceof运算符判断一个对象是否为另一个对象的实例

```javascript

function isntanceof2(case, Ctor) {
    //基本数据类型返回false
  //兼容一下函数对象
  if (typeof(Case) !== 'object' && typeof(Case) !== 'function' || Case === 'null') {
    return false;
  }
  
  let caseProto = Object.getPrototypeOf(case)
  while(true) {
    if (caseProto == null) return false
    //找到相同的原型
    if (caseProto === Ctor.prototype) return true
    caseProto = Object.getPrototypeOf(caseProto)
  }
}


```



### js的垃圾回收机制

#### JS中判定位垃圾的情形如下:

- 对象不再被引用；
- 对象不能从根上访问到；

#### 常见的GC算法

- 引用计数
  - 语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。
- 标记清除
  - 遍历所有对象找标记活动对象；
  - 遍历所有对象清除没有标记对象；
  - 回收相应的空间。
- 标记整理
  - 标记整理可以看做是标记清除的**增强**。标记阶段的操作和标记清除一致。
- 分代回收
  - 内存分为新生代、老生代
  - 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
  - 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

​	

#### 性能优化

* 避免使用全局变量
* 减少判断层级
* 减少数据读取次数
* 减少循环体中的活动
* 事件绑定优化
* 避开闭包陷阱

### 内存泄露和内存溢出比较

- 内存溢出

  - 运行程序需要分配的内存超过了系统能给你分配的最大剩余内存

  - 抛出内存溢出的错误，程序中断运行

  - 演示代码

    ```
    const arr = []
    for (let index = 0; index < 100000000; index++) {
    	arr[index] = new Array(1000)
    }
    ```

- 内存泄漏

  - 理解: 当程序中的某个内存数据不再需要使用， 而由于某种原因， 没有被释放

  - 常见情况:

    - 意外的全局变量

      ```
      function fn () {a = new Array(100000)}
      fn()
      ```

    - 没有及时清除的定时器

  this.intervalId = setInterval(() => {}, 1000) // clearInterval(this.intervalId) ```

  - 没有及时解绑的监听

  this.bus.bus.on('xxx', this.handle) // this.bus.bus.off('xxx') ```

  - 没有及时释放的闭包







## HTTP



### 输入网址后发生了什么

> [what-happens-when-zh_CN/README.rst at master · skyline75489/what-happens-when-zh_CN (github.com)](https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst?utm_medium=social&utm_source=wechat_session&from=timeline&isappinstalled=0)



* 合成URL

* DNS域名解析

  * 浏览器缓存--->本地hosts文件--->本地DNS解析器缓存--->本地DNS服务器--->根域名服务器-->顶级域名服务器(com, cn,...)-->权威域名服务器(顶级域名托管商)

* 建立TCP连接

  * 首先，判断是不是https的，如果是: 服务端和客户端的信息传输都会加密
  * 进行三次握手,建立TCP连接
    * 第一次握手：建立连接。客户端发送连接请求报文段
    * 第二次握手：服务器收到报文段。同时，自己还要发送请求信息给客户端
    * 第三次握手：客户端收到服务器的报文段。然后将向服务器发送报文段，客户端服务器更新状态,完成TCP三次握手。

* 客户端发送HTTP请求,服务器处理请求,返回响应结果

* 关闭TCP连接,四次挥手

  * 第一次分手: 主机1(客户端, 也可以是服务端)向主机2发送报文,请求关闭
  * 第二次分手: 主机2接收报文,之后发送报文更新状态
  * 第三次分手: 主机2向主机1发送报文, 请求关闭连接
  * 第四次分手: 主机1收到主机2报文, 向主机2发送报文段，然后主机1进入TIME_WAIT状态；
    * 主机2收到主机1的报文段以后，就关闭连接；
    * 主机1等待2个报文最大生存时间后依然没有收到回复，证明Server端已正常关闭，主机1关闭连接

* 浏览器渲染

  1.HTML 被 HTML 解析器解析成 DOM 树；

  2.CSS  被 CSS 解析器解析成 CSSOM 树；

  3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；

  4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；

  5.将布局绘制(paint)在屏幕上，显示出整个页面。



### 浏览器如何渲染页面的？

1、HTML被HTML解析器解析成DOM树。 

2、CSS被CSS解析器解析成CSS规则树。 

3、浏览器会将CSS规则树附着在DOM树上，并结合两者生成渲染树Render Tree。 

4、生成布局（flow），浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。 

5、将布局绘制（paint）在屏幕上，显示出整个页面

### GET和POST的区别

#### 是什么

`GET`和`POST`，两者是`HTTP`协议中发送请求的方法

##### GET

`GET`方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据

##### POST

`POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**

本质上都是`TCP`链接，并无差别

但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别



#### 区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中



### Accept和Content-Type

Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。 服务器使用 Content-Type 应答头通知客户端它的选择。

```text
Accept: text/html
Accept: image/*
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

1.Accept属于请求头， Content-Type属于实体头。
Http报头分为通用报头，请求报头，响应报头和实体报头。
请求方的http报头结构：通用报头|请求报头|实体报头
响应方的http报头结构：通用报头|响应报头|实体报头

2.Accept代表发送端（客户端）希望接受的数据类型。
比如：Accept：text/xml;
代表客户端希望接受的数据类型是xml类型

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。
比如：Content-Type：text/html;
代表发送端发送的数据格式是html。

二者合起来，
Accept:text/xml；
Content-Type:text/html
即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。





### 状态码

| 状态码 | 类别                             | 描述                   |
| ------ | -------------------------------- | ---------------------- |
| 1xx    | Informational（信息状态码）      | 接受请求正在处理       |
| 2xx    | Success（成功状态码）            | 请求正常处理完毕       |
| 3xx    | Redirection（重定向状态码）      | 需要附加操作已完成请求 |
| 4xx    | Client Error（客户端错误状态码） | 服务器无法处理请求     |
| 5xx    | Server Error（服务器错误状态码） | 服务器处理请求出错     |



### HTTP缓存





### 如何处理不让别人盗用你的图片，访问你的服务器资源

- http header, 对refer做判断看来源是不是自己的网站，如果不是就拒绝
- 通过session校验，如果不通过特定服务生成cookie和session就不能请求得到资源



### Http与Https的区别

- HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
- HTTP 是不安全的，而 HTTPS 是安全的
- HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
- 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
- HTTP 无法加密，而HTTPS 对传输的数据进行加密
- HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书



### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，
当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。

可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。







## git操作

- git config --global credential.helper store (记住用户和密码)

- 分支操作

  ​	拉取远程新分支到本地

  ​	git pull (如果分支是在clone后创建的才需要执行)

  ​	git checkout -b dev origin/dev

- 版本注释一般规范
  feature 特性：新增功能

  docs 文档：新增文档

  fix 修复 Bug

- xiongjian分支到本地仓库xiongjian分支上

  git fetch origin xiongjian:xiongjian 拉取远程仓库

```bash

git checkout -b branchName

git add .

git commit -m 'xxx'

git checkout master

git merget branchName

git pull

git push
```





## webpack

#### 1. Webpack 基本概念

##### 1) entry 入口

- 以某个文件为入口开始打包
- 分类
  - 单入口 String 
    - 只会输出一个文件
  - 多入口 Array / Object
    - Array 只会输出一个文件
    - Object 会输出多个文件  ==> 多页应用(MPA)

##### 2) output 输出

- 打包后资源输出到哪里去
- 输出的文件名叫什么

##### 3) loader 加载器

- webpack 本身只能识别 json、js 模块，其他模块一旦加载就会报错
- 需要借助 loader 帮助 webpack 识别其它识别不了的模块

##### 4) plugins 插件

- loader 功能有限，要想做功能更加强大的工作交给插件
- 比如在页面中自动引入打包生成的js/css, 压缩css, 拷贝文件等

##### 5) mode

- 模式：开发环境（development）和生产环境（production）
- 提供一系列默认配置, 用于简化配置

#### 2. Webpack 基本配置

##### 1) 处理JS文件

- eslint-loader
  - 在package.json中配置eslintConfig来指示eslint-loader到底要干什么事
  - enfore: 'pre' 优先执行
- babel-loader
  - 在webpack配置中配置babel来指示babel-loader到底要干什么事
  - babel.config.js: 配置webpack的preset与plugin

##### 2) 处理Vue文件

- vue-loader

##### 3) 处理JSX文件 

- babel-loader
- presets: ['@babel/preset-react']

##### 4) 处理CSS文件

- 开发环境：创建style标签插入样式
  - style-loader
  - css-loader
  - postcss-loader
  - less-loader / sass-loader / stylus-loader
- 生产环境：提取单独css文件，将来通过link引入
  - MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）
  - css-loader
  - postcss-loader
  - less-loader / sass-loader / stylus-loader

##### 5) 处理HTML文件

- 目标: 自动引入打包生成的js/css
- html-webpack-plugin

##### 6. 处理图片/字体/音视频文件

- url-loader / file-loader
- limit: 10000 小于10kb一下的图片会被base64处理

#### 3. Webpack 优化手段

##### 1) 优化打包构建速度

##### HMR 热模块替换

- 为什么要用？
  - 默认情况下，一旦修改了代码，全部代码重新编译刷新，速度慢（全体刷新）
- 有什么作用？
  - 只更新修改的模块，其他模块不变（局部更新）  
- 怎么使用？
  - devServer: { hot: true }  
  - new webpack.HotModuleReplacementPlugin()  
- 注意：
  - 默认情况下只有样式文件有HMR功能（style-loader），JS是没有的
- 开启JS的HMR功能：
  - 手写JS代码 --> module.hot.accpet('模块路径', () => {})
  - 在Vue使用 --> vue-loader
  - 在React使用 --> react-hot-loader

#### 缓存

- eslint和babel两个任务处理JS文件，时间一般会比较长，为了让其重新构建速度更快, 可以使用缓存。
- eslint --> cache: true
- babel --> cacheDirectory: true
- cache-loader放置在要缓存loader的前面
- 注意：一般只针对耗时长的任务：eslint-loader/babel-loader/vue-loader

#### oneOf

- 作用：
  - 让模块只被一个loader处理，其他的就不看了(原本所有都会判断一下)
  - 能够提升打包速度
- 注意：
  - eslint-loader: 处理js, 需要先执行, 将其定义在oneOf的外面
  - babel-loader: 处理js, 后执行, 将其定义在oneOf的内部

#### 多进程打包

- 过去: happyPack
- 现在: thread-loader
- 用法和cache-loader差不多，放在要使用loader前面
- 作用：开启多进程处理前面的任务，提升打包速度
- 注意：每个进程开启和通信都有开销，一般只针对耗时长的任务：babel-loader

### 2) 优化打包代码体积和性能

#### 兼容性处理

- JS
  - ES6由二个部分
    - 新语法: const/let/箭头函数/解构赋值/对象简写 
    - 新API: Promise / 数组新方法/ 对象新方法
  - babel-loader presets: ['@babel/preset-env'] 问题就是只能编译语法, 不能处理新API
  - @babel/polyfill 做API兼容，问题是体积太大了
  - core-js3 在@babel/preset-env基础上，增加了useBuiltIns: 'usage'来实现按需加载
  - 指定浏览器版本或占有率配置, 进一步减小打包文件: 只打包使用了且浏览器没有实现的
- CSS  
  - postcss-loader 
  - 在package.json中指定browserslist来指示postcss-loader兼容性做到什么程度

#### tree shaking( 摇树)

- 去除没有使用的JS代码
- 必须使用ES6模块化（需要禁止@babel/preset-env转换ES6模块化语法 modules: false）
- 开启webpack的生产模式（内部启用TerserPlugin，用来压缩JS代码的插件，tree shaking功能就是这个插件完成的）
- 在package.json配置sideEffects来指定哪些文件需要进行tree shaking

#### code split 代码分割 / lazy loading 懒加载

- 作用：
  - 抽取公共代码 
  - 拆分多个文件，减少单个文件体积（避免单次请求时间过长）
- 配置：
  - 多入口 + optimization
    - 将node_modules抽取成单独模块
    - 将多入口的公共模块也抽取成单独模块
  - 单入口 + optimization + import
    - 将node_modules抽取成单独模块
    - 动态导入语法import就能将某些文件抽取成单独模块
  - import()动态引入模块
    - 原生 JS:  在需要的回调函数中动态加载模块, import(模块).then()
    - Vue: () => import('./Foo.vue'), 实现路由组件懒加载
    - React: Suspence +lazy(() => import('./SomeComponent')), 实现路由组件懒加载

#### preload 和 prefetch 预加载

- 作用：
  - 让资源提前加载
- 区别：
  - preload 让当前页面的要使用资源加载（延后加载）
  - prefetch 让后面要使用资源提前加载（当前不需要使用）
- 使用：
  - import(/*webpackChunkName: xxx webpackPrefetch: true */'./xxx')
  - import(/*webpackChunkName: xxx webpackPreload: true */'./xxx') // 没有效果
  - 问题：兼容性较差 
- 使用Chrome团队提供的一个工具包: preload-webpack-plugin
  - npm i -D preload-webpack-plugin@next  // 必须是最新的下一个版本
  - 对异步模块包使用: prefetch
  - 对同步模块包使用: preload

#### 浏览器cache/缓存

- hash 
  - webpack每次构建都会生成一个新的且唯一的hash
  - 问题：只要webpack重新构建，所有文件的hash都会发生变化，缓存就会失效

- chunkhash
  - 打包属于同一个chunk，就共享同一个hash
  - 问题：样式文件被css-loader打包js文件中，导致样式文件和js文件属于同一个chunk，共享同一个hash
  - 一旦样式文件发生变化，js文件也会变

- contenthash
  - 根据文件的内容来成hash，所以只要文件内容不一样，hash就不一样
  - 问题：
    - 比如A模块有一个依赖，是B模块，那么A模块内部就会保存B模块hash值，
    - 一旦B模块发生变化，B模块的hash值就会变，导致A模块内部保存B模块hash值也发生改变
    - 此时A模块文件内容发生变化，它的hash值也会变
  - 解决：
    - runtimechunk: true 将A模块保存的B模块hash值存到runtime文件中，这样A模块内部就没有B模块的hash值了，就不会因为B模块的修改而修改



### 基础

- entry 入口

  指示 webpack 从哪个文件开始打包

- output 输出

  指示 webpack 将打包后的文件输出到哪里去

- loader 加载器

  帮助 webpack 解析它解析不了的模块（将其他模块解析成 webpack 能识别的模块，这样才能打包）

  还有其他功能：多进程打包...

- plugin 插件

  能够功能更加强大的事

  将现有库包装成 webpack 能够识别的功能模块，从而加载使用

- mode 模式

  模式（development/production）

  区别：设置不同 NODE_ENV，启用不同的插件

### 其他配置

- resolve 解析：帮助 webpack 解析模块

  alias 配置路径别名

  extensions 配置自动补全文件扩展名

  modules 配置 引入 node_modules 库，node_modules 文件夹去哪找

- optimization 优化

- devServer 开发服务器

### 兼容性处理

- JS 兼容性处理 babel
- CSS 兼容性处理，使用 postcss-loader 做 css 兼容性处理

### 摇树（**tree shaking**）

- 摇树：去除无用的 JS 代码

- 配置

  必须使用 ES6 模块化

  开启 mode: production

### 缓存

- 客户端端缓存服务器请求的资源（js/css/图片...）

  - 强制缓存（不会重新访问服务器，直接读取缓存）

    问题：如果资源在缓存期间内，是没办法更新的~

  - 协商缓存（每次都会重新访问服务器，由服务器来决定要不要走缓存，304）

- hash webpack 打包生成的，所以资源共享 hash 值

  问题：如果改动一个资源，所有资源的 hash 都变~导致其他资源缓存失效

- chunkhash 属于同一个 chunk，hash 值一样，不同 chunk，hash 值不一样

  问题：单入口样式文件因为 css-loader，会把样式文件打包到 js 中，此时就会和 js 共享同一个 hash 值，一旦改动 js/css 文件，css/js 文件缓存失效

- contenthash 根据文件内容来生成 hash，不同文件 hash 值不同

  新问题：如果 A 文件采用 import 进行代码分割文件 B，分割文件 B 一旦变化，那么 A 文件缓存失效

  原因是：A 文件保存 B 文件的 hash 值，一旦 B 文件变化，A 文件的 hash 值也要更新，从而导致 A 文件也变了

  解决：需要将 A 文件保存 B 文件的 hash 值单独提取出来，成单独文件，这样就不会影响 A 文件了

  ```js
  runtimeChunk: {
    name: (entry) => `runtime-${entry.name}.js`;
  }
  ```

### 关闭map(vue项目生产环境)

productionSourceMap: false, // 关闭map映射文件



### 实际使用

#### require.context

```javascript
//store/index.js

const moduleFIles = require.context('./modules', true, /\.js$/)
const modules = moduleFiles.keys().reduce((modules, modulePath) => {
  let moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
  //处理多层文件
  if (moduleName.includes('/')) {
    let moduleNameParts = moduleName.split('/')
    for (let idx=1,len=moduleNameParts.length; idx<len; idx++) {
      const item = moduleNameParts[idx]
      moduleNameParts[idx] = item.slice(0, 1).toUpperCase() + item.slice(1)
    }
    moduleName = moduleNamePargs.join('')
  }
  const value = modulesFiles(modulePath)
  modules[moduleName] = value.default
  return modules
}, {})
```



## 8. Vue 基础

### 什么是MVVM

Model–View–ViewModel （MVVM） 是一个软件架构设计模式,

ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model
View 和 Model 之间的同步工作完全是自动的，无需人为干涉（由viewModel完成，在这里指VUE）
因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理

* M：model、就是模型数据，普通的JS对象.可以理解为data中的对象
* V：view、就是Dom
* VM：view-model、就是Vue，view和model不可以直接交互，需要通过VM联系到一起

<span style="background: #ccc">M 到 V（数据驱动视图）：Data Bindings：通过<span style="color:red">数据绑定</span>联系到一起。</span>

<span style="background: #ccc">V 到 M（视图影响数据）：Dom Listeners：通过<span style="color:red">事件监听</span>联系到一起。</span>

<span style="background: #ccc">只要数据进行了改变，同时视图也会同时更新。</span>





### 怎么实现vm

1.需要利用Object.defineProperty，将要观察的对象，转化成getter/setter，以便拦截对象赋值与取值操作.也就是<u>数据观察者</u><span style="color:blue">Observer</span>；

2.将DOM解析，提取其中的指令与占位符，并赋与不同的操作. 也就是<u>指令解析器</u><span style="color:blue">Compile</span>

3.需要将Compile的解析结果，与Observer所观察的对象连接起来，在Observer观察到对象数据变化时，接收通知，同时更新DOM. 也就是<u>订阅者</u><span style="color:blue">Watcher</span>，它是Observer和Compile之间通信的桥梁；

4.最后，需要一个公共入口对象，接收配置，协调上述三者，称为vm，也就是Vue;

### Vue响应式

Vue响应式指的是：组件的data发生变化，立刻触发视图的更新 

2. 实现原理： Vue 采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。



### vue优点

数据和视频之间的同步工作完全是自动的，无需人为干涉，所以开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题， 复杂的数据状态维护完全由 MVVM 来统一管理，节省了很多精力。

### Vue数据流

1. Vue也是一个单向数据流的框架
2. Vue通过指令实现了双向数据绑定： v-model
3. v-model都做了哪些事情; `<input v-model='msg' />`
   1. 将指定变量的数据赋值给input的value
   2. 给当前的表单项自动绑定一个input事件，监听View层表单项数据发生改变获取最新value的同时更新Model的数据



### vue数据绑定原理

Vue的数据双向绑定都是依据Object.defineProperty()这一方法来做的, 这个方法可以定义一个对象某个属性的描述符, 我们需要用到的就是描述符当中的getter和setter

```javascript
const obj = {a:1}
obj.a // 1

obj.a = 2
```

当我们输入obj.a时 就是在访问obj对象a属性的getter 当输入obj.a = 2 时就是在访问obj对象a属性的setter

```javascript
Object.defineProperty(obj, 'a', {
  get : function(){
    return val
  },
  set : function(newValue){
    val = newValue
  },
  enumerable : true,
  configurable : true
})
```

getter和setter都是一个函数 我们还可以这样做 例如

```javascript
get: function() {
  // 每次访问obj.a时都会执行这段代码
  console.log('hello, 你在读取a的值')
  return val
}
set: function(newValue) {
  val = newValue
  // 每次给obj.a赋值时都会执行这段代码
  console.log('你设置了a的值')
}
```

Vue的双向数据绑定就是根据上面的原理来实现的 只要在读取值时收集观察者 在赋值时触发观察者更新函数 就可以实现数据变更 从而实现DOM重新渲染

复制放到HTML文件里自己运行一下 然后打开网页 在控制台里输入data.user.name看看 会有惊喜

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>动态数据绑定（一）</title>
</head>
<body>
 <script>
    var data = {
        user: {
            name: 'xiaoming',
            age: 18,
            occupation: 'frontend'
        },
        address: {
            city: 'shaoguan'
        }
    }; 
    function Observer(data) {
        this.data = data;
        this.walk(data);
    }
    Observer.prototype = {
        walk: function(obj) {
            var value,
                key;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    value = obj[key];
                    if (typeof value === 'object') {
                        new Observer(value);
                    }
                    this.convert(key, value); 
                }   
            }
        },
        convert: function(key, value) {
            Object.defineProperty(this.data, key, {
                get : function(){ 
                    console.log("你访问了" + key);
                    return value; 
                },
                set : function(newValue){ 
                    value = newValue; 
                    console.log('你设置了' + key + '=' + value);
                }
            });
        }
    }  
    var example = new Observer(data);
 </script>   
</body>
</html>
```











### 组件间通信的方式

#### 根据通信的2个组件间的关系来选择一种通信方式

```
父子
	props
	vue自定义事件
	v-model
	.sync
	$refs, $children与$parent
	插槽 ==> 作用域插槽
祖孙
	$attrs与$listeners
	provide与inject
兄弟或其它/任意
	全局事件总线
	Vuex
```



#### 方式1: props 

```
1). 实现父向子通信: 属性值是非函数
2). 实现子向父通信: 属性值是函数
应用: 最基本, 用得最多的方式
```



#### 方式2: vue自定义事件

```
1). 用来实现子组件向父组件通信
2). 相关语法:
    父组件中给子组件绑定自定义事件监听:
      <Child @eventName="callback">
    子组件中分发事件
      this.$emit('eventName', data)
应用: elment-ui的组件的事件监听语法都用的是自定义事件
      我们项目中的组件也用了不少自定义事件
```



#### 方式3: 全局事件总线   ===> 消息订阅与发布

```
1). 实现任意组件间通信
2). 编码:
    将入口js中的vm作为全局事件总线对象: 
        beforeCreate() {
            Vue.prototype.$bus = this
        }
    分发事件/传递数据的组件: this.$bus.$emit('eventName', data)
    处理事件/接收数据的组件: this.$bus.$on('eventName', (data) => {})
应用: 前台项目中使用全局事件总线
```

#### 方式4: v-model

    1). 实现父子之间相互通信/同步
    2). 组件标签上的v-model的本质: 自定义input监听来接收子组件分发$emit的数据更新父组件数据
        父组件: 
            <CustomInput v-model="name"/>
            <!-- 等价于 -->
            <CustomInput :value="name" @input="name=$event"/>
        子组件: 
            <input type="text" :value="value" @input="$emit('input', $event.target.value)">
            props: ['value']
    应用: element-ui中的表单项相关组件都用了v-model: Input / Select / Checkbox / Radio

#### 方式5: .sync

    1). 实现父子之间相互通信/同步(在原本父向子的基础上增加子向父)
    2). 组件标签的属性上使用.sync的本质: 事件监听来接收子组件分发$emit过来的数据并更新父组件的数据
        父组件:
            <child :money.sync="total"/>
            <!-- 等价于 -->
            <Child :money="total" @update:money="total=$event"/>
    
            data () {
              return {
                total: 1000
              }
            },
        子组件:
            <button @click="$emit('update:money', money-100)">花钱</button>
            props: ['money']
    应用:  
        element-ui在有显示隐藏的组件上: Dialog / Drawer

#### 方式6: $attrs与$listeners

    1). $attrs
        //实现当前组件的父组件向当前组件的子组件通信
        父组件传递给子组件的属性,除了props已经声明接收的属性及父组件的style,class属性.
        它是包含所有父组件传入的标签属性(排除props声明, class与style的属性)的对象
        使用: 通过 v-bind="$attrs" 将父组件传入的n个属性数据传递给当前组件的子组件
    2). $listeners
        实现当前组件的子组件向当前组件的父组件通信
        $listeners是包含所有父组件传入的自定义事件监听名与对应回调函数的对象
        使用: 通过v-on="$listeners" 将父组件绑定给当前组件的事件监听绑定给当前组件的子组件
    应用: 利用它封装了一个自定义的带hover文本提示的el-button

#### 方式7: $refs & $children & $parent

    1). $refs
        实现父组件向指定子组件通信
        $refs是包含所有有ref属性的标签对象或组件对象的容器对象
        使用: 通过 this.$refs.child 得到子组件对象, 从而可以直接更新其数据或调用其方法更新数据
    2). $children
        实现父组件向多个子组件通信
        $children是所有直接子组件对象的数组
        使用: 通过this.$children 遍历子组件对象, 从而可以更新多个子组件的数据
    3). $parent
        实现子组件向父组件通信
        $parent是当前组件的父组件对象
        使用: 通过this.$parent 得到父组件对象, 从而可以更新父组件的数据
    应用: 在后台管理项目中使用了$refs

#### 方式8: provide与inject

	1). 实现祖孙组件间直接通信
	2). 使用
		在祖组件中通过provide配置向后代组件提供数据
		在后代组件中通过inject配置来声明接收数据
	3). 注意:
		不太建议在应用开发中使用, 一般用来封装vue插件
		provide提供的数据本身不是响应式的 ==> 父组件更新了数据, 后代组件不会变化
		provide提供的数据对象内部是响应式的 ==> 父组件更新了数据, 后代组件也会变化
	应用: element-ui中的Form组件中使用了provide和inject



#### 方式9: vuex

- vuex用来统一管理多个组件共享的状态数据

- 任意要进行通信的2个组件利用vuex就可以实现

  A组件触发action或mutation调用, 将数据保存到vuex的状态中

  B组件读取vuex中的state或getters数据, 得到最新保存的数据进行显示
  
- 面试题

  1. mutation负责同步修改状态数据的，能不能异步修改

     可以异步修改

     如果异步修改的话会导致Vuex的调试工具失效，无法检测异步修改数据

  2. 设计的时候为什么建议mutation同步修改状态数据，而新增action负责异步

     Vuex的作用是给多个组件共享数据

     如果支持mutation异步修改数据，又因为异步的特性，会导致store对象中state数据发生错乱甚至是报错

     为了数据的安全

  3. Vuex刷新页面，数据丢失问题

```js
 //数据丢失原因
1.	Vuex数据保存在运行内存中，vue实例初始化的时候为其分配内存
2.	当刷新页面的时候重新初始化Vue实例，所以重新为Vuex分配内存导致之前保存的数据丢失

   //如何解决?
1.	Vuex的数据都是每次组件加载时候动态请求获取数据保存
a)	优点： 保证数据不会丢失
b)	缺点: 性能差，因为网络问题可能有网络延迟

2.	将Vuex中的数据每次同步更新保存到sessionStorage中
a)	优点: 每次页面刷新后从sessionStorage中获取保存的数据，不会丢失
b)	缺点: state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差

3.	在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取
a)	优点: 减少动态更新sessionStorage的次数，性能好
b)	重点: 给window绑定beforeupload事件监听
```



```js
//绑定事件监听: 在页面卸载(关闭)或刷新时候保存当前数据
// beforeunload 页面即将刷新之前调用
window.addEventListener('beforeupload', () => {
    sessionStorage.setItem('test2', JSON.stringify(this.personArr))
})
// 读取sessionStorage中是否有之前缓存的数据
let personArr = sessionStorage.getItem('test2')
// 如果有： 更新Vuex中状态数据
personArr && this.changePersonArrMutation(JSON.parse(personArr))
```









#### 方式10:  插槽  ==> 作用域插槽slot-scope

    1). 实现父组件向子组件传递标签内容
    2). 什么情况下使用作用域插槽?
        父组件需要向子组件传递标签结构内容
        但决定父组件传递怎样标签结构的数据在子组件中
    3). 编码:
        子组件:
            <slot :row="item" :$index="index">  <!-- slot的属性会自动传递给父组件 -->
            </slot>
        父组件:
            <template slot-scope="{row, $index}">
                <span>{{$index+1}}</span> &nbsp;&nbsp;
                <span :style="{color: $index%2===1 ? 'blue' : 'green'}" >{{row.text}}</span>
            </template>
    应用: element-ui中的Table组件



### computed与method和watch的区别

- **computed** 

  1. 支持缓存，多次读取, 只会执行一次计算, 只有依赖数据发生改变，才会重新进行计算 
  2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
  3. 底层用到的是对象set和get方法: 简写为函数形式,就是get方法;完整写法为对象,get+set方法;
     1. setter和getter中的this上下文自动绑定为Vue实例;如果使用箭头函数形式, 可以将实例作为第一个参数
  4. 执行时机: 初始化时; 当依赖数据发生变化时;



- method

  - 没有缓存, 多次读取, 必须多次调用

- **watch**

  1. watch支持异步；
  2. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
  3. 当一个属性发生变化时，需要执行对应的操作；一对多；
  4. 监听数据必须是一个响应式数据(data/props/computed)

  　　immediate：组件加载立即触发回调函数执行，

  　　deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变



```bash
computed：计算属性
计算属性是由data中的已知值，得到的一个新值。
支持缓存，多次读取, 只会执行一次计算, 只有依赖数据发生改变，才会重新进行计算 

watch：监听数据的变化
支持异步
监听数据必须是一个响应式数据(data/props/computed)

1.watch擅长处理的场景：一个数据影响多个数据

2.computed擅长处理的场景：一个数据受多个数据影响
```

### Vue 列表为什么加 key？

比如有很多li元素，要在某个位置插入一个li元素，但没有给li上加key，那么在进行运算的时候，就会将所有li元素重新渲染一遍，但是如果有key，那么它就会按照key一一比对li元素，只需要创建新的li元素，插入即可，不需要对其他元素进行修改和重新渲染。 

key也不能是li元素的index，因为假设我们给数组前插入一个新元素，它的下标是0，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了



### Vue 中 $nextTick 作用与原理？

Vue 在更新 DOM 时是异步执行的，在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。

所以修改完数据，立即在方法中获取DOM，获取的仍然是未修改的DOM。 $nextTick的作用是：该方法中的代码会在当前渲染完成后执行，就解决了异步渲染获取不到更新后DOM的问题了。 $nextTick的原理：$nextTick本质是返回一个Promise

应用场景：在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中





### vfor与vif同时使用的问题?

> 在官方文档中明确指出**v-for和v-if不建议一起使用**。 原因：v-for比v-if优先级高，所以使用的话，每次v-for都会执行v-if,造成不必要的计算，影响性能，尤其是当之需要渲染很小一部分的时候。

`v-for` 和 `v-if` 同时使用有 3 种情景：

1. 部分遍历（内/外部条件）：一个 `list` 中某个属性值符合条件的遍历出来；
2. 全部遍历（外部条件）：某外部条件符合条件时遍历全部。
3. 全部遍历（内部条件）：根据某内部条件渲染出不同的内容。

#### 解决方案:

##### 使用计算属性

> 在计算属性中先用内/外部条件处理数据，再遍历处理后的数据

```javascript
<!-- 遍历list，条件是值小于100 方案：使用计算属性activeList首先筛选出符合条件的值再直接遍历 -->
<ul>
  <li v-for="item in activeList" :key="item"></li>
</ul>

export default {
  data() {
    return {
      list: [78, 90, 20, 45, 66, 120, 136]
    }
  },
  computed: {
    activeList() {
      return this.list.filter((item) => item < 100)
    }
  }
}
```



##### 条件放于父元素(外部条件)

> 解决方案：外部条件放到遍历的父级元素上，没有父级可以使用`<template></template>`。

```html
<ul v-if="isActive">
  <li v-for="item in list" :key="item"></li>
</ul>
<!-- or -->
<div>
  <template v-if="isActive">
    <span v-for="item in list" :key="item"></span>
  </template>
  <p>Hello,My name is Lillian!</p>
</div>

<script>
export default {
  data() {
    return {
      isActive: true,
      list: [78, 90, 20, 45, 66, 120, 136]
    }
  }
}
</script>
```



##### 遍历`template`(内部条件)

> 根据某内部条件，显示不同内容。注意 `key` 不能放 `template` 标签上

```html
<div>
  <template v-for="item in list">
    <span v-if="item.type===0" :key="item.id">文字+图标</span>
    <span v-if="item.type===1" :key="item.id">文字+文字</span>
    <span v-else :key="item.id">其他</span>
  </template>
</div>
```

`vue` 中会优先执行 `v-for`, 当 `v-for` 把所有内容全部遍历之后 , `v-if` 再对已经遍历的元素进行删除 , 造成了加载的浪费 , 所以应该尽量在执行 `v-for` 之前优先执行 `v-if` , 可以减少加载的压力。







### 为什么组件中的data必须是函数形式？

- Vue解析组件标签时，会创建一个新的组件实例对象
- 每个组件实例对象, 都需要有自己的data数据对象
- 如果data配置是对象, 就会导致同个组件的多个实例共享一个data对象
- 如果data是函数, 组件的多个实例的data对象是各自的, 是多份



### 如何理解vue的渐进式

![](https://img-blog.csdn.net/201806191038393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6dW5rdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



所谓的渐进式框架,就是把框架分层.

最核心的部分是视图层渲染,然后往外是组件机制,在这个基础上再加入路由机制,再加入状态管理,最外层是构建工具.

所谓分层,就是说你既可以只用最核心的视图层渲染功能来快速开发一些需求,也可以使用一整套全家桶来开发大型应用.



### 自定义指令

```js
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
```











### Vue实例的生命周期函数

#### 是什么

> 每个 Vue 实例在被创建时都要经过一系列的初始化过程, 这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同阶段添加自己的代码的机会





Vue生命周期说明

* 有什么
* 三个阶段
  * 挂载阶段=>beforeCreate、created、beforeMounted、mounted
  * 更新阶段=>beforeUpdate、updated
  * 销毁阶段 beforeDestroy、destroyed
* 每个阶段适合干什么
  * created：实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求
  * 页面的初始化 beforeMount 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 
  * mounted：实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求
  * beforeupdate：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 
  * updated：虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作避免在这个钩子函数中操作数据，可能陷入死循环 
  * beforeDestroy：实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例，常用于销毁定时器、解绑全局事件、销毁插件对象等操作

| 生命周期钩子    | 说明                                                         | 对应上述步骤   |
| --------------- | ------------------------------------------------------------ | -------------- |
| `beforeCreate`  | 初始化实例前，`data`、`methods`等不可获取                    | 1 之后，2 之前 |
| `created`       | 实例初始化完成，此时可获取`data`里数据和`methods`事件，无法获取 DOM | 2 之后，3 之前 |
| `beforeMount`   | 虚拟 DOM 创建完成，此时未挂载到页面中，`vm.$el`可获取未挂载模板 | 3 之后，4 之前 |
| `mounted`       | 数据绑定完成，真实 DOM 已挂载到页面，`vm.$el`可获取真实 DOM  | 4 之后         |
| `beforeUpdate`  | 数据更新，DOM Diff 得到差异，未更新到页面                    | 5 之后，6 之前 |
| `updated`       | 数据更新，页面也已更新                                       | 6 之后         |
| `beforeDestroy` | 实例销毁前                                                   | 7 之前         |
| `destroyed`     | 实例销毁完成                                                 | 7 之后         |



#### 重要生命周期函数（开发中常用） 

- **created / mounted** 

  发送AJAX请求、设置定时器等一次性任务

  created速度更快

- **beforeDestroy** 

  做一些收尾工作：取消AJAX请求，清除定时器等

#### 周期函数补充

- 动态组件

  `<component :is="comName"></component>`  is属性来切换不同的组件

  正常传入props数据就可以接受到

- 缓存组件

  ```vue
  <keep-alive :include="['a','b']>
    <component :is="view"></component>
  </keep-alive>
  ```

- **errorCaptured(errObj, errVM, errMsg)**

  捕获一个来自子孙组件的错误时被调用

  return false // 阻止错误继续向上传播，并且不会在浏览器控制台抛出错误

  参数：错误对象，抛出错误的实例，错误信息



动态`<component>`案例

```vue
// src/comopnents/baseComponents/baseForm/index.vue

<template>
	<div @clik.stop>
    <component
    	:is="componentId"
      v-bind="$attrs"
      @click="(param) => this.$emit('click', param)"
    ></component>
  </div>
</template>


<script>
	import baseInput from "./baseInput"
  import baseSelect from "./baseSelectCustom"; // 定制版
  import baseTime from "./baseTime";
  import baseCheck from "./baseCheck";
  import baseJudge from "./baseJudge";
  import baseupload from "./baseupload";
  import baseSelectQuery from "./baseSelectQuery";
  import baseSelectQuery_two from "./baseFromMask_two";
  import baseSearchShll from "./baseSearchShll";
  import baseCheckTwo from "./basecheckTwo";
  import baseTime_two from "./baseTime_two";
  import baseCheckthree from "./baseCheckthree";
  import baseInputTwo from "./baseInputTwo";
  import baseuploadMetering from "./baseuploadMetering";
  import baseInputSelects from "./baseInputSelects";
  import basejudeFlag from "./basejudeFlag"
  import basePopup from "./baseInputpopup";
  import baseInforSearchShll from "./baseInforSearchShll";
  import baseTimeashdas from "./baseTimeashdas";
  import baseJudges from "./baseJudges";
  import baseJudgetb from "./baseJudgetb";
  
  export default {
    name: 'baseFrom',
    components: {
      baseInput,
      baseSelect,
      baseTime,
      baseCheck,
      baseJudge,
      baseupload,
      baseSelectQuery,
      baseSelectQuery_two,
      baseSearchShll,
      baseCheckTwo,
      baseTime_two,
      baseCheckthree,
      baseInputTwo, 
      baseuploadMetering,
      baseInputSelects,
      basejudeFlag,
      basePopup,
      baseInforSearchShll,
      baseTimeashdas,
      baseJudges,
      baseJudgetb,
    },
    props: {
      type: {type:String, default: '1'}
    },
    computed: {
      componentId() {
        return [
          "baseInput",//ok
          "baseSelect",//ok
          "baseTime",//ok
          "baseCheck",//ok
          "baseJudge",//ok
          "baseupload",//该组件默认不可修改
          "baseSelectQuery",//ok
          "baseSelectQuery_two",//
          "baseSearchShll",//9
          "baseCheckTwo",//ok
          "baseTime_two",//ok
          "baseCheckthree",//ok
          "baseInputTwo", //13ok
          "baseuploadMetering", // 14
          "baseInputSelects",//15
          "basejudeFlag",//16
          "basePopup",
          'baseInforSearchShll',//18ok
          'baseTimeashdas',//19ok
          'baseJudges',//20ok
          'baseJudgetb',//21ok
        ][this.type - 1];
      }
    }
  }
</script>
```



```vue
// 其他组件调用baseForm

<!-- 发电用户普查 -->
<article class="publicData" v-show="powerUsers">
  <template v-for="(item, index) in publicEntryList">
	<baseFrom
          v-if="[19].indexOf(index) != -1"
          :key="index"
          v-bind="item"
          v-model="publicEntryList[index]"
          @click="entryList($event, item, index)"
          />
  </template>
</article>
```



##### 在缓存组件的基础上存在的声明周期

- **activated()**

  每次缓存组件被激活时就会调用

- **deactivated()**

  缓存的组件停用时调用，可替代destroyed



#### 父子组件生命周期

加载渲染过程

父 beforeCreate -> 父 created -> <span style="color:blue">父 beforeMount -></span><span style="color:red"> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted </span>-> <span style="color:blue">父 mounted</span>

子组件更新过程

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

父组件更新过程

父 beforeUpdate -> 父 updated

销毁过程

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed







### 路由

#### 重载组件,页面没有变化的解决方法

当从 C 组件切换到 C 组件（只更新参数的时候），C 组件并不会被重新创建或卸载，而是复用之前 C 组件，这样会导致只有路由变化，页面没有发生变化

<span style="color:red;">解决方案：</span> 3种

* watch
* beforeRouteUpate
* router key

##### watch

​	使用watch进行监视，因为每次更新时，$route都会创建一个新对象 ，而不是原对象，所以所有数据都是新的，可以监视

```js
watch: {
  $route(to, from) {
    // to 变化前的路由对象
    // from 变化后的路由对象
  }, 
}

//项目中使用
search页面改变参数，无法重复发请求的问题
watch: {
    $route(newVal, oldval) {
      this.handlerSearchParams();
      this.getSearchInfo();
    },
  },
```



##### beforeRouteUpdate

```javascript
beforeRouteUpdate(to, from, next) {
  
}
```



##### router key

> https://mp.weixin.qq.com/s/0Yekkc08ozbNxuquHVGveg

```html
<router-view v-bind="$route.fullpath"></router-view>
```



#### history模式刷新404问题解决方法

通过配置webpack来解决：在devServer中加 historyApiFallback: true

index.html 需要将 href="./bootstrap.css" 改成 href="/bootstrap.css"

webpack.config.js 需要output上增加 publicPath: '/'



#### 命名路由的时候params和query分别可以和什么搭配使用

query + name

query + path

params + name  (怎么记忆, 都有am)



#### **路由传参**

1. query
   传参方式：

       1. 注册的路由的时候不需要做任何事情
       2. 请求的时候通过path?key=value&key2=value2
        
       query参数无需声明即可接收,接收通过计算属性this.$route.query

   获取:  $route.query.key

   使用场景：适合多个参数
   
2. params

   传参方式:

   1. 注册路由的时候需要声明占位符，{path: '路由路径/:key(占位符)'}
   2. 请求的时候通过 path/params参数

   获取:  $route.params.key

   使用场景：

   1. 通常只有一个参数的时候(也可以指定多个params参数)
   2. 该参数通常是一个标识id

3. meta

   传参方式:

   1. 注册的时候通过meta字段进行参数设置

   获取:  $route.meta.key

   使用场景：

   1. 路由元信息，用于描述当前的路由信息
   2. 可以自定义参数内容的时候(可以有多个)

4. props

   传参方式:

   1. 布尔值(只能搭配params参数使用)
   2. 对象(用于自定义参数)
   3. 函数(自定义参数 + 路由信息)

   获取:  在组件内部通过props接收获取

   使用场景：用来解耦$route和组件实例的耦合度



#### params传入多个参数行不行

可以，第一次加载没问题，刷新没有用冒号指定的参数消失

只有在路由中指定的参数才可以正常使用



#### $router VS $route的区别

1. $router

   路由器对象

   用来控制路由的跳转，包含相关方法: push()/replace()/back()/addRoutes()

2. $route

   路由信息对象

   包含当前路由的所有信息(path, query, params, meta)





### 导航守卫（路由守卫）

#### 全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // 使用场景： 验证用户身份，判断用户是否登录
  if(isLogin){ // 如果登录，正常跳转至home
    next()
  }else { // 如果未登录就跳转至登录界面
    if(to.path === '/login'){
      next()
    }else {
      next('/login')
    }
  }
})
```

#### 全局解析守卫

- 这和 `router.beforeEach` 类似，区别是在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后**，解析守卫就被调用。

```js
router.beforeResolve((to, from, next) => {
  // 负责解析路由地址，加载对应的路由组件
})
```

#### 全局后置钩子

```js
router.afterEach((to, from) => {
  // 路由完全跳转后执行
})
```

#### 组件内的守卫

```js
beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
    // 因为当守卫执行前，组件实例还没被创建
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
},
beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
},
beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
}
```



#### 路由守卫

```js

```



### 完整导航解析流程

1. 导航被触发。
2. 在失活的组件里调用组件后置守卫 `beforeRouteLeave` 。
3. 调用全局前置守卫 `beforeEach` 。
4. 在重用的组件里调用 组件解析守卫`beforeRouteUpdate`  (2.2+)。
5. 在路由配置里调用路由前置守卫 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用组件前置守卫 `beforeRouteEnter`。
8. 调用全局解析守卫 `beforeResolve` (2.5+)。
9. 导航被确认。
10. 调用全局后置守卫 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用组件前置守卫 `beforeRouteEnter` 中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。



#### 触发钩子的完整顺序

> https://www.yuque.com/cuggz/interview/hswu8g#2c3f563ad7506984575f1a323937c5c0

路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件

- beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。
- beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。
- beforeEnter：路由独享守卫
- beforeRouteEnter：路由组件的组件进入路由前钩子。
- beforeResolve：路由全局解析守卫
- <u>afterEach：路由全局后置钩子</u>
- beforeCreate：组件生命周期，不能访问this。
- created;组件生命周期，可以访问this，不能访问dom。
- beforeMount：组件生命周期
- <u>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</u>
- mounted：访问/操作dom。
- <u>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</u>
- 执行beforeRouteEnter回调函数next。



### keep-alive

keep-alive是vue的内置组件，能在组件切换过程中将状态保留在内存中，相当于缓存，防止DOM的重复渲染；keep-alive有三个属性：include（只有名字匹配的才会被缓存）、exclude（任何名字匹配的都不会被缓存）、max（最多可以缓存多少个组件）。

在路由router的中：相应组件下规定meta属性，定义keep-alive：true；

可以结合Vue组件实例加载顺序讲解，VNode->实例化->_updata->真实Node，在实例化的时候会判断该组件是否被keep-alive保存过，是的话则直接拿其中的DOM进行渲染。



### 路由懒加载

引入路由时，动态引入，代码分割，异步加载，例：

```js
const Home = () => import('../components/Home/Home')
```

import函数不是webpack提供的语法。是es6语法

### Vue.use

1. 自定义Vue插件需要向外暴露对象或者是函数

2. 如果向外暴露对象的话，对象中必须有install方法

3. 如果向外暴露的是函数的话，那么该函数本身就是install方法

4. 当Vue.use()的时候，会自动调用install方法，并且将Vue对象作为实参传入到install方法中

### 打包相关

- 关闭map文件映射配置

  productionSourceMap: false, // 关闭map映射文件



### 1. Vue相关API

#### 1) 全局配置

- Vue.config对象的属性
- Vue.config.productionTip = false

#### 2) 全局API

- Vue.component(): 
- Vue.directive(): 
- Vue.filter(): 
- Vue.use(): 
- Vue.nextTick(callback): 
- Vue.set(): 
- Vue.delete():

#### 3) 配置选项

- 数据
  - data:
  - props: 
  - computed: 
  - methods: 
  - watch: 
- DOM
  - el: 
  - template: 
  - render: 
- 生命周期
  - beforeCreate
  - created
  - beforeMount
  - mounted
  - beforeUpdate
  - updated
  - beforeDestroy
  - destroyed
  - 
  - activated
  - deactivated
  - errorCaptured

```js
//生命周期
一. 各阶段钩子:
1.初始化阶段钩子: beforeCreate created 
1.1 挂载阶段钩子: beforeMount mounted 
2.更新阶段钩子: beforeUpdate updated
3.卸载阶段钩子: beforeDestroy destroied

二.阶段
1.初始化阶段:
new Vue()到created之间的阶段: 在vue实例上初始化一些属性,事件及响应式数据.

2.模板编译阶段
created到beforeMount钩子函数之间: 解析模板,生成虚拟dom放到内存,但并没有挂在到页面,页面不能显示解析好的内容.

3.挂载阶段
beforeMount到mounted钩子函数之间,将实例挂在到dom元素上.

4.更新阶段
beforeUpdate到updated钩子函数之间. 数据(状态)发生改变时,watcher会通知虚拟dom重新渲染视图,并会在渲染视图前触发beforeUpdate,渲染之后触发updated钩子函数.

5.卸载阶段
调用vm.$beforeDestroy方法后,组件生命周期进入卸载阶段,从父组件中删除,取消实例上所有依赖的追踪并且移除所有的事件监听器.

activated

deactivated

errorCaptured
```



- 资源
  - directives:
  - filters: 
  - components: 

```js
//directives 自定义指令
1.什么是指令?
 是带有v-特殊的属性.用来解析标签(包括:标签属性,标签体内容,绑定事件等)
2.自定义指令(全局+局部)
作用:对DOM元素进行操作.
语法:
全局指令加s,局部不加s
Vue.directives('指令名称', function(ele,binding){})
ele代表当前真实的dom节点,binding是一个含有绑定当前节点信息的对象. binding.value,value属性是irru的

//filter 过滤器
1.理解过滤器
 功能:对显示数据进行格式化
 注意:不改变原数据,而是产生新数据
2.使用
 2.1 使用
 使用地点:双花括号插值和v-bind表达式
 {{message|capitalize}}  
 <div v-bind:id="rawId|formatId"></div>

 2.2 定义
 Vue.filter(过滤器姓名, function(value){  //value就是接收的值,是message是rawId
     //数据处理
     return newValue
 }

 定义本地或全局过滤器:
 filters:{
     captitalize:function(value){
         if(!value)return '';
         value = value.toString();
         return value.charAt(0).toUpperCase()+value.slice(1)
     }
 }
 定义全局过滤器:
 Vue.filters('capitalize',function(value)){...}
 new Vue({
     //...
 })


//components 组件
```



- 杂项
  - mixins: 
  - provide / inject:  

```js
//mixins  混合
当多个组件有部分相同的js代码,利用mixin实现复用
```



- 其它
  - name: 
  - functional:

```js
//name
组件的名字

//functional
```



#### 4) 实例属性

- $el
- $parent
- $children
- $refs
- $attrs
- $listeners

```js
$el 用于指定当前vue实例为哪个容器服务

$parent 父组件对象
$children 子组件对象数组

$refs 含有注册过ref属性的所有dom元素和组件实例组成的对象.

$attrs  
父组件给子组件传递的所有属性组成的对象
$listeners
父组件给子组件传递的所有自定义方法组成的对象

```





#### 5) 实例方法

- 数据
  - $watch()
  - $nextTick()
  - $set()
  - $delete()

```js

```



- 事件
  - $on()
  - $once()
  - $off()
  - $emit()

```js
$once()
只执行一次
```



- 生命周期
  - $mount()
  - $nextTick()
  - $destroy()

```js

```



#### 6) 指令

- v-text 更新元素的文本内容
- v-html 更新元素的innerHtml
- v-show
- v-if
- v-else
- v-else-if
- v-for
- v-on
- v-once
- v-bind
- v-model
- v-slot

```js
//至少9种
v-text 更新元素的innerText
v-html 更新元素的innerHtml

v-show v-if 条件渲染
- 相同:都是根据条件来显示或隐藏组件
- 不同:v-if是真正的销毁组件, v-show是通过display:none的形式隐藏组件(无论条件如何,元素都会被渲染)
- 使用场景: v-if适用于使用频率低的组件,v-show适用于使用频率高的组件

v-else v-else-if  条件渲染

v-for 数据遍历

v-bind 绑定属性
v-on 绑定自定义事件
v-model 在表单控件或组件上实现双向数据绑定

//问题
v-for与v-if一起使用问题:

v-show v-if 条件渲染的比较:
- 相同:都是根据条件来显示或隐藏组件
- 不同:v-if是真正的销毁组件, v-show是通过display:none的形式隐藏组件(无论条件如何,元素都会被渲染)
- 使用场景: v-if适用于使用频率低的组件,v-show适用于使用频率高的组件
```



#### 7) 特殊属性

- key
- ref
- is

#### 8) 内置组件

- component
- transition
- keep-alive   缓存路由组件
- slot 插槽组件

### 2. vue组件的生命周期

#### 1) 单个组件生命周期

- 初始化:
  - beforeCreate
  - created
  - beforeMount
  - mounted
- 更新:
  - beforeUpdate
  - updated
- 死亡:
  - beforeDestroy
  - destroyed

#### 2) 父子组件的生命周期

```js
子组件初始化: 在父组件beforeMount-->mounted之间 执行beforeCreated->mounted4个钩子
子组件更新: 在父组件beforeUpdate->updated之间 执行2个钩子
子组件死亡: 在父组件beforeDestroy->destroyed之间 执行2个钩子
```



- 初始化:
  - beforeCreate
  - created
  - beforeMount
  - *--child beforeCreate*
  - *--child created*
  - *--child beforeMount*
  - *--child mounted*
  - mounted
- 更新:
  - beforeUpdate
  - *--child beforeUpdate*
  - *--child updated*
  - updated
- 死亡:
  - beforeDestroy
  - *-- child beforeDestroy*
  - *-- child destroyed*
  - destroyed

#### 3) 带缓存的路由组件生命周期keep-alive

```js
路由组件添加<keep-alive></keep-alive>之后,在mounted之后会出现activated
总结:路由组件生命钩子activated是在挂在mounted之后.离开的路由组件生命周期钩子deactivated是在进入的路由组件生命钩子mounted之前调用

(路由组件,activated是在自身mounted之后;deactivated是在进入其他路由组件mounted之前调用)
当前组件激活总是最后一个

 同级路由组件:离开一个进入一个 ++表示进入的路由组件,没有加的表示离开的路由组件
++beforeCreate
++created
++beforeMount
 deactivated
++mounted
++activated
```



- 初始化:
  - ...
  - mounted
  - *--Child activated*
  - activated
- 路由离开
  - *--Child deactivated*
  - deactivated
- 路由回来
  - *--Child activated*
  - activated

#### 4) 捕获子组件错误的勾子

- 子组件执行抛出错误
  - errorCaptured

```js
父组件中调用这个钩子:

errorCaptured(err,child,info){
    console.log('errorCaptured')
    console.log(err,child,info)  //打印的错误是灰色的
    return false;//不再向外传递,说明当前已经处理了错误
}
```



#### 5) 各个生命周期勾子说明

![vue组件生命周期详图.png](https://i.loli.net/2021/04/03/t4AIhPlnpNe8i9d.png)

(1) beforeCreate(): 在实例初始化之后调用, data和methods都还没有初始化完成, 通过this不能访问

初始化data与methods/computed

(2) created(): 此时data和methods都已初始化完成, 可以通过this去操作, 可以在此发ajax请求

编译模板

(3) beforeMount(): 模板已经在内存中编译, 但还没有挂载到页面上, 不能通过ref找到对应的标签对象

插入到界面上显示

(4) mounted(): 页面已经初始显示, 可以通过ref找到对应的标签, 也可以选择此时发ajax请求



n次更新数据

(5) beforeUpdate(): 在数据更新之后, 界面更新前调用, 只能访问到原有的界面

更新界面

(6) updated(): 在界面更新之后调用, 此时可以访问最新的界面



**销毁组件/ v-if隐藏/离开不缓存的路由组件**

(7) beforeDestroy(): 实例销毁之前调用, 此时实例仍然可以正常工作

(8) destroyed(): Vue 实例销毁后调用, 实例已经无法正常工作了



(9) deactivated():组件失活, 但没有死亡

(10) activated(): 组件激活, 被复用

(11) errorCaptured(): 用于捕获子组件的错误,return false可以阻止错误向上冒泡(传递)



```js
//面试题:
1.activated与mounted的区别?
 - activated在mounted之后执行
 - mounted只执行一次,activated可能会执行多次; //什么时候执行activated 带缓存keep-alive的组件

2.子组件在父组件的哪个钩子出现?
 - beforeMount

3.接口请求一般放在哪个生命周期?
 - created或mounted

4.created,mounted区别,在created中可以发送请求吗?
 - 区别:created执行时间早于mounted;操作dom节点需要在mounted中
 
5.页面加载会调用几个钩子?
 - 4个.如果有缓存设计,5个

6.第一个能看到tihs的生命周期函数
 - beforecreate  但是初始化还没完成,操作无意义;

7.第一个能发请求的钩子
 - created
8.第一个能操作dom的钩子
 - mounted
9.created钩子做了什么
 - 生命周期钩子只是通知,什么也没做. 在created之前已经完成初始化,可以通过this操作data,methods等
```





### 3. 组件深入

#### 1) 动态组件

- 通过<component>动态确定要显示的组件,  is指定要显示组件的组件名

```vue
<component :is="currentComp" />
```

- 问题: 当从A组件切换到B组件时, A组件就会销毁

#### 2) 缓存组件

- 使用<keep-alive>缓存动态组件, 可以通过include或exclude指定只缓存特定组件

```vue
<keep-alive :exclude="['Home']">
	<component :is="currentComp"/>
</keep-alive>
```

- 使用<keep-alive>也可以缓存路由组件

```vue
<keep-alive include="Life1">
	<router-view></router-view>
</keep-alive>
```

- 路由组件对象什么时候创建?
  - 默认: 每次跳转/访问对应的路由路径时
  - 有缓存: 第一次访问时
- 路由组件对象什么时候死亡?
  - 默认: 离开时
  - 有缓存: 离开时不死亡, 只有当destroy/父组件死亡/刷新页面

#### 3) 异步组件 

- 好处: 能更快的看到当前需要展现的组件界面(异步组件的代码开始没有加载)

- 无论是**路由组件**还是**非路由组件**都可以实现异步组件效果
  - 拆分单独打包
  - 需要时才请求加载组件对应的打包文件

- 配置组件: component: () => import(modulePath)
  - import(modulePath): 被引入的模块会被单独打包(code split)      --ES8的新语法
  - () => import(modulePath): 函数开始不调用, 当第一次需要显示对应的界面时才会执行, 请求加载打包文件
- 细节
  - import()返回promise, promise成功的结果就是整体模块对象
  - 本质上: 可以利用import()实现对任意模块的懒加载

#### 4) 函数式组件: functional + render + JSX

- 函数组件的特点
  - 无状态
  - 无法实例化
  - 内部没有任何生命周期处理函数
  - 轻量,渲染性能高,适合只依赖于外部数据传递而变化的组件(展示组件，无逻辑和状态修改)
  - 可以没有根标签
- 编码

```js
export default {
    functional: true, // 当前是函数组件
    render (createElement, context) {
        return 要显示界面的虚拟DOM
    }
}
```

#### 5) 递归组件

- 递归组件: 组件内部有自己的子组件标签
- 应用场景: 用于显示树状态结构的界面
- 注意: 递归组件必须有name
- 编码: 实现一个简单的可开关的树状结构界面的 Tree 组件



```js
//递归组件
```





```js
//面试题
1.keep-alive缓存组件介绍
-作用: 是vue中内置组件,保留组件状态或避免重新渲染.提供了include/exclude两个属性,实现有条件地进行缓存.
-使用
 <keep-alive>
 	<component></component>
 </keep-alive>

-生命钩子: keep-alive提供了两个生命钩子，分别是activated与deactivated。
```





### 3. Vue组件间多种通信方式

#### 1) 组件间通信方式列表

```
1) props
2) vue自定义事件
3) 全局事件总线
4) v-model
5) .sync 
6) $attrs与$listeners
7) $refs, $children与$parent
8) provide与inject
9) Vuex
10) 插槽 ==> 作用域插槽
```

#### 2) 通信方式的选择

```js
//父子
	props: 
		父向子
		子向父
	vue自定义事件: 
		子向父
	v-model: 
		父子之间
	.sync: 
		在父向子的基础上添加子向父
	$refs, $children与$parent: 
		$refs/$children: 父向子
		$parent: 子向父
	插槽 ==> 作用域插槽
		默认插槽/具名插槽: 父组件向子组件传递标签内容
		作用域插件: 子向父传递数据后, 父组件根据接收到的数据来决定向子组件传递不同的标签内容
//祖孙
	$attrs与$listeners
	provide与inject
//兄弟或任意
	全局事件总线
	Vuex
```

```js
//provide于inject案例

export default{
    //
    provide(){
        return { //声明向所有后代提供2个数据
            content1:this.content1,
            content2:this.content2,
            updateContent:this.updateContent
        }
    }
}

export default{
    //
    inject:['content1', 'content2', 'updateContent'] //声明注入的属性会成为组件对象的属性
}


//.sync

```





#### 3) 各种组件间通信详细说明

查看 ***vue_组件间通信.md***

```js
//组件间通信 面试题
1.父组件如何获取子组件实例对象的方法
 $refs, $children
 $refs包含所有有ref属性的标签对象或组件对象的容器对象, 通过this.$refs.组件name来操作子组件方法
 $children是所有直接子组件组成的数组
 
2.父子组件互相调用方法
 父调子:$refs, $children
 子调父:props, $parent

3.常用事件修饰符
.stop .prevent .native

4.v-on可以监听多个方法吗?
 可以. $listeners  <el-button v-on="$listeners">
```







### 4. Vue的响应式

#### 1) 几个重要问题?

- mvvm的理解, 与MVC的区别?

  > 查看word


```js
//什么是mvvm?
1.	M： Model模型, 也就是包含数据的js对象(只包含属性, 不包含方法)
2.	V： View视图，动态显示模型对象中的数据显示界面
3.	VM： ViewModel视图模型, 本质是一个绑定器, 通过vm读取model中的数据显示到view上, 同时view输入数据改变, vm也可以将输入数据保存到model中
4.	MVVM的优势: 不用亲自操作DOM, 数据是响应式的, 一旦数据变化,页面会自动更新


//mvvm与mvc的区别?
mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。

区别：vue数据驱动，通过数据来显示视图层而不是节点操作。

场景：数据操作比较多的场景，更加便捷
```

;

- **组件的data为什么只能是函数不能是对象?**
- 同一个组件的多个组件实例的data必须是不同的对象(内容初始数据可以相同)
  - 如果是data是对象, 组件的多个实例共用一个data对象
  - 如果是函数, 组件对象通过调用函数得到的一个新的data对象
- **响应式数据与非响应式数据?**
  - 响应式: data / props / computed/ vuex的state与getters
  - 非响应式:　仅仅存在于组件对象上的属性数据
    - 给组件对象添加一个新属性: this.xxx = value 
    - 直接给一个响应式对象添加一个新属性: this.product.xxx = 'abc'  ==> this.$set(this.product, 'xxx', 3)
- **对象的响应式与数组的响应式有什么区别?**
  - 对象: 通过Object.defineProperty()添加setter方法来监视属性数据的改变 + 订阅-发布
  - 数组: 重写数组一系列的更新数组元素的方法 + 订阅-发布(pop splice push shift unshift sort reverse)

```js
//vue种数组实现响应式为什么不用object.defineProperty
1.如果使用defineProperty,数组作为对象形式,只能通过下标属性来修改属性
2.假设数组元素过多,就需要为每一个元素添加这个属性, 使用方法效率高于此种方式.

重写数组方法的限制: 只能通过7个方法来更新数据.
```





#### 2) Vue数据绑定/响应式原理图

![vue响应式原理.png](https://i.loli.net/2021/04/06/GdBSN3OvCYelWty.png)



```js
//响应式原理
vue.js 是采用数据代理,数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。


```



- 理解:

  - 说vue的数据绑定的原理, 或者数据响应式的原理, 都是在说一个事

  - 当我们修改了data中的数据时, 组件界面是如何自动更新的

  - 这里涉及下面几个重点

    - 数据代理: Object.defineProperty()   this.msg = 'abc'   ==> data.msg = 'abc'
    - 数据劫持/监视: Object.defineProperty()
    - 发布-订阅: observer 与 dep 与 watcher

    this._data.msg = 'xxx'

- 数据代理 

  - 通过Object.defineProperty()给vm添加与data对象中对应的属性
  - 在getter中, 读取data中对应的属性值返回  ==> 当我们通过this.xxx读值时, 读取的是data中对应的属性值
  - 在setter中, 将最新的值保存到data中对应的属性上  ==>当我们通过this.xxx = value时, value保存在data中对应的属性上
  - 作用: 简化对vm/组件对象内部的data对象的属性数据的操作(读/写)

- 数据劫持/监视

  - 在observer中, 通过Object.defineProperty()给data中所有层次属性都添加上getter/setter
  - 为每个属性都创建一个dep对象, 用于后面更新
  - 注意: 在解析模板时, 为每个表达式都创建了一个用于更新对应节点的watcher
  - 在getter中, 去建立dep与watcher之间的关系
    - dep与data中的属性一一对应
    - watcher与模板中的表达式一一对应
    - 一个dep中, 保存了包含n个watcher的数组  ==> 当多个表达式用到当前dep所对应的属性
    - 一个watcher中, 保存了包含n个dep的对象 ==> 当表达式是一个我层的表达式
  - 在setter中, 通过dep去通知所有watcher去更新对应的节点

- 发布-订阅模式

  - 发布者: observer
  - 订阅者: watcher
  - 订阅器/中间人: dep

- 初始化

  - 实现数据代理: 通过defineproperty给vm/组件对象添加与data中对应的属性
    - 在getter中读取data中对应属性返回
    - 在setter中将最新的value保存到data对应的属性上
  - 创建oberver(发布者): 
    - 使用defineProperty来劫持/监视data中所有层次属性
    - 为data中每个属性创建对应的dep对象(订阅器) ==> 用于后面界面更新
  - 创建compile
    - 编译模板, 实现界面的初始化显示
    - 为每个包含非事件指令表达式的节点创建对应的watcher
      - 绑定用于更新界面的回调函数
      - 将watcher(订阅者)添加到dep(订阅器)中去

- 更新数据后的基本流程

  - this.xxx = value
  - 由于有数据代理, data中的xxx会更新
  - 由于有数据劫持, xxx对应的setter就会调用
  - 在setter中, 通过dep去通知所有对应的watcher去更新对应的节点



#### 3) Vue双向数据绑定

- 通过v-model来实现双向数据绑定
- v-model的本质
  - 将动态的data数据通过value属性传给input显示  ==> data到view的绑定
  - 给input标签绑定input监听, 一旦输入改变读取最新的值保存到data对应的属性上 ==> view到data的绑定
- 双向数据绑定是在单向数据绑定(data-->view)的基础, 加入input事件监听(view ==> data)



#### 4) 响应式原理面试交流总结

```js
dev是依赖对象,是中间人
watcher 监视器
```



- 初始化
  - 实现数据代理
    - 通过defineproperty给vm定义与data中属性对应的带getter/setter的属性
    - 在getter中, 读取data中对应的属性值返回      ==> 读取this.msg ==> 读取的是data中msg属性值
    - 在setter中, 将最新值保存到data对应的属性上   ==> this.msg = 'abc'   ==> 'abc'会保存到data的msg上
  - 创建observer
    - 目标: 对data中所有层次的属性进行监视/劫持
    - 通过defineproperty给data中所有层次属性, 都重新定义, 加上getter与setter
      - getter: 用来建立dep与watcher的关系   
      - setter: 用来当data数据发生改变去更新界面
    - 为data中所有层次的属性创建一个对应的dep   ==> 用来将来更新界面的
  - 创建compile
    - 目标1: 实现界面的初始化显示
    - 目标2: 为将更新做准备
      - 为模板中每个包含表达式(事件表达式除外)的节点创建一个对应的watcher
      - 给watcher绑定用于更新对应节点的回调函数
      - 将watcher添加到n个对应的dep中 

- 更新
  - this.msg = 'abc'
  - 由于有数据代理 ==> data的msg更新为了'abc'
  - 由于有数据劫持 ==> data中msg的setter调用了
  - 在setter中, 通过对应的dep去通知所对应的watcher去更新对应的节点     ==> 使用了订阅发布模式



### 5. 可复用性

#### 1) mixin(混入)

- 用来复用多个组件中相关的js代码的技术
- 将多个组件相同的js代码提取出来, 定义在一个mixin中配置对象
- 在多个组件中通过mixins配置引入mixin中的代码, 会自动合并到当前组件的配置中

```js
//使用流程
1.导入
import {cpMixin} from './mixin';
2.声明
export default {
    mixins:[cpMixin]
}
3.使用
<button @click="gaveMoney(50)"></button>  //gaveMoney是mixins中的方法
```



#### 2) 自定义指令

```js
Vue.directive('upper-text', (el, binding) => {
    el.innerText = binding.value.toUpperCase()
})
```

#### 3) 自定义过滤器

```js
// 注册全局过滤器
Vue.filter('date-format', (value) => {
  return moment(value).format('YYYY-MM-DD HH:mm:ss')
})
```

#### 4) 自定义插件

```js
// 对象插件
const myPlugin = {
    install (Vue) {
        // 通过Vue来扩展新的功能语法, 如注册全局组件/指令/过滤器/...
    }
}
// 函数插件
const myPlugin = (Vue) => {
    // 通过Vue来扩展新的功能语法, 如注册全局组件/指令/过滤器/...
}

export default myPlugin

// 在入口JS中引入, 并声明使用来安装插件
import myPlugin from './vue-myPlugin'
Vue.use(myPlugin)
```

#### 问题: Vue.use()内部做了什么?

- 对象插件: 调用插件对象的install方法(传入Vue)来安装插件(执行定义新语法的代码)
- 函数插件: 直接将其作为install方法来调用(传入Vue)来安装插件(执行定义新语法的代码)

### 6. Vue状态管理: Vuex

#### 1) vuex的5大属性

- state
- mutations
- actions
- getters
- modules

#### 2) vuex的数据流结构图

![vuex.png](https://i.loli.net/2021/04/06/HmRr8OqSuwsGa1W.png)

![vuex结构图.png](https://i.loli.net/2021/04/06/JhZR5cEqNXyj86O.png)



#### 3) vuex多模块编程

- vuex的多模块编程的必要性
  - vuex单模块问题: 
    - 需要的管理状态数据比较多, 那对应的mutations/actions模块就会变得比较大
    - 如果添加新的数据管理, 需要修改现在文件(不断向其添加内容) 
  - vuex多模块编程: 对各个功能模块的数据分别进行管理, 这样更加具有扩展性

- 什么时候需要用vuex多模块编程? 需要vuex管理的数据比较多时使用
- 多模块编程的总state结构:

```js
{
	home: {
        categoryList: [],
        xxx: {}
    },
    user: {
        userInfo: {}
    }
}
```

#### 4) 问题1: vuex中的mutation可以执行异步操作吗?

- 可以 ==> 异步更新数据后界面确实会自动更新
- 问题 ==> vuex的调用工具监视不到mutation中的异步更新, 工具记录还是更新前的数据(不对)
- 扩展: 工具如何记录数据变化? ==> 每次mutation函数执行完后, 立即记录当前的数据   ==> 在mutation中同步更新state, 才能被记录到



#### 5) 问题2: vuex中的状态数据的响应式的原理?

1. 创建了一个vue实例(vm)对象

2. state中的数据都是实例的data数据(是响应式的)

3. 组件中读取的state数据本质读取的就是data中的数据

4. 一旦更新了state中的数据, 所有用到这个数据的组件就会自动更新



#### 6) 问题3: vuex数据刷新丢失的问题

```js
//数据丢失原因
1.	Vuex数据保存在运行内存中，vue实例初始化的时候为其分配内存
2.	当刷新页面的时候重新初始化Vue实例，所以重新为Vuex分配内存导致之前保存的数据丢失


//如何解决?
1.	Vuex的数据都是每次组件加载时候动态请求获取数据保存
a)	优点： 保证数据不会丢失
b)	缺点: 性能差，因为网络问题可能有网络延迟

2.	将Vuex中的数据每次同步更新保存到sessionStorage中
a)	优点: 每次页面刷新后从sessionStorage中获取保存的数据，不会丢失
b)	缺点: state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差

3.	在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取
a)	优点: 减少动态更新sessionStorage的次数，性能好
b)	重点: 给window绑定beforeupload事件监听

```

- 绑定事件监听: 在页面卸载(关闭)或刷新时候保存当前数据

```js
beforeCreate(){
    window.addEventListener('beforeunload', () => {
	sessionStorage.setItem('CART_LIST_KEY', 
		JSON.stringify(this.$store.state.shopCart.cartList))
	})
}
```

- 在初始时读取保存数据作为状态的初始值. 解决页面刷新数据丢失的问题

```js
//state中初始化属性值
cartList: JSON.parse(sessionStorage.getItem('CART_LIST_KEY')) || [],
```



#### vuex面试题

```js
1.vuex与redux的区别
redux根据老的状态来更新新的状态

2.vuex和store的关系,vuex的5大属性
 vuex是vue插件,核心对象是store,store管理5大属性


3.vuex原理,组件传参方式
 构建一个vm,state中的数据都是实例的data属性
 组件传参方式? 先需要确认是否是组件和vuex传递数据
 组件->vuex dispatch commit
 vuex->组件: mapState,mapGetters
     
4.监听vuex自身数据
 两种方式获取vuex的state数据:  $store.state与mapState
 定义返回state数据的计算属性->通过watch监视这个计算属性->state变化,计算属性值,监视的回调

5.vuex理解
 - vuex是vue中集中式状态管理的一个插件,可以对组件共享状态进行集中式管理(管理:读写)
 - vuex是组件间通信的一种方式,可实现任意组件间通信.
 - 什么时候使用? 多个组件依赖同一状态,不同组件的行为要变更为同一状态: 购物车页面要根据登录状态来访问



6.vuex如何外部改变内部的值
 是组件更新了state中的数据:dispatch, commit
 模块化编程下,内部模块改变外部模块的值:
 
 
7.对vuex的理解一些使用场景
 多个组件共享数据或者是跨组件传递数据时
 购物车的数据共享, 登录注册
```





### 7. Vue路由: vue-router

#### 1) 一些基本知识

- 跳转/导航路由的2种基本方式
  - 声明式路由:  \<router-link :to="{path: '/xxx'}" replace>xxx</router-link/>
  - 编程式路由: this.$router.push/replace(location)


```js
//<router-link>解析过程
1.生成a标签
2.阻止默认行为,绑定事件监听
3.调用编程式路由
```



- 跳转路由携带参数(数据)的方式
  - params参数
    - 注册的路由路径得有点位: /xxx/:name/:age
    - 跳转时指定参数值:
      - /xxx/abc/12
      - {name: 'xxx', params: {name: 'abc', age: 12}}
  - query参数
    - 位置: url路径中以?开始以&连接key=value的字符形式    /xxx?name=tom&age=12
    - 注册路由时不需要做特别的指定
    - params和query同时使用,params参数要放在query前面.
  - props
    -  props: true, // 只能同名映射params参数
    -  props: {a: 1, b: 'abc'}, // 只能映射非params/query参数
    -  props: route => ({keyword3: route.params.keyword, keyword4: route.query.keyword2, xxx: 12}), //可以指定任何数据都可以
  - meta
    - 通过路由的meta的配置来指定包含n个数据的对象
    - 取数据: this.$route.meta.xxx
- location的2种类型值
  - 字符串 path
  - 对象形式: {name, path, params, query}
  - push(location)
  - \<router-link :to="{}">

####   2) 参数相关问题

- params与path配置能不能同时使用

  不可以: router.push({path: '/xx', params: {name: 'tom'}})

  params只能与name配合: router.push({name: 'xx', params: {name: 'tom'}})   

- 如何配置params参数可传可不传?

  path: '/search/:keyword?',    

  注意: 一旦声明可以不传, 不能传入一个空串的param参数

- 跳转携带的参数, 刷新就丢失了

  如果注册没有指定/:xxx的点位, 而跳转时通过params配置携带的参数数据, 刷新时就会丢失

  因为url中没有携带的参数数据路径

  this.$router.push({name: 'Info', params: {a: 1, b: 2}})

  this.$route.params.a

  /info/1/2

- 路由组件能不能传递props参数?

  可以, 但只是将params/query映射成props传入路由组件的

- **编程式路由跳转到当前路由, 参数不变, 会报出错误?  ==> 在做项目时有没有遇到比较难/奇怪的问题?**

  push(location, () => {}, () => {})

  push(location).then(() => {}, () => {})

  

push(location, () => {})



- 说明情况:

  - 上一个项目这种操作没有这个问题

    - 后面的一个项目(2019.8之后)开始有这个问题, 而且是声明式跳转没有, 只有编程式跳转有

  - 当编程式跳转到当前路由且参数数据不变, 就会出警告错误:

    错误: Avoided redundant navigation to current location ==> 重复跳转当前路由

  - 原因: 

    vue-router在3.1.0版本(2019.8)引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise

    说明文档: https://github.com/vuejs/vue-router/releases?after=v3.3.1

  - 

  - 解决:

    - 办法1: 在每次push时指定回调函数或catch错误

      ```js
      push('/xxx', () => {})   ===> 声明式路由跳转本质就是这样执行的
      push('/xxx').catch()
      ```

    - 办法2: 重写VueRouter原型上的push方法 (比较好)

      - 1). 如果没有指定回调函数, 需要调用原本的push()后catch()来处理错误的promise
      - 2). 如果传入了回调函数, 本身就没问题, 直接调用原本的push()就可以

    ```js
    const originPush = VueRouter.prototype.push
    VueRouter.prototype.push = function (location, onComplete, onAbort) {
      console.log('push()', onComplete, onAbort)
      // 判断如果没有指定回调函数, 通过call调用源函数并使用catch来处理错误
      if (onComplete===undefined && onAbort===undefined) {
        return originPush.call(this, location).catch(() => {})
      } else { // 如果有指定任意回调函数, 通过call调用源push函数处理
        return originPush.call(this, location, onComplete, onAbort)
      }
    }
    
    ```

  - 说明:

    声明式路由跳转之所有没有问题, 是因为默认传入了成功的空回调函数

    

```js
//路由问题:
1.二级路由介绍? 
- 实现:路由对象中添加children属性,属性值是数组,内部是对象
- 子路由path写法: 基本: /home/message  简化:message

2.params参数,及和query参数一起用注意问题?
- params参数需要占位接收;
- 一起使用,params参数需要写在query参数的前面

3.路由配置中props属性的作用
- 组件中使用$route会使对应的组件形成耦合,这些组件只能在相应的url上使用,限制灵活性
- 通过props传递,简化了以往需要计算属性获取params,query参数.可以直接在组件的props属性上声明接收.
```



​    

#### 3) 有点难度, 但很重要的

- 路由懒加载: 

  - () => import('./Home.vue')
  - 组件单独打包, 开始不加载其打包文件, 第一次请求时才会加载 ==> 加载更快, 提高用户体验


```js
使用import  from 这样的方式是同步执行，将所有的路由组件一次性打包在一个大的文件当中
//这样打包之后，打包出来的文件体积比较大，当浏览器在访问这个文件加载的时候，效率不高
//所以我们就想办法将所有的路由组件，分别打包为一个小的文件
//浏览器在访问哪个组件的时候，再去加载哪一个小的文件，效率就会提升
//这个过程就是我们所说的路由懒加载

路由对象中的component属性组件名称,函数

const Home = ()=>import('@/pages/Home')
或
{
    name:'Home',
    component:()=>import('@/pages/Home')
    //component:Home
}
```



- 缓存路由组件

  ```vue
  <keep-alive>
      <router-view/>
  </keep-alive>
  ```

​			路由离开时不销毁, 路由回来时不用重新创建  ==> 利用缓存, 切换路由更快

​			再利用上prefetch实现预获取, 用户体验更佳

- 动态添加路由

  - router.addRoutes(routes)
  - 在异步确定用户的权限路由后, 需要动态添加到路由器


```js

```



- 路由守卫与权限校验

  - router.beforeEach()注册全局前置守卫
  - 统一对用户权限进行一系列的校验处理
- history与hash路由的区别和原理

```js
- localhost:4000/xxx ==>  localhost:4000/xxx  ==> 后台没有对应的资源 ==> 404
  - 当请求找不到对应的资源时 ==> 返回index.html  ==>  js ==> 解析路径(当成前台路由路径解析)
- localhost:4000/#/xxx  > localhost:4000 => index.html  ==> js ==> 解析路径(当成前台路由路径解析)
  - 区别:
    - history:  路由路径不#, 刷新会携带路由路径, 默认会出404问题, 需要配置返回首页
      - 404: 
        - history有: 刷新请求时会携带前台路由路径, 没有对应的资源返回
        - hash没有: 刷新请求时不会携带#路由路径
      - 解决: 
        - 开发环境: 如果是脚手架项目本身就配置好 
          ==> webpack ==> devServer: {historyApiFallback : true}
          当使用 HTML5 History API 时, 所有的 404 请求都会响应 index.html 的内容
      - 生产环境打包运行:
        - 配置nginx
              location / {
                try_files $uri $uri/ /index.html; # 所有404的请求都返回index页面
              }
    - hash: 路由路径带#, 刷新不会携带路由路径, 请求的总是根路径, 返回首页, 没有404问题
 
        
- 原理:
- history: 内部利用的是history对象的pushState()和replaceState() (H5新语法)
- hash: 内部利用的是location对象的hash语法
    - 写hash路径
    - 读hash路径
    - 监视hash路径的变化

```



如何让路由跳转后, 滚动条自动停留到起始位置?

```js
new VueRouter({ // 配置对象
  // ...
  scrollBehavior (to, from, savedPosition) {
    // 指定路由跳转后滚条的坐标
    return { x: 0, y: 0 }
  }
})


//返回上个页面定位到底上次访问的位置
scrollBehavior(to,from,savedPosition){
    if(savedPosition){
        return savedPosition;
    }else{
        return {x:0, y:0}
    } 
}

//完善 上面的代码.不是每个页面都有这个需求 搭配使用meta属性
scrollBehaviour(to,from,savedPosition){
    if(savedPosition && to.meta===true){
        return savedPosition
    }else{
        return {x:0,y:0}
    }
}
```

如何实现登陆后, 自动跳转到前面要访问的路由界面

在全局前置守卫中, 强制跳转到登陆页面时携带目标路径的redirect参数

```js
if (userInfo.name) {
  next()
} else {
  // 如果还没有登陆, 强制跳转到login
  next('/login?redirect='+to.path)  // 携带目标路径的参数数据
}
```



在登陆成功后, 跳转到redirect参数的路由路径上

```js
await this.$store.dispatch('login', {mobile, password})
// 成功了, 跳转到redirect路由 或 首页
const redirect = this.$route.query.redirect
this.$router.replace(redirect || '/')
```



####   4) 路由导航守卫的理解和使用

##### 是什么?

```js
导航守卫是vue-router提供的下面2个方面的功能

- 监视路由跳转  -->回调函数
- 控制路由跳转  -->  放行/不放行/强制跳转到指定位置    next()
```



##### 应用

```js
- 在跳转到界面前, 进行用户权限检查限制(如是否已登陆/是否有访问路由权限)
- 在跳转到登陆界面前, 判断用户没有登陆才显示
```



##### 导航守卫分类

1.**全局守卫: 针对任意路由跳转**

全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // ...
})
```

全局后置守卫

router.afterEach((to, from) => {})



2.**路由守卫**

前置守卫

```js
{
	path: '/foo',
	component: Foo,
	beforeEnter: (to, from, next) => {}
},
    
{
	path: '/xxx',
	component: Foo,
  	beforeEnter: (to, from, next) => {}
}
```



3.**组件守卫: 只针对当前组件的路由跳转**

进入

```js
beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
      // 不！能！获取组件实例 `this`
      // 因为当守卫执行前，组件实例还没被创建
    
    next(vm => {
    	// 通过 `vm` 访问组件实例
    	})
  },
 
```



更新

beforeRouteUpdate (to, from, next) {}

离开

beforeRouteLeave (to, from, next) {}

```js
//面试题

1.vuerouter路由跳转传参的方式,路由懒加载实现
传参方式4种:
params参数: 路由注册时需占位接收(冒号+变量形式);跳转传参时路径传参和对象传参两种,注意事项是编程路由导航种params参数只能搭配命名路由name
query参数: 路由注册无需对query声明接收;跳转传参是对象形式;路径形式是?后以&连接的key=value形式; 注意:同时接收params,query,要先声明params参数.

props属性: 3种形式:布尔值->映射params参数,静态数据->只能映射非params和query参数,函数->可传递任意数据.
meta属性: 通过路由的meta的配置来指定包含n个数据的对象, 通过this.$route.meta来访问相应属性

路由懒加载: 代码分别打包,函数延迟执行

2.vue-router中的全局守卫,路由守卫和组件守卫.
vue-router中的3种导航守卫,有监视控制路由跳转的功能,应用在页面跳转的权限和登录页面是否显示上.
全局守卫: 针对任意路由跳转,全局前置守卫beforeEach 全局后置守卫afterEach
路由守卫: 在路由配置上直接定义 beforeEnter 守卫,使用方法和全局前置守卫相同.
组件守卫: 只针对当前组件的路由跳转.beforeRouteEnter beforeRouteUpdate beforeRouteLeave. beforeRouterEnter不能访问this,组件还未创建.使用next函数传入当前组件实例来解决.


3.vue-router的使用和理解
vue-router是vue的一个插件库,是官方路由管理器,简化构建单页面应用.

使用:
引入和暴露对象
路由传参
路由懒加载
缓存路由组件
动态添加路由
路由守卫权限校验
滚动条位置
导航守卫
路由模式
默认显示页面/404


4.vue-router跳转的原理/前端路由的实现/
- history: 内部利用的是history对象的pushState()和replaceState() (H5新语法)
- hash: 内部利用的是location对象的hash语法
    - 写hash路径
    - 读hash路径
    - 监视hash路径的变化

5.hash路由和history路由实现原理

6.vue种$route和$router的区别,query和params的区别

7.vue路由模式的区别

8.vue种路由传参的方式

```



### HashRouter 和 HistoryRouter的区别和原理？

（1）在url显示： hash有#很Low ； history 无#好看

（2）回车刷新： hash 可以加载到hash值对应页面 ； history一般就是404掉了

（3）支持版本： hash支持低版本浏览器和IE浏览器 ； historyHTML5新推出的API

hash模式背后的原理是onhashchange事件,可以在window对象上监听这个事件:

```js
		window.onhashchange = function(event){
		  console.log(event.oldURL, event.newURL);
		  let hash = location.hash.slice(1);
		  document.body.style.color = hash;
		}
```

```scss
window.history 提供了两类API，一类是go(), back(), forward()这种定位到某个浏览历史的记录上；
另外一类是pushState(), replaceState()这种，是操作历史记录的接口（添加和替换历史记录栈）。
history mode就是使用pushState()和replaceState()来实现前端路由，通过这两个方法改变url，页面不会重新刷新。
使用这两个方法更改url后，会触发popstate事件，监听popstate事件，实现前端路由。
window.addEventListener('popstate', function(e) { alert('url 更新') });
当我们访问同域下不同的url时，就能触发popstate事件
```





## 8. Vue 前台项目问题

### 路由跳转与传参相关问题

**面试问题1: 指定params参数时可不可以用path和params配置的组合?**

​	不可以用path和params配置的组合, 只能用name和params配置的组合

​	query配置可以与path或name进行组合使用

**面试问题2: 如何指定params参数可传可不传?**

​	`path: '/search/:keyword?'`

**面试问题3: 如果指定name与params配置, 但params中数据是一个"", 无法跳转**

​	解决1: 不指定params

​	解决2: 指定params参数值为undefined

**面试问题4: 路由组件能不能传递props数据?**

​	可以: 可以将query或且params参数映射成props传递给路由组件对象

```js
//在routes中配置
props: route=>({keyword1:route.params.keyword, keyword2: route.query.keyword })
```

**面试问题5(非常重要): 编程式路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误**

​	面试问题: 在做项目时有没有遇到比较难的问题?(可做回答)

回答步骤：

1. **我的问题**: 我在上一个项目时没有问题, 后面再做一个新的项目时就有了问题

2. **原因分析**: vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise

3. **解决办法**:解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误

   ​				解决2: 修正Vue原型上的push和replace方法 (优秀)

   ```js
   // 缓存原型上的push方法
   const originPush = VueRouter.prototype.push
   VueRouter.prototype.push = function (location, onComplete, onAbort) {
     console.log('push()', location, onComplete, onAbort)
     // this是路由器对象 $router
     // 如果调用push, 传递了成功或者失败的回调函数
     if (onComplete || onAbort) {
       // 让原来的push方法进行处理
       originPush.call(this, location, onComplete, onAbort) // 不用返回, 因为执行的结果返回是undfined
     } else { // 如果调用push, 没传递了成功或者失败的回调函数, 可能会抛出失败的promise, 需要catch一下
       return originPush.call(this, location).catch(() => {
         console.log('catch error')
       })   // 必须返回产生的promise对象
     }
   }
   ```

### **解决在二层及以上的路由路径上刷新, 丢失reset样式的问题**

- 因为history模式的缘故

  页面中引入reset: `<link rel="stylesheet" href="./css/reset.css"> `

- 解决： 

  `<link rel="stylesheet" href="/css/reset.css">`



### 测试调用接口请求函数（跨域问题）

1. 出404的错误

   ​	 axios请求配置的地址: /api/product/getBaseCategoryList'

   ​     当前发请求所在的地址:　http://localhost:8080/

   ​	最终ajax请求的地址: http://localhost:8080/api/product/getBaseCategoryList (没人处理)

2. 解决办法1

   ​	配置baseURL: http://182.92.128.115/api   ==> 成功的前提是后台允许ajax跨域

3. 使用代理服务器转发到目标接口地址 (使用代理解决ajax跨域)

   ​	配置baseURL: /api

   ​	配置代理: vue.config.js中

   ```js
   devServer: {
     proxy: {
       // 配置代理
       "/api": {
         // 只处理以/api开头的请求
         target: "http://182.92.128.115", // 转发的目标地址
         changeOrigin: true, // 支持跨域
       }
     }
   }
   ```

#### vuex的基本使用

- store对象: state, mutations, actions, getters配置store对象: 在vm中配置

#### vuex多模块编程

- 当vuex管理的数据个数很多时使用
- 好处: 每个功能模块的数据单独管理, 更方便, 更有扩展性

#### vuex多模块编程的总state结构

- 要根据具体分出的模块进行调用

```js
{
    user: {
        userInfo: {}
    },
    home: {
        baseCategoryList: []
    }
}
```

#### vuex与api交互

- 异步action: 调用api接口请求函数 ==> 成功之后commit ==> 调用mutation ==> 更新状态数据

### 利用lodash进行函数节流处理

**问题: mouseenter事件频繁触发会导致分类列表更新卡的现象**

- 解决: 使用lodash的throttle函数进行节流处理, 限制更新的次数

#### 优化减小打包文件: 对lodash库实现按需引入 

```js
import _ from 'lodash'  // 引入整体lodash  ==> 打包了没用的工具函数, 打包文件变大
import throttle from 'lodash/throttle'  // 只引入我需要的工具函数   打包文件减少1.4M
```

#### 解决快速移出后可能显示第一个分类的子分类列表的bug

    原因：在最后一个mouseenter事件延迟0.3m才执行更新的回调函数
        在这个0.3s之内可能已经移出去了
    解决: 给currentIndex设计了3个值:
            -2: 在整个大div外面   
            -1: 进入了包含所有分类的大div上
            >=0: 在某个分类上
        在准备更新currentIndex之前, 需要判断currentIndex当前不能为-2





### 3级分类列表卡顿及解决

商品分类鼠标快速移入移出, 浏览器出现卡顿现象. 使用防抖和节流处理.  使用库lodash

lodash是已经存在的依赖包, 可以通过`search_modules`搜索确认

使用lodash时, 只引入所需的函数/功能



#### 函数防抖/节流

##### 函数防抖的应用场景:

连续的事件,只需触发一次的回调的场景有:

* 搜索框搜索输入.只需要用户最后一次输入完,再发请求
* 手机号,邮箱验证码输入监测
* 窗口大小Resize. 只需要窗口调整完成后,计算窗口大小.防止重复渲染

##### 函数节流的应用场景:

间隔一段时间执行一次回调的场景有:

* 滚动加载,加载更多或滚动到底部监听
* 谷歌搜索框,搜索联想功能
* 高频点击提交,表单重复提交.



#### throttle

两种引入形式. 及参数的具体含义

按需引入lodash减少打包体积

解决使用lodash节流后，快速移出后，可能还会显示某个子项
	{ 'trailing': true,leading:false}

'trailing': 是否在时间间隔之后执行函数
leading： 是否在时间间隔之前执行函数

```js
import _ from 'lodash'

methods: {
  moveInItem: _.throttle(function(index) {
    this.currentIndex = index
    console.log(index)
  }, 20, { 'trailing': false})
}

// 
import throttle from 'lodash/throttle'

methods: {
  moveInItem: throttle(function(index) {
    this.currentIndex = index
    console.log(index)
  }, 20, { 'trailing': false})
}
```





### 页面跳转实现的3种方式及选择

#### 实现

页面三级分类列表 和搜索框 跳转, 通过3种方式来跳转

* 每个a标签链接更改为`router-link`
* 将`router-link`改为编程式导航`$router.push({name:'search', query:{}})`
* 使用事件委托 + 自定义属性 来代替多个`$router.push`



#### 存在的问题

当`<a>`标签改为`<router-link>`后, 会出现卡顿现象

##### 原因

渲染组件标签时候, 其本质是通过和标签名绑定好的构造函数,实例化了一个对象, 称作是组件对象.

多层vfor循环中多个\<router-link>标签产生了多个组件, 内存占用大, 卡顿

#### 解决1-编程式导航代替声明式导航

使用编程式导航代替声明式导航

```html
<div
							class="item"
							:class="{ item_on: currentIndex === index }"
							v-for="(c1, index) in categoryListSumIs15"
							v-bind:key="c1.cat_id"
							@mouseenter="moveInItem(index)"
						>
							<h3>
								<!-- <a href="">{{ c1.cat_name }}</a> -->
								<!-- <router-link
									:to="{
										name: 'search',
										query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
									}"
									>{{ c1.cat_name }}</router-link
								> -->

								<a
									href="javascript:;"
									@click="
										$router.push({
											name: 'search',
											query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
										})
									"
									>{{ c1.cat_name }}</a
								>
							</h3>
```





#### 解决2 - 事件委托

每个a标签都添加了点击事件, 内存中会定义很多个函数,内存占用也是比较大,效率虽然比声明式导航大,但是不够好. 使用<u>事件委托</u>来代替



每个分类项都添加事件，事件的回调函数很多，效率也不好
在共同的祖先级元素添加事件监听
		问题：怎么知道点击的是不是a标签
		问题：假设你点击的就是a标签，怎么知道点击的是一级还是二级还是三级
		问题：参数怎么携带，要携带携带哪些个的参数



利用在a标签中添加自定义属性来解决以上问题

##### 自定义属性(data-)

```js
//为html标签添加自定义属性,结构是data-xxx="..."
标签的data-开头的属性，叫做自定义属性,通过它我们可以给标签添加上自定义的属性.
获取:通过事件属性 event.target.dataset来获取这个属性.

注意:Vue会把自定义属性的大写变为小写.

```









### Mock接口数据

    1.新建文件夹 src/mock 准备数据新建文件xxx.json  floor.json banner.json
    2.安装mock模块 yarn add mockjs
    3.创建src/mock/mockServer.js
    	Mock.mock('/mock/banner',{code:200,data:banner}) //第一个参数，代表我们以后请求的路径，第二个参数代表返回的数据
    4.在main.js中引入 import '@/mock/mockServer'
    5.ajax文件中,新建mockAjax.js文件, 复制ajax.js中的内容, 但是基础路径改为/mock  // 不会向后台发送数据

### 使用swiper

- 创建并配置swiper对象: 必须在列表显示显示之后创建 ===> 在mounted()中创建

#### 解决多个swiper效果冲突的问题

​	问题: 针对某个swiper界面创建一个swiper对象, 它会影响了其它界面的swiper界面

​	原因: new Swiper ('.swiper-container'), 类名选择器匹配了页面中所有的swiper界面, 都产生了效果

​	解决: 使用ref技术: 通过ref标识swiper的根div, new Swiper (this.$refs.swiper)

#### 解决swiper动态页面轮播的bug

​	问题: 异步动态获取数据 + 直接在mounted中创建Swiper对象 ===> 没有轮播效果

​	原因: swiper对象创建得太早

​	解决: 使swiper对象在列表数据显示之后创建

​			**办法1**: 使用延迟定时器延迟一定的时间才创建 ==> 不合适, 因为请求获取的时间是不定的

​			**办法2**: watch + $nextTick()

​					通过watch能知道banners有数据了(变化了)

​					通过 $nextTick(callback)知道界面也更新了，那我们就可以在callback中创建swiper对象

**理解nextTick()**

- nextTick()需要在数据更新之后界面更新前我们调用

- 指定的回调函数在这次数据更新导致的界面更新完成后立即执行

#### 解决Floor组件中轮播有问题的bug

问题: banners的轮播可以, 但2个Floor的轮播都没有效果

原因: (在v-for以后轮播组件已经有数据了，不是从空数组变为有数据，所以watch不调用)

​	 	基础理解: 给组件标签传入的属性值是空数组/undefined, 组件对象会创建，如果是通过v-for遍历一个空数组或undefined来产生多个标签, 组件对象不会创建

​		watch默认: 初始创建显示不会执行, 只有在数据变化后才会执行

解决:

​		**办法1**: mounted() + watch回调

​					mounted()中: 判断如果已经有数据了, 立即创建swiper对象

​					watch回调: 判断如果有数据, 延迟创建swiper对象

​		**办法2**: watch

​					给watch指定2个配置

​					handler: 判断如果有数据, 延迟创建swiper对象

​					immediate: 指定为true, 表示在初始显示之前就会调用一次









### 响应式数据对象

#### **添加新属性**

错误方式: 

​		直接添加: this.options.trademark = 'xxx'  ==> 不会自动更新界面

原因: 

​		vue内部没有对添加的属性进行劫持操作(没有对应的setter监视)

正确方式:

​		vm.$set( target, key, value )

​		Vue.set( target, key, value )

​		为响应式对象添加一个属性，确保新属性也是响应式的，并且能够触发视图更新

#### 删除属性

错误方式: 

​		直接添加: delete this.options.trademark  ==> 不会自动更新界面

原因: 

​		vue内部给响应式属性添加的setter, 只能监视属性值的改变, 不能监视属性的删除

正确方式:

​		vm.$delete( target, key )

​		Vue.delete( target, key )

​		删除属性, 同时更新界面

### 自定义分页组件: Pagination

**自定义通用型/复用型组件的基本步骤**

- 实现静态组件: 模板/样式写好

- 设计从外部接收的数据: props

- 设计内部包含的数据: data

- 设计基于props和data的计算属性数据: computed

- 根据props和data数据和computed进行动态显示

  **v-for的优先级高于v-if: 先执行v-for的遍历, 每遍历一个再进行v-if的判断 面试题**

- 更新数据, 更新界面

  用户操作组件界面元素时, 更新当前组件的data数据

  子组件更新data数据的同时, 可能需要通知父组件做一些更新父组件数据的操作(可能异步/同步)

  父组件更新data数据的同时, 可能也要去更新子组件的数据



### 可说性强的点



### 1) 三级分类列表

- 使用编程式导航代替声明式导航

- router-link太多 ==> 创建很多组件对象 ==> 占用内存大, 效率低

  ```js
  1.使用声明式导航 产生的组件过多,内存中组件对象多,卡顿
  2.使用编程式导航代替声明式 click事件. 每个a标签上都添加了点击事件,内存中有很多函数,内存占用大.
  3.使用事件委托
   -如何获取发生事件的元素和属性:event.target 自定义属性和元素的dataset属性
  4.对mouseEnter事件的高频进行节流处理: lodash的节流函数throttle函数+按需引入
  
  import _ from 'lodash'
  import throttle from 'lodash/throttle'
  ```

  

- 优化事件处理效率

  - 利用事件委托: event.target
  - 理解事件委托与事件冒泡

- 如何携带点击的分类的数据?

  - event.target得到a标签  获取发生事件的元素
  - 利用自定义的data标签属性来保存分类信息

- 对mouseEnter高频事件进行节流处理

  - 使用lodash的throttle进行节流处理
  - 对lodash库实现按需引入



```html
<div class="all-sort-list2" @click="toSearch">
  <div
       class="item"
       :class="{ item_on: currentIndex === index }"
       v-for="(c1, index) in categoryListSumIs15"
       v-bind:key="c1.cat_id"
       @mouseenter="moveInItem(index)"
       >
    <h3>
      <a
         href="javascript:;"
         :data-c1Id="c1.cat_id"
         :data-cName="c1.cat_name"
         >{{ c1.cat_name }}</a
        >
      <!-- <router-link
:to="{
name: 'search',
query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
}"
>{{ c1.cat_name }}</router-link
> -->

      <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c1Id: c1.cat_id, c1Name: c1.cat_name },
})
"
>{{ c1.cat_name }}</a
> -->
    </h3>
    <div class="item-list clearfix">
      <div class="subitem">
        <dl
            class="fore"
            v-for="(c2, index) in c1.children"
            :key="c2.cat_id"
            >
          <dt>
            <a
               href="javascript:;"
               :data-c2Id="c2.cat_id"
               :data-cName="c2.cat_name"
               >{{ c2.cat_name }}</a
              >
            <!-- <router-link
:to="{
name: 'search',
query: { c2Id: c2.cat_id, c2Name: c2.cat_name },
}"
>{{ c2.cat_name }}</router-link
> -->

            <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c2Id: c2.cat_id, c2Name: c2.cat_name },
})
"
>{{ c2.cat_name }}
</a> -->
          </dt>
          <dd>
            <em v-for="(c3, index) in c2.children" :key="c3.cat_id">
              <a
                 href="javascript:;"
                 :data-c3Id="c3.cat_id"
                 :data-cName="c3.cat_name"
                 >{{ c3.cat_name }}</a
                >
              <!-- <router-link
:to="{
name: 'search',
query: { c3Id: c3.cat_id, c3Name: c3.cat_name },
}"
>{{ c3.cat_name }}</router-link
> -->
              <!-- <a
href="javascript:;"
@click="
$router.push({
name: 'search',
query: { c3Id: c3.cat_id, c3Name: c3.cat_name },
})
"
>{{ c3.cat_name }}</a
> -->
            </em>
          </dd>
        </dl>
      </div>
    </div>
  </div>
</div>
```



```javascript
		// 事件委派 函数
		toSearch(event) {
			// event是什么 每一次触发事件时,系统(浏览器内核)都会把这一次触发事件相关的所有信息,封装为一个对象. 在浏览器调用回调函数的时候, 自动传递给回调函数的第一个形参
			// 回调函数 自己定义 自己没调用 最后执行了.  所以toSearch在html中可以不用括号 vue中的回调参数顺序可以改变,但原生的不能改
			// event 是浏览器调用函数传递过来的时间对象, 代表你传递的$event, 只能在模板里出现

			let targetNode = event.target; // 获取目标元素
			let data = targetNode.dataset;
			console.log("data", data);
			let { c1id, c2id, c3id, cname } = data;

			if (cname) {
				// cname存在, 证明点击的就是a标签
				let location = {
					name: "search",
				};
				let query = {
					cName: cname,
				};

				// 确定是几级的ID
				if (c1id) {
					query.c1Id = c1id;
				} else if (c2id) {
					query.c2Id = c2id;
				} else {
					query.c3Id = c3id;
				}

				location.query = query;
				// 跳转之前, 要合并原来过来时的params参数
				if (this.$route.params) {
					location.params = this.$route.params
				}

				// 如果是从home页跳search页, 就push
				// 如果是从search页 跳 search 页, 就replace
				if (this.$route.path !== '/home') {
					this.$route.replace(location)
				} else {
					this.$router.push(location);
				}
				
			}
		},

```





### 2) 商品搜索列表

- 准备各种搜索条件
  - category1Id: '', // 一级分类ID
  - category2Id: '', // 二级分类ID
  - category3Id: '', // 三级分类ID
  - categoryName: '', // 分类名称
  - keyword: '', // 关键字
  - trademark: '', // 品牌  "ID:品牌名称"
  - props: [], // 商品属性的数组: ["属性ID:属性值:属性名"] 示例: ["2:6.0～6.24英寸:屏幕尺寸"]
  - order: '1:desc', // 排序方式  1: 综合,2: 价格 asc: 升序,desc: 降序  示例: "1:desc"
  - pageNo: 1, // 当前页码
  - pageSize: 10, // 每页数量
- 添加搜索条件
- 删除搜索条件
  - 删除分类或关键字条件后, 地址栏还有条件参数?
  - 删除关键字条件, 输入框中的关键字没有同步删除?
- 排序处理
  - 根据综合/价格/销量/评价排序
  - 升序/降序
  - 搞清条件数据结构
    - orderFlag:orderType
    - orderFlag: 1: 综合,2: 价格, 3: 销量, 4: 评价
    - orderType:  asc: 升序,desc: 降序

```js
//准备各种搜索条件
1.初始化搜索条件: data中的数据:搜索条件对象, dispatch只能接收一个参数
2.获取条件对象中的各个数据:
 获取对象数据: 从路由对象$route中获取query参数(点击的分类名称及id)和params参数(输入的关键字)
2.1优化条件对象-删除空属性: 对条件对象使用扩展运算符,更新.对象循环遍历Object.keys(obj),删除空属性
2.2处理对象的声明周期, 请求数据的声明周期: beforeMounte, mounted

//删除分类或关键字条件后, 地址栏还有条件参数
1.在搜索页重新输入关键字或者点击类别不会再发送请求，因为mounted只会执行一次，需要监视路由变化
2.解决: 使用watch监视$route,更新参数,重新发请求.

//删除关键字条件, 输入框中的关键字没有同步删除
1.使用自定义事件通知header组件清空关键字
2.重新发送请求this.searchParams.pageNo = 1  this.$router.replace({name:'search', query:this.$roue.query})

//商品排序处理(order:'2:desc')
0.data中初始化数据: order:'2:desc'
1.判断用户点击的是否是原来的排序标志sortFlag是否和原来一样,一样就更改排序类型sortType(asc,desc). 不一样就更改排序标志,排序类型默认.
2.更新页码,重新发送请求(this.getSearchInfo())
3.其他:阿里图标字体库的使用 ;计算属性的引入获取排序标志和类型
```







### 详情页

```js
//图片实现放大镜效果
组件结构:详情页组件, 缩略图组件imgList, zoom大图组件

//缩略图组件imgList
1.引入swiper轮播图组件
2.处理思路: 使用watch监视props属性图片数组imgList,一旦有变化,实例化swiper.但是没有效果,因为页面还没有完全形成,所以需要等页面完全形成后再去实例化swiper,使用$nextTick(最近一次页面更新之后调用)
watch:{
    imgList:{
        immediate:true,
        handler(newValue,oldValue){
            this.$nextTick(()=>{
                new Swiper(this.$refs.imgSwiper,{
                    slidesPerView:4, //一个视图放几张
                    slidePerGroup:4, //切换一组,几张图片
                    navigation:{
                        nextEl:".swiper-button-next",
                        prevEl:".swiper-button-prev"
                    }
                })
            })
        }
    }
}
3.点击的当前图片添加边框
动态类判断当前索引和点击索引是否相同,初始化index数据0,点击后将当前图片索引赋值给初始index. 
4.其他: 缩略图列表和展示图列表同步,使用全局事件总线传递当前图片的index值 this.$bus.$emit('changeDefaultIndex',index)

//右侧大图组件
1.缩略图组件给大图组件传递的index,在mounted中指定全局事件总线接收 //全局事件总线接收,$on后是方法
mounted(){this.$bus.$on('changeDefaultIndex',this.changeDefaultIndex)}
methods:{changeDefaultIndex(index){this.defaultIndex=index}}
1.1 beforeDestroy解绑全局事件总线

2.图片展现问题
使用<img :src="imgList[0].imgUrl"/> 报错:can't read property of undefined
使用<img :src="defaultImg.imgUrl"/> 通过计算属性得到return this.imgList[this.defaultIndex]||[] 来解决


3.蒙版+右侧大图
<div class="spec-preview">
    <img :src="default.imgUrl"/>
    <div class="event" @mousemove="move"></div>
    <div class="big">
        <img :src="defaultImg.imgUrl" ref="bigImg">
    </div>
    <div class="mask" ref="mask"></div>
</div>

move(event){
    //鼠标动,蒙版动,转化为根据鼠标位置求蒙版位置
    //event.clientX 视口 event.pageX页面 event.offsetX元素
    let mask = this.$refs.mask;
    let bigImg = this.$refs.bigImg;
    
    //获取鼠标坐标
    let mouseX = event.offsetX;
    let mouseY = event.offsetY;
    //根据鼠标位置和蒙版宽度计算蒙版位置
    let maskX = mouseX - mask.offsetWidth/2;
    let maskY = mouseY - mask.offsetHeight/2; //offsetWidth: 目标元素的宽度(加边框) 
    
    //设置蒙版位置前需要边界限定
    if(maskX<0){
        maskX=0;
    }else if(maskX>mask.offsetWidth){//因为整体宽度是蒙版的两倍
        maskX = mask.offsetWidth;
    } 
    if(maskY<0){
        maskY=0;
    }else if(maskY>mask.offsetHeight){
        maskY = mask.offsetHeight;
    }
    
    //设置蒙版的位置让蒙版活动
    mask.style.left = maskX + 'px';
    mask.style.top = maskY + 'px';
    
    //蒙版动,大图动  大图是蒙版移动反方向的2倍
    bigImg.style.left = -2*maskX+'px';
    bigImg.style.top = -2*maskY+'px';   
}

//点击切换销售属性值的选中状态
1.排它实现: 第一步,让所有成员变为同一种状态;第二步,让当前点击的这个成员变为另一种状态

//购买数量输入框
1.blur失去焦点还是选择change事件,change事件:触发条件时当前数据和原来的数据不一样
2.使用三元表达式处理负数,非数值等. //这里需要使用大于等于,否则会失效
<input v-model="skuNum" @change="$event.target.value>=1?(skuNum=$event.target.value*1):(skuNum=1)"/>

//加入购物车按钮-需要发请求    
.加入购物车 需要发请求给后台让后台存储信息,请求成功后返回信息,根据这个信息再去跳转.否则,如果添加失败,而又跳转到下个页面,救出问题.
async addShopCart(){
    try{
        await this.$store.dispatch('addOrUpdateShopCart',{skuId:this.skuId,skuNum:this.skuNum});
        alert('添加购物车信息成功');
        sessionStorage.setItem('SKUINFO_KEY',JSON.stringify(this.skuInfo));
        this.$router.poush('/addcartsuccess?skuNum='+this.skuNum)
    }catch(error){
        alert(error.message)
    }
}

```



### 购物车成功页面

```js
//请求需要携带用户临时身份标识,才能获取到数据

//用户临时标识
1.创建保存
 浏览器端创建,每次请求需要携带;
 应用一打开就创建保存在localStorage
 在state中也去保存一份,可以更快获取
2.使用
 请求拦截器每个请求都带上
3.做法
 工具函数去创建保存uuid
 在state中调用这个函数
 ajax发送请求,所有请求头中携带这个标识

//utils/userabout.js
import{v4 as uuid} from 'uuid';
export function getUserTempId(){
    let userTempId = localStorage.getItem('USERTEMPID_KEY');
    if(!userTempId){
        userTempId = uuidv4();
        localStorage.setItem('USERTEMPID_KEY', userTempId)
    }
    return userTempId;
}

//store/user.js
import{getUserTempId} from '@/utils/userabout';



//数据存储到data,方便后期使用

beforeMount(){
    this.skuNum = this.$route.query.skuNum;
    this.skuInfo = JSON.parse(sessionStorage.getItem('SKUINFO_KEY'))
}



```



### 购物车页面

```js
修改数量,修改选中状态,删除商品都需要发请求,请求成功后再请求更新页面数据

//修改购物车数量
<input autocomplete="off" type="text" :value="cart.skuNum" minnum='1' @change="changeCartNum(cart,$event.target.value*1, false)"
@click="changeCartNum(cart,-1,true)"
@click="changeCartNum(cart,1,true)"
async changeCartNum(cart,disNum,flag){
    //获取本身的数量
    let originNum = cart.skuNum;
    if(flag){
        if(originNum+disNum<1){disNum = 1-originNum}
    }else{
        if(disNum<1){
            disNum=1-originNum;  //disNum是变化的值
        }else{
            disNum = disNum - originNum;
        }
    }
    try{
        //发请求修改数量
    	await this.$store.dispatch('addOrUpdateShopCart',{skuId:cart.skuId,skuNum:disNum});
        alert('更改成功');
        //发请求重新获取购物车列表数据
        this.getshopCartInfo();
    }catch(error){
        alert(error.message);
    }
}

//修改购物车的全选状态
利用input标签:checked属性选中与否来决定配置属性isChecked是0还是1

  //使用计算属性读取和更新全选状态
  isCheckAll:{
      get(){
          return this.cartInfoList.every((item)=>{item.isChecked})
      },
      async set(val){
          try{
              const result = await this.$store.dispatch('updateCartIscheckAll', val?1:0);
              alert('修改成功')
              this.getshopCartInfo();
          }catch(error){
              alert(error.message)
          }
      }
  }

//vuex中全选 使用promise.all处理
async updateCartIscheckAll({commit,dispatch,getters}, isChecked){
    let promises=[];
    getters.cartInfo.cartInfoList.forEach(item=>{
        if(item.isChecked===isChecked) return;
        let promise = dispatch('updateCartIscheck', {skuId:item.skuId, isChecked})
        promises.push(promise);
    })
    return Promise.all(promises)
}

//页面数据计算

//统计已选的数量
computed:{
    checkNum(){
        return this.cartInfoList.reduce((prev,item)=>{
            if(item.isChecked){
                prev += item.skuNum;
            }
            return prev;
        },0)
    },
    
    //统计总价
    allMoney(){
        return this.cartInfoList.reduce((prev,item)=>{
            if(item.isChecked){
                prev += item.skuNum*item.skuPrice;
            }
            return prev;
        },0)
    }
}

//删除购物车数据

```



### 注册页面

```js
//点击注册按钮的逻辑
根据请求成功还是失败有后续操作（所以action里面函数要有return，来让vue当中判断成功和失败）
如果请求验证码成功，我们需要把验证码自动添加到页面上，修改data的code为state里面获取的
如果请求验证码失败，提示
async register(){
    //点击完成注册首先对所有的表单项做整体验证，验证通过返回的true,没通过返回的false
    const success = await this.$validator.validateAll();
    if(success){
        //发请求把收集的数据，作为参数传递给后台存储数据库
        let {phone, password, code} = this;
        try{
            await this.$store.dispatch('userRegister',{phone,password,code});
            alert('注册成功');
            this.$router.push('/login')
        }catch(error){
            alert(error.message)
        }
    }
}

main.js中  import '@/utils/validate'  //引入vee-validate相关配置

utils/validate.js
import Vue from 'vue'
import VeeValidate from 'vee-validate'
import zh_CN from 'vee-validate/dist/locale/zh_CN' // 引入中文message
Vue.use(VeeValidate)
```





### 登录页面

```js
//登录按钮回调

登录跳转前,进入到全局路由前置守卫中进行判断.
先判断是否又token:
有->访问的依然是login页面->跳转到首页
有->访问其他页面->再判断是否已经获取用户信息
用户信息有->放行
用户信息没有->dispatch一下请求,获取用户信息(保存到vuex中)


methods:{
    aysnc login(){
        let{phone,password}=this;
        if(phone&password){
            try{
                await this.$store.dispatch('userLogin',{phone,password});
                //登录成功后,跳转到之前前往的页面
                let targetPath = this.$route.query.redirect||'/';
                this.$route.push(targetPath);
            }catch(error){
                alert('登录失败')
            }
        }
    }
}



//路由器对象中配置全局路由守卫
const router = new VueRouter({
    routes,
    scrollBehavior(to,from,savedPosition){
        return {x:0,y:0}
    }
})
//注册全局前置导航守卫，用来对token校验（根据token获取用户信息）
router.beforeEach(async(to,from,next)=>{
    //第一步：守卫拦截住，先去获取用户的token和用户的信息
    let token = store.state.user.token;
    let userInfo = store.state.user.userInfo.name;
    
    if(token){
        //如果token存在,代表用户登录过
        if(to.path==='/login'){
            next('/')
        }else{
            //如果用户已经登录,但跳转的不再是登录页,需要查看用户信息获取了没有
            if(userInfo){
                //如果已经获取
                next()
            }else{
                //用户已经登录,但还没获取用户信息,需要请求用户信息
                try{
                    await store.dispath('getUserInfo') //用户根据token获取信息
                    next();
                }catch(error){
                    //根据token获取用户信息失败，代表token可能过期
          			//把用户的过期token给清理掉，重新跳转到登录页
                    store.dispatch('clearToekn');
                    next('/login')
                }
            }
        }
    }else{
        //用户没有登录,如果用户访问的是 交易相关  支付相关 个人中心相关，那么跳转到登录页面
        let accessPath=['/trade','/center','/pay'];
        let targetPaht = to.path;
        let result = accessPath.some((item)=>{item === targetPath})
        if(result){
            next('/login?redirect='+targetPath)
        }else{
            next();
        }
    }
})


//vuex中 user.js
const actions={
    //请求登录
    async userLogin({commit}, userInfo){
        const reuslt = await reqUserLogin(userInfo);
        if(result.code === 200){
            commit('RECEIVE_TOKEN', result.data.token);
            //自动登录就是需要保存token到localStorage
      	    //保证第一次登录完成，后期的登录都可以免了
            locationStorage.setItem('TOKEN_KEY',result.data.token)
            return 'ok';
        }else{
            return Promise.reject(new Error('failded'))
        }
    }
}

//ajax.js
//登录成功后，需要把token添加到请求头当中，从今往后所有的请求当中都要带上这个token
let token = store.state.user.token;
if(token){
    config.headers.token = token;
}

//用户临时标识和token区别
userTempId  未登录状态下的用户身份识别标识
token       登录状态下的用户身份识别标识 
如果没登陆，请求头当中只带了临时标识，添加的购物车信息是和临时身份标识对应的信息
如果登录了，那么我们同时在请求头添加临时标识和登录后标识，
那么此时后台会把临时标识对应的数据，转移到真正登录的标识数据里面，而临时标识对应的数据就不见了
两个标识都存在的话，后台会合并临时id对应的信息到token对应的信息上 token是老大
```







### 支付界面

```js
//支付流程
1.结算按钮 提交订单信息(push页面的时候,query参数传递订单编号)
2.根据接收的订单编号请求商品信息(支付url,金额)
3.支付1: 根据支付url生成支付二维码,引入qrcode
4.支付2: 扫码支付
5.支付3:使用定时器setInterval轮询请求支付状态
 5.1 支付成功: 存储支付状态->消息提示->关闭定时器(clearInterval,null)->跳转页面




//点击提交订单的逻辑
1.根据订单id获取支付信息 awati this.$API.reqPayInfo(this.orderNum)
2.可以根据支付信息获取支付url和金额
3.支付
3.1 根据支付url生成支付二维码图片显示 使用插件qrcode
3.2 扫码支付
3.3 轮询请求获取订单状态


async pay(){
    try{
        //第一步：根据支付信息当中codeUrl生成二维码进行弹框展示
    let imgUrl = await QRCode.toDataURL(this.payInfo.codeUrl);
    //生成的二维码图片链接进行展示
    this.$alert(`<img src="${imgUrl}" />`, '请使用微信扫码支付',{
        dangerouslyUseHTMLString:true,
        showClose:false,
        showCancelButton:true,
        cancelButtonText:'支付遇到问题',
        confirmButtonText:'我已支付成功',
        center:true,
        beforeClose:(action,instance,done)=>{
            //action代表用户点击的是哪个按钮 'confirm确定按钮', 'cancel取消'或'close关闭'；
            if(action==='confirm'){
                //判断如果没有支付
                if(!this.payStatus){
                    this.$message.info('请确保支付成功,成功后自动跳转支付页面')
                }
            }else if(action==="cancel"){
                //1.提示
                this.$message.warning('支付遇到问题请练习客服');
                //2.清除定时器
                clearInterval(this.timer);
                this.timer = null;
                //3.关闭消息盒子
                done();
            }
        }
    }).then(()=>{}).catch(()=>{});
     //.then() 是对应点击确定按钮之后的操作 .catch();是对应点击取消按钮之后的操作
     //如果采用这两个去操作，都会强制关闭我们的弹出框msgBox,而我们现在并不是要直接关闭，是需要判断用户是不是支付了，才决定关闭不关闭
    
    //轮询 隔2秒发一个请求， 为了让后台给我返回这个订单的支付状态
    //用以判断用户到底是支付了还是没支付
    if(!this.timer){
        this.timer = setInterval(async()=>{
            const result = await this.$API.reqPayStatus(this.orderNum);
            if(result.code === 200){
                //1、把成功的标志存储起来用于用户点击按钮的时候进行判断
                this.payStatus = 200;
                //2、提示支付成功
                this.$message.success('支付成功');
                //3、把定时器清除
                clearInterval(this.timer);
                this.timer = null;
                //4,自动跳转到支付成功页面
                this.$msgbox.close(); //强制关闭弹出框
                this.$router.push('/paysuccess');
                
            }
        },2000)
    }
    }catch(error){
        //生成二维码图片失败 提示
        this.$message.error(error.message)
    }
}

```





### 个人中心页面

```js
//路由权限控制
全局路由守卫: 隐私页面(个人中心,交易及支付相关页面)没登录情况下需要先登录,之后会自动跳转到个人中心页面


```



### 路由守卫在项目中使用

```js
//只有从购物车页面才能跳转到交易页面

//只有从交易页面才能跳转到支付页面

//只有从支付页面才能跳转到支付成功页面, 且需要携带必要的参数订单号,商品信息
```





### 补充

```js
//代码优化
1.图片懒加载:在图片界面没有进入到可视范围前不加载, 在没有得到图片前先显示loading图片
import  lazyload from 'vue-lazyload';
import loading from '@/assets/images/loading.gif'
Vue.use(VueLazyload, { // 内部自定义了一个指令lazy
  loading,  // 指定未加载得到图片之前的loading图片
})

<img v-lazy="goods.defaultImg" />
    
//2.路由懒加载
通常路由组件使用import..from..方式同步将所有路由组件一次性打包在一个文件中.(体积大,加载效率低).
路由懒加载是使用动态import分别打包文件,浏览器请求哪个组件再去加载哪个组件(效率高)

形式: const Home = ()=>import('@/pages/home');
{
    name:'Home',
    component:()=>import('@/pages/home')
}
//3.第三方插件按需引入
element-ui  lodash

//4.大数组优化: 冻结列表+虚拟列表

//5.事件销毁
全局事件总线在beforeDestroy(){this.$bus.$off('eventname')}

//webpack优化

```





### 3) 下单支付流程

- 去结算 ==> 获取订单交易数据
- 提交订单 ==>提交下单请求, 得到订单ID
- 根据订单ID获取支付信息
  - 金额
  - 支付url
- 支付
  - 根支付Url生成支付二维码图片显示, 使用qrcode
  - 扫码支付
  - 轮询请求获取订单状态
- 分页显示订单列表

### 4) 注册流程

- 前台: 输入注册需要的相关信息(用户名/密码/...), 进行前台表单校验, 如果不通过, 提示错误
- 前台: 发送注册的ajax请求(post), 携带注册接口需要的相关数据(用户名/密码/...)

- 后台: 获取到注册请求携带的参数, 去数据库中判断是否已经存在
  - 如果已经存在, 返回提示此用户已存在的提示信息
  - 如果不存在, 保存到数据库, 返回成功的数据
- 前台: 接收到响应
  - 如果是不成功的数据, 提示
  - 如果是成功的数据, 自动跳转到登陆页面

### 5) 登陆流程

- 前台: 输入登陆需要的相关信息(用户名/密码),  进行前台表单校验, 如果不通过, 提示错误
- 前台: 发送登陆的ajax请求(post), 携带登陆接口需要的相关数据(用户名/密码)
- 后台: 获取到登陆请求携带的参数, 去数据库中查询看是否存在
  - 如果不存在, 返回登陆失败的信息
  - 如果存在, 生成一个新的token字符串, 将token与用户信息一起返回
- 前台: 接收到响应
  - 如果是不成功的数据, 提示
  - 如果是成功的数据, 
    - 将用户信息和token都保存到vuex中
    - 将token保存到localStorage中   ==> 不保存用户信息
    - 跳转到首页或redirect页面

### 6) 自动登陆流程

- 简单说: 页面一加载时, 发送请求根据token获取用户信息
- 利用全局前置守卫:
  -  一旦发再当前没有登陆, 但前面登陆过(有token, 没有用户信息)
  -  发送请求根据token获取用户信息
     - 成功了, 保存用户信息及token
     - 失败了(说明token过期了): 清除token, 强制跳转到登陆页面

### 7) 购物车模块

- 购物车数据是保存在后台的, 标识是什么?
  - 未登陆: 标识为用户临时ID(userTempId)
    - 第一次访问时前台利用uuid库生成的唯一字符串, 保存保存在local中
    - 每次请求时通过请求头自动携带它(利用请求拦截器)
  - 登陆: 登陆用户对应的token
    - 用户请求登陆时, 服务器端生成并返回给浏览器, 浏览器收到后自动保存到local中
    - 每次请求时通过请求头自动携带它(利用请求拦截器)
- 添加购物车 / 修改购物项数量
  - 提交请求时, 携带商品的skuid和数量
  - 这2个操作是同一个接口, 也就是数量有可能是负数
- 获取购物车列表
  - 请求获取时不需要携带额外参数, 会自动携带标识: userTempId / token
  - 一旦用户登陆上, 后台会将关联在usertempId上的购物车数据合并到token对应用户关联的购物车数据
- 删除购物项(一个/多个)
  - 请求接口, 携带一个skuId或多个skuId的数组
- 勾选购物项(一个/多个)
  - 请求接口, 携带一个skuId或多个skuId的数组 和 是否勾选的标识数据(0/1)



## 9. Vue 后台项目的重要点

实现element-ui的按需打包

深度作用选择器修改第三方UI组件的内部样式

利用深拷贝解决修改不能取消的问题

利用nextTick与set实现: 动态显示输入框并自动获得焦点

 对Form表单前台校验, 减少无用请求

Upload组件管理图片上传: 限制图片大小和文件类型

路由权限: 路由全局前置守卫 + 动态添加路由: addRoutes()

路由组件懒加载: import()

路由跳转的loading处理: nprogress

登陆成功自动跳转到redirect参数路由

使用各种组件间通信技巧:

​	![后台项目_组件间通信.png](https://i.loli.net/2021/04/10/3vNkhMfDx1cy94T.png)

高复用组件:

![复用组件.png](https://i.loli.net/2021/04/10/gZP1iphXS9TLvOf.png)







## 性能优化

> [🔥 2022 前端性能优化最佳实践 - SegmentFault 思否](https://segmentfault.com/a/1190000041753539)
>
> [聊一聊前端性能优化 - 掘金 (juejin.cn)](https://juejin.cn/post/6911472693405548557)



### 性能优化本质

**展示更快**、**交互响应快**、**页面无卡顿情况**。

更详细的说，就是指，在用户输入url到站点完整把整个页面展示出来的过程中，通过各种优化策略和方法，让页面加载更快；在用户使用过程中，让用户的操作响应更及时，有更好的用户体验。

### 性能优化指标

1.性能评估 Chrome Performance选项卡 / Lighthouse 生成性能检测报告 

2.值得关注的性能指标

(1)LCP (Largest Contentful Paint 最大内容绘制 ) 

(2)首屏渲染时间（也叫白屏时间） 

(3)FCP (Fitst Contentful Paint 首先内容绘制 ) 

(4)可交互时间 (Time to Interactive TTI)

 (5) Network请求时间(jax,js等) 

3.浏览器开发者工具什么都能看得到，可以调用性能监测API 或建立 前端监控系统(无痕埋点) 



### 性能优化手段

前端性能优化分为两类，一类是文件加载更快，另一类是文件渲染更快。 

* 加载更快的方法： 
  * 让传输的数据包更小（压缩文件/图片）：图片压缩和文件压缩 
  * 减少网络请求的次数：雪碧图/精灵图、节流防抖 
    * 雪碧图的应用场景一般是项目中不常更换的一些固定图标组合在一起，比如logo、搜索图标、切换图标等
    * 电商项目中最常用到的懒加载，一般在查看商品展示的时候通常下拉加载更多，因为商品数据太多，一次性请求过来数据太大且渲染的时间太长。
  * 减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等） 
* 渲染更快的方法： 
  * 提前渲染：ssr服务器端渲染 
  * 避免渲染阻塞：CSS放在HTML的head中 JS放在HTML的body底部 
  * 避免无用渲染：懒加载 
  * 减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签 



### JS中的性能优化

#### 1.不要覆盖原生方法

#### 2.事件委托(简化DOM操作)

#### 3.JS动画

#### 4.节流与防抖



### 页面渲染优化

#### 1.避免CSS, JS堵塞

CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。**尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化）**

实际使用时，可以遵循下面3个原则：

- **CSS 资源优于 JavaScript 资源引入**
- **JS 应尽量少影响 DOM 的构建**

改变JS阻塞方式

##### defer（延缓）模式

`defer` 方式加载 script, 不会阻塞 HTML 解析，等到 DOM 生成完毕且 script 加载完毕再执行 JS。

##### async（异步）模式

`async` 属性表示异步执行引入的 JS，加载时不会阻塞 HTML解析，但是加载完成后立马执行，此时仍然会阻塞 load 事件。

从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 `async`；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用`defer`。



#### 2.使用字体图标iconfont代替图片图标

字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。



#### 3.降低CSS选择器复杂性

浏览器读取选择器，遵循的原则是从选择器的右边到左边读取

1. 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素
2. 关注可以通过继承实现的属性，避免重复匹配重复定义
3. 尽量使用高优先级的选择器，例如 ID 和类选择器。
4. 避免使用通配符，只对需要用到的元素进行选择



#### 4.减少重绘和重排(回流)

**回流必将引起重绘，重绘不一定会引起回流，回流比重绘的代价要更高。**

如何避免?

**CSS**

- 避免使用table布局。
- 尽可能在DOM树的最末端改变class。
- 避免设置多层内联样式。
- 将动画效果应用到position属性为absolute或fixed的元素上。
- 避免使用CSS表达式（例如：calc()）。

**JavaScript**

- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
- 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。



#### 5.使用flexbox布局



#### 6.图片资源优化

##### 使用雪碧图

雪碧图的作用就是减少请求数，而且多张图片合在一起后的体积会少于多张图片的体积总和

##### 图片压缩

压缩方法有两种，一是通过在线网站进行压缩，二是通过 webpack 插件 image-webpack-loader。它是基于 [imagemin](https://link.segmentfault.com/?enc=OIHazSW1xgE0eJv1ufzlhg%3D%3D.50sTefI%2FunQpQnTLFGGC2iHdYBRXLANOzcn9%2BnYmSIMvSsZ2MxqDRBV%2F%2BgM8jZ3hfnNCnY2A6GBe0w8Jx7FIk7eCSR1knYAy2lBQYNu45s4%3D) 这个 Node 库来实现图片压缩的。

##### 图片拉加载

在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。

##### 使用CSS3代替图片



##### 使用webp格式的图片

小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。












###  Vue代码层面优化

####  1) v-for 遍历列表

指定非下标的唯一key

不同时使用 v-if



#### 合理使用watch computed

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行**异步**或**开销较大**的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。



#### 长列表性能优化

Vue 会通过 `Object.defineProperty` 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 `Object.freeze` 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

```javascript
export default {
  data: () => ({
    users: {}
  }),
  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
};
```



#### 优化无线列表性能: 虚拟列表

如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 [vue-virtual-scroll-list](https://link.segmentfault.com/?enc=RwGR6yk1CBddLI%2Bu8vtszQ%3D%3D.dlCkBYR4PA%2B55K3tT%2FQw8n0NYgopqNuyAiHiOl%2BmqkEbvSEXfwJzLmiOlCKtzroQt8eQCA8Nhva3W4K0YZ%2B%2FqtpzzMo6urAt17%2F52bgtgue87rsur8bCDAKfgfIWQNni) 和 [vue-virtual-scroller](https://link.segmentfault.com/?enc=VUESvmfK3cEynJ2TsRaDtw%3D%3D.BJ5wA7H4OmMcXokRRU59qGLNEEnNcyBtrSbVUK4mD9Dx8n1PY3Ug0ZqP05IZgBQjewtZNwuUGdg0J9VPr%2FVEGmAMU0cO94XO2a%2FeHYKtnDDlsvX9R2pFCY2p2kTTalwi) 来优化这种无限列表的场景的。



#### 事件的销毁

Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 JS 内使用 `addEventListener` 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：

```javascript
created() {
  addEventListener('click', this.click, false)
},
beforeDestroy() {
  removeEventListener('click', this.click, false)
}
```





#### 图片资源懒加载

如使用v-lazyload

##### 页面大量图片，如何优化加载，优化用户体验

1. 图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
2. 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
3. 如果图片为css图片，可以使用CSSsprite，SVGsprite等技术。
4. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
5. 如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。



#### 路由组件懒加载

```js
https://blog.csdn.net/fanjianglin/article/details/113430620
```

>  **Vue动态加载组件主要有两类方式，即import方式和require方式**, 

const Home = () => import('./pages/Home')

#### 第三方插件的按需引入

如: element-ui / vant 



#### 服务端渲染SSR / 预渲染

具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《 [Vue SSR 踩坑之旅](https://link.segmentfault.com/?enc=Hf%2BIPuMRv2K%2BeUWhiiDh1w%3D%3D.3jDS1JNzAA3uTddj1k%2FbKUkxDfmUV66bvM0o0VlBp7p4tnJIH%2F%2FCoaWInurEjB3S) 》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要**预渲染**，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 [prerender-spa-plugin](https://link.segmentfault.com/?enc=0VzVqkIFywisus2tXadNQA%3D%3D.idXZ937QutVTXXQ7wd01EK5OzIiISu2XSekHrv7pF9FQiDAmnD%2BWfxWCnx3amR%2FY1GwMIYYXtSDhO1lW0mWFyN7OTrA%2BbYHHgPsQzzqGblwB1SWoyI0BnBBKo7se13rh) 就可以轻松地添加预渲染 。



### webpack配置层面优化

#### 1) 兼容性处理

- JS

  - babel-loader: presets: ['@babel/preset-env'] 问题就是只能编译/转换简单语法
  - @babel/polyfill: 做复杂语法(新的APi)兼容，问题是体积太大了
  - core-js: 在@babel/preset-env基础上，增加了useBuiltIns: 'usage'来实现按需打包

- CSS  

  - postcss-loader  

  - 内部使用autoprefixer插件, 给C3样式自动添加厂商前缀

    ![preview](https://segmentfault.com/img/remote/1460000014782566/view)

  - 在package.json中指定browserslist来指示postcss-loader兼容性做到什么程度

#### 2) 拆分打包与压缩

对第三方JS包, css进行拆分打包

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2130fabf53ec430b9d103ae8b8009eca~tplv-k3u1fbpfcp-watermark.image)

#### 3) 资源预加载(prefetch)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a896fd6ab9e4e3b9479ea018aae8b49~tplv-k3u1fbpfcp-watermark.image)

#### 4) 生产环境时不生成 SourceMap

productionSourceMap: false

减少打包文件

#### 5) 文件名hash化=>利用浏览器缓存

对打包文件名用上contenthash ==> 某个bundle对应的模块文件内容发生改变文件名才会变化 ===> 利用浏览器缓存

#### 6) 代码Tree Shaking

效果: 打包时'摇掉'模块中没有被使用的代码

条件: 必须是ES6模块化导出且进行代码压缩时



### 基础的Web技术层面的优化

#### 1) 开启 Gzip

- 下载: yarn add compression-webpack-plugin --dev

- vue.config.js

```
var CompressionWebpackPlugin = require('compression-webpack-plugin');
...
configureWebpack: config => {
  config.plugins.push(
      new CompressionWebpackPlugin({
          test: new RegExp('\\.(js|css)$'),
          threshold: 8192,
          minRatio: 0.8
      })
 )
```

- nginx.conf中

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6749ab642da04d578181cc30d6f114e7~tplv-k3u1fbpfcp-watermark.image)

#### 2) 静态资源(css/js/img)使用CND引入

浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。

![image-20201119221157741.png](https://i.loli.net/2021/04/09/c2ZFgNI75WtVAze.png)



### 缓存优化 ??

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。



- HTML：使用协商缓存。
- CSS、JS和图片：使用强缓存，文件命名带上hash值



### 其他

#### vue-cli3 已有优化

> https://juejin.cn/post/6844904083858407438

webpack4中，`mode`为`production`时会自动开启**代码压缩**和`Tree Shaking`















## 10. React

### 基础

- JSX语法最终都会经过babel编译，编译成JS语法
- 组件名首字母必须大写，JSX一旦标签首字母小写就会当做html元素解析，但是html中没有这个元素就会报错
- 内部返回虚拟DOM对象元素必须有结束符
- 必须要保证更新的数据是一个全新数据（不能push unshift等）
- Fragment  能作为多个虚拟DOM元素的根节点    优点：不会生成真实DOM元素   简写方式<></>

#### 通信方式

- props

  用PropTypes限制传入类型

- refs

  xxx = React.createRef()，再作用在标签上

- 消息订阅(subscribe)-发布(publish)机制

  import PubSub from 'pubsub-js' //引入

  PubSub.subscribe('delete', function(msg,data){ }); //订阅

  PubSub.publish('delete', data) //发布消息

- context  内部包含两个组件

  context.Provider 提供者（负责向后代组件提供数据）

  context.Consumer 消费者（负责消费数据，使用父（爷）组件提供的数据）

- forwardRef，获取工厂/纯函数组件的ref

  函数组件通过第二个参数接收ref

- render props

  本质上是一个组件，将B组件渲染到A组件内部，同时A组件传递必要的props（往往是属性数据，而不是方法）

  ```react
  <A render={(count) => {return <B count={count} />;}}/>
  ```

- 总结：

  触发事件元素和要收集数据元素是同一个元素，就e.target

  触发事件元素和要收集数据元素不是同一个元素，就用refs

#### 生命周期函数

**始化流程**

- constructor
- componentWillMount    将要挂载
- render     开始执行
- componentDidMount     挂在完成

**更新流程（三种方式触发）**

1. 父组件this.setState导致子组件重新渲染，子组件会触发：

   componentWillReceiveProps	将要接收数据

   shouldComponentUpdate	

   componentWillUpdate

   render

   componentDidUpdate	更新完成

2. 父组件this.setState, 父组件触发：

   shouldComponentUpdate

   componentWillUpdate

   render

   componentDidUpdate

3. 父组件this.forceUpdate, 父组件触发：

   componentWillUpdate

   render

   componentDidUpdate 

**卸载**

- componentWillUnmount 

  直接将之前插入到指定容器的DOM结构直接移除

  页面上没有该内容  

**即将废弃的生命周期**

- componentWillMount
- componentWillUpdate

**新的生命周期**

- static getDerivedStateFromProps(props, state){}

  用来取代willMount和willUpdate

  render 方法之前调用，并且在初始挂载及后续更新时都会被调用

  返回一个对象来更新 state，如果返回 null 则不更新任何内容

#### 重要生命周期函数

- componentDidMount

  发送请求、设置定时器、绑定事件等一次性任务

- shouldComponentUpdate    做性能优化

  返回值 true 要更新

  返回值 false 不更新

- componentWillUnmount

  取消请求、清除定时器、解绑事件等收尾工作

#### 高阶组件：HOC

- 本质上是一个函数：执行函数接受一个组件作为参数，返回值是一个新组件
- 给高阶组件命名 --> displayName优先级最高
- 可用高阶函数的形式传参
- 可用装饰器语法调用

#### Hooks（钩子）

- 本质就是函数，能让你使用React组件的状态和生命周期函数...

- 作用：让代码更加可复用，不用在定义繁杂的HOC

- 使用：

  - 让工厂函数组件拥有状态数据state

    `const [状态数据（初始化为defaultValue）, 更新状态数据的方法] = React.useState(defaultValue)`

  - 让工厂函数组件拥有生命周期函数（componentDidMount componentDidUpdate componentWillUnmount）

    ```react
    React.useEffect(() => {
        return () => {
          PubSub.unsubscribe("MSG");
        };
    },[])
    ```

#### react-router

- **Hash 模式** 

  兼容性好

  缺点带#

  刷新页面时只会把#前面地址发请求

- **History 模式**

  兼容性稍差

  地址很干净

  刷新页面时会把所有地址带上发请求（导致开发时刷新浏览器404问题）

  解决方法：

  ​		出现404，就直接返回 index.html

  ​		webpack配置devServer historyApiFallback: true

  问题：引入资源（css/js）路径问题

  ​		webpack配置output publicPath: "/"

  ​		index.html --> "/bootstrap.css"

- **API**

  ```react
  import {
    BrowserRouter,HashRouter,Link,NavLink,Route,Redirect,Switch,
  } from "react-router-dom";
  ```

- **路由组件三大属性（都在props上）**

  location     pathname 当前路由地址    state 

  history       push/replace/goBack/goForward/listen 等方法，用来操作浏览历史记录

  match        params 参数
  
- **特点**

  1. 默认是模糊匹配，如果想要精准匹配，需要给Route标签添加一个属性 exact
  2. 默认每次匹配都会匹配所有注册路由
  3. 性能优化相关： Switch, 一旦有匹配成的路由就停止匹配

- **路由传参**

  1. params传参

     ```react
     <Route path='/home/:id' component={Home}></Route>
     ```

  2. props 传参

     ```react
     <Route path='/personal' render={() => <Personal num={123}/>}></Route>
     ```

     

### 面试

#### 工厂函数组件和ES6类组件的区别

1. this不一样

   工厂函数没有this，ES6类组件函数中有this

2. 功能不一样

   工厂函数没有this，有些功能默认实现不了；ES6类组件有this，所以可以实现 

- 总结

  工厂函数组件一般用来定义功能简单组件

  ES6类组件一般用来定义功能复杂组件

#### 函数柯里化

- 是闭包的典型应用

```react
// 普通函数
function fn(a, b) { return a + b}
// 经过函数柯里化处理的函数
function fn(a) {
  return function (b) {
    return a + b;
  }
}
```

#### 性能优化

- 减少render调用次数，从而减少diff比较和重新渲染次数

1. 自己编写shouldComponentUpdate（nextProps, nextState）函数进行优化

2. PureComponent：组件内部实现了一种类似shouldComponentUpdate的比较

   ```react
   import { PureComponent } from "react";
   export default class Index extends PureComponent {}
   ```

- shouldComponentUpdate 和 PureComponent 同时存在只会生效 shouldComponentUpdate

#### Portals

- Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
- 通常情况下不会使用，一般用于Modal组件 
- 防止组件卸载/重新创建过程中创建多个div

#### 如何遍历显示子路由

- 没有通过Route加载，所以没有路由组件三大属性

- 解决：react-router-dom有一个高阶组件withRouter，withRouter内部保存路由组件的三大属性，会给被包装组件传递三大属性

- 判断routes中哪个配置匹配上当前路径

  forEach 一般写代码推荐forEach，语义化更好，一般用于要全部遍历的场景

  for循环 一般写库或框架，追求极致性能使用。性能好，一般用于遍历可中断的场景

- 判断 当前路径是否以一级菜单开头：

  String.prototype.startsWith()

  正则表达式

注意：

​		如果Route组件不加exact属性（严格模式），则会默认匹配以该路径开头的组件

#### 虚拟DOM的diff算法

**diff 策略**

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

- 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。

**tree diff**

- 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。

- 即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

- 如果出现了 DOM 节点跨层级的移动操作，性能不好!

**component diff** 

- 如果是同一类型的组件，按照原策略继续tree diff。

* 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。

* 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。

**element diff**

- 允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！

- 通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动

- 在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

### 深入理解setState

- **setState()更新状态的两种写法:**

  setState(stateChange,[callback])--------对象式的setState

  setState(updater,[callback])---------函数式的setState

- **setState()更新状态的动作是同步还是异步的**？（setState()执行的位置对其后续动作的影响）

  在由react所控制的回调函数中更新的动作是【异步】的，如：生命周期钩子 / react所监听的事件

  在非react控制的异步回调函数中更新的动作是【同步】的，如：定时器的回调 / 原生事件监听回调 /Promise所指定的成功、失败回调 / ajax所指定的成功或失败的回调

- **关于异步的setState()连续多次调用的问题**

  1. 多次调用，如何处理？

     若是对象式的setState，多次更新状态的动作合并为一次(只以最后一次为准),所以就调用一次render

     若是函数式的setState，每次更新的动作都会生效(更新的动作不合并)，但是只会调用一次render

  2. 注意：

     若函数式setState和对象式setState混用的时候，要把函数式写在最后

  3. 如何得到异步更新后的状态？

     在setState第二个参数的回调里





## 11. 移动端

### 基础知识

- 1英寸(inch) = 2.54厘米(cm)

-  IPhone 6 的屏幕分辨率为 750 * 1334  设备独立像素为 375 * 667

- 物理像素：由屏幕制造商决定，屏幕生产后无法修改

- css像素：单位是px，它是为 Web 开发者创造的

- 设备独立像素的出现，使得即使在【**高清屏**】下，也可以让元素有正常的尺寸，让代码不受到设备的影响，它是设备厂商根据屏幕特性设置的，无法更改。

- 1个位图像素对应1个物理像素，图片才能得到完美清晰的展示

- pc端视口：默认宽度和浏览器窗口的宽度一致，也被称为初始包含块`document.documentElement.clientWidth`

- 移动端视口:

  - 布局视口：一般是**<span style='color:red'>980px</span>**左右，布局视口经过压缩后，横向的宽度用css像素表达就不再是375px了，而是980px

  - 视觉视口：用户可见的区域，它的绝对宽度永远和设备屏幕一样宽

  - 理想视口：布局视口宽度 与 屏幕等宽（设备独立像素），靠meta标签实现

    ```html
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    ```

### 适配

#### 1.viewport 适配

- 方法：拿到设计稿之后，设置布局视口宽度为设计稿宽度，然后直接按照设计稿给宽高进行布局即可。
- 一般适用于：计图稿宽度 < 375

```js
<meta name="viewport" content="width=375">
```



#### <span style="color:#ee0b41">2.rem适配</span>

- 方案一：（百度）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小 = **( 当前设备横向独立像素值 *100) / 设计稿宽度**</span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / 100** </span>
  4. 增加 JS 代码进行实时适配
- 方法二：（淘宝、搜狐、唯品会）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小  = **当前设备横向独立像素值 / 10** </span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / (设计稿宽度 / 10)**</span>
  4. 增加 JS 代码进行实时适配

#### 3.vw适配

vw和vh是两个相对单位

- 1vw = 等于布局视口宽度的1%
- 1vh = 等于布局视口高度的1%

#### 4.1px物理像素边框

高清屏幕下 1px 对应更多的物理像素，所以 1 像素边框看起来比较粗，解决方法如下

##### 方法一

使用媒查询：

```css
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo{
        border: 0.5px solid black;
    }
}
或
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo2::after{
        transform:scaleY(0.5);
    }
}
```

##### 方法二

根据dpr扩大布局视口，例如dpr为n则布局视口改为原来的n倍，则元素尺寸均变为原来的n分之一，为了保证元素尺寸比例不变，扩大根字体为原来的n倍，但整个过程中边框一直用px作为单位，不用rem。

1. rem 页面布局

2. 元素的边框设置为 1px

3. 通过 viewport 中的 initial-scale 将布局视口扩大n倍，这样页面元素就比原来缩小了n倍

```js
var viewport = document.querySelector('meta[name=viewport]')
var scale = 1 / window.devicePixelRatio
viewport.setAttribute('content', 'width=device-width,initial-scale=' + scale);
```

4. 重新设置根元素字体

```js
var fontSize = parseInt(document.documentElement.style.fontSize);
document.documentElement.style.fontSize = fontSize * window.devicePixelRatio + 'px'
```

### 移动端事件

* touchstart   元素上触摸开始时触发
* touchmove   元素上触摸移动时触发
* touchend   手指从元素上离开时触发
* touchcancel   触摸被打断时触发

### 移动端中touchstart,touchend,click执行顺序

- touchstart
- touchend
- click，浏览器在 click 后会等待约300ms去判断用户是否有双击行为，如果300ms内没有再一次click，那么就判定这是一次单击行为

### 点击穿透

- touch 事件结束后会默认触发元素的 click 事件

  方法一：阻止默认行为

  方法二：使背后元素不具备click特性，用touchXxxx代替click

  方法三：让背后的元素暂时失去click事件，300毫秒左右再复原，属性`pointer-events: none;`

  方法四：让隐藏的元素延迟300毫秒左右再隐藏

### getComputedStyle

- 可读取到非内联样式上的属性
- 可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式





## 12. 小程序

### 1) 小程序特点

1. 体积小，压缩包的体积不能大于2M
2. 没有DOM对象
3. 基于组件化开发
4. 小程序环境不同于浏览器环境
   1. 浏览器环境中全局对象： window
   2. 小程序环境中全局对象：wx
   3. 小程序环境中没有window对象

### 2)小程序适配

1. 小程序适配单位： rpx(responsive px) 响应式单位
2. 小程序中规定所有的机型中页面宽度都是750rpx
3. iphone6: 1物理像素 = 0.5px = 1rpx ---> 1px = 2rpx
4. 小程序底层已经做了viewport适配

### 3) 小程序相关语法

1. 数据绑定

   1. 单项数据流: Model ---> view
   2. 修改状态数据： this.setData() 同步行为
   3. 页面中的数据均来自于data中，使用data中的数据的时候记住使用表达式{{}}
   
2. 事件绑定

   1. 事件分类： 冒泡事件 || 非冒泡事件
   2. 绑定的方式： bind + 事件名  || catch + 事件名
   
3. 路由跳转

   1. wx.navigateTo() || wx.redirectTo()
   
4. 本地存储
   1. 语法： 
      1. wx.setStorage() || wx.setStorageSync()
      2. wx.getStorage() || wx.getStorageSync()
   2. 注意点
      1. 单个key上限是1M
      2. 整体上限是10M
   
5. 全局传参

   app.js中可定义全局参数globalData

### 4) 向事件对象传参

1. 语法
   1. id=value
   2. data-key=value
2. 获取
   1. id: event.target.id || event.currentTarget.id
   2. data-key: event.target.dataset.key || event.currentTarget.dataset.key
3. 使用场景
   1. id：通常需要向event对象传递单一且唯一的标识
   2. data-key:   需要向event对象传递多个标识数据

### 5) 小程序获取用户唯一标识（openId）

1. 客户端先通过wx.login(获取code
2. wx.request()发送code给服务器
3. 服务器端发送请求携带参数(code, appSecret（开发密钥）, appId)给微信服务器获取openId
4. 微信返回openId给服务器后，服务器进行加密再返回给前端
5. 前端进行本地储存，下次发送请求时携带参数

### 6) 小程序支付流程

1. 用户在小程序客服端下单(包含用户及商品信息)
2. 小程序客户端发送下单支付请求给商家服务器
3. 商家服务器同微信服务器对接获取唯一标识openID
4. 商家服务器根据openId生成商户订单(包含商户信息)
5. 商家服务器发送请求调用统一下单API获取预支付订单信息
6. 商家对预支付信息签名加密后返回给小程序客户端
7. 用户确认支付（鉴权调起支付）
8. 微信服务器返回支付结果给小程序客户端
9. 微信服务器推送支付结果给商家服务器端


### 7) 面试问题

- Iphone6的dpr为多少？Iphone6Plus比Iphone6显示图像清晰吗？

  视网膜屏幕是分辨率超过人眼识别极限的高分辨率屏幕，Iphone4的dpr = 2; 人类肉眼分辨的极限
  
- 生命周期函数实际测试和官网描述有差

- wx.setStorage()，单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB

- 性能优化

  一个页面一次只有一个video标签，其余的使用image代替
  
- 请求相关

  小程序为了安全起见只支持Https请求

  wx.request最大并发限制10个

- 如何使用组件

  先创建组件，在对应的json文件下设置component: true

  到使用组件页面的json文件中，注册组件填写相应的路径

- 使用npm包

  下载后，勾选使用npm模块，再构建npm，会将node_modules中的包打包到miniprogram_npm中

- 分包相关

  分包后可解决2M限制，并且能分包加载内容，提高性能

  分包后单个包的体积不能大于2M，所有包的体积不能大于16M

  1. 常规分包

     加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容

     分包的页面可以访问主包的文件，数据，图片等资源

  2. 独立分包

     独立分包可单独访问分包的内容，不需要下载主包

     独立分包不能依赖主包或者其他包的内容

     通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页 || 活动页

  3. 分包预下载

     在加载当前包的时候可以设置预下载其他的包

     缩短用户等待时间，提高用户体验

### 7)-2小程序开发遇到的问题

```js
1.页面通信方式及注意事项
通信方式: 路由传参+storage
 路由传参只能通过query形式(原生小程序对query参数有长度限制,如果长度过长会自动截取.且会对query参数自动进行类型转换)
 wx.getStorage('cookies')

2.本地存储 有上限

3.请求
 协议: https请求
 并发数:10个
 
4.分包
4.1原因:程序要求压缩包体积小于2M;提高用户体验, 提高页面的加载速度
4.2形式
4.3特点:

5.性能优化:
5.1 视频优化 图片封面
5.2 
```



### 8) 开发相关

- setData行为始终是同步的
- H5中实现滑块功能，推荐大家使用：better-scroll

### 9) 封装

- 封装函数：

  1. 功能点明确

  2. 函数内部保留静态的数据

  3. 将动态的数据抽取出来作为形参，由使用者根据场景不同动态传入实参

- 封装组件：

  1. 功能点明确 || 呈现效果

  2. UI组件 || js组件

  3. 组件内部保留静态的数据

  4. 将动态的数据抽取出来作为 props属性，由使用者根据场景不同动态以标签属性的形式导入

  5. 封装良好的组件应该规定传入props数据的必要性还有数据类型 propsType

## 13) express

### 1. 基本使用

```js
// 引入
let express = require('express');
// 1. 生成应用实例
const app = new express(); // app: application 代表整个应用

// 3. 注册路由
app.get('/', (request, respone) => {
  console.log('1111');
  // 返回数据
  respone.end('success data');
});

app.get('/login', (req, res) =>  {
  console.log('2222');
  res.end('login data');
});

app.post('/register', (req, res) =>  {
  console.log('4444');
  res.end('register data');
});

// 2. 绑定监听(设置当前项目的端口号)
app.listen('3001', (err) => {
  if(err){
    console.log('服务器启动失败');
    console.log(err);
  }else {
    console.log('服务器启动成功');
    console.log('服务器地址： http://localhost:3001');
  }
})

```

### 2. 路由

1. 路由分类
   1. 前端路由
   2. 后端路由
2. 前端路由
   1. 发请求不需要走网络传输层
   2. 需要由前端指定的js库解析(vue-router, react-router-dom)
   3. 应用： SPA（single page application）
3. 后端路由
   1. 发请求需要走网络传输层
   2. 需要由服务器端解析
   3. 应用： 前后端交互

### 3. 路由参数

1. get请求
   1. params参数： 
      1. 请求： url/:id ==> url/参数
      2. 获取： req.params
   2. query参数:
      1. 请求：url?key=value&key2=value2
      2. 获取: req.query
   3. 总结:
      1. params参数只能有一个参数，适用于参数为标识数据
      2. query参数可以有多个
2. post请求
   1. params参数
   2. query参数
   3. body参数
      1. 相对安全
      2. 获取req.body，但是不能直接获取，需要使用中间键

### 4. res常用方法

1. res.end() 返回响应: 直接返回数据
2. res.send() 根据数据类型不同，自动做出判断处理，再返回，如：中文的话会自动设置content-type
3. res.set() 设置响应头的方法
4. res.json() 返回的数据一定是json数据，直接返回
5. res.cookie() 设置cookie
6. res.status() 设置状态码
7. res.redirect() 返回的是新地址，状态码通常是302，浏览器接收到响应以后会跳转至新的地址
8. res.download()  返回的文件信息，浏览器会自动下载该文件

### 5. 中间件

1. 本质
   1. 就是一个函数
2. 作用
   1. 处理请求，返回响应数据
   2. 获取，修改请求的参数及响应数据
   3. 执行下一个中间键
3. 体现形式
   1. (req, res, next) => {}
   2. req: 请求对象
   3. res: 响应对象
   4. next：是一个方法，用来调用下一个中间键
4. 注意
   1. 连续使用多个中间键的时候返回数据的动作应该放在最后且只有一次
   2. 路由对应的回调 也是中间键函数
   3. 如果请求方法和中间键共存的情况下，只能匹配一个，谁在前就匹配谁（满足匹配条件情况下）

## 14 问题

### 如何做到修改url参数页面不刷新

HTML5引入了 `history.pushState()` 和 `history.replaceState()` 方法，它们分别可以添加和修改历史记录条目。

```js
let stateObj = {
    foo: "bar",
};

history.pushState(stateObj, "page 2", "bar.html");
```

假设当前页面为 `foo.html`，执行上述代码后会变为 `bar.html`，点击浏览器后退，会变为 `foo.html`，但浏览器并不会刷新。



### 请用js去除字符串空格

去除所有空格

```text
str.replace(/\s/g, '')
```

去除两边空格

```text
str.replace(/^\s+|\s+$/g, '')
// 原生方法
str.trim()
```



### 格式化金钱，每千分位加逗号

```javascript
function format(str) {
    let s = ''
    let count = 0
    for (let i = str.length - 1; i >= 0; i--) {
        s = str[i] + s
        count++
        if (count % 3 == 0 && i != 0) {
            s = ',' + s
        }
    }
    return s
}


function format(str) {
    return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,')
}
```



### 服务端渲染

服务器端生成HTML直接返回给浏览器、减少网络传输、首屏渲染快、对搜索引擎友好 标准回答 SSR是Server Side Render简称；页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的html就可以了。和它对应的是，CSR是Client Side Render简称；客户端在请求时，服务端不做任何处理，直接将前端资源打包后生成的html返回给客户端，此时的html中无任何网页内容，需要客户端去加载执行js代码才能渲染生成页面内容，同时完成事件绑定，然后客户端再去通过ajax请求后端api获取数据更新视图。 

服务端渲染的优势：减少网络传输，响应快，用户体验好，首屏渲染快，对搜索引擎友好，搜索引擎爬虫可以看到完整的程序源码，有利于SEO。 

在Vue项目中实现服务端渲染方法：Vue在客户端渲染中也是采用一定方法将虚拟DOM渲染为真实DOM的，那么服务端的渲染流程也是通过虚拟DOM的编译来完成的，编译虚拟DOM的方法是renderToString。在Vue中，vue-server-renderer 提供一个名为 createBundleRenderer 的 API，这个API用于创建一个 render，并且自带renderToString方法。 

加分回答 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 

- 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 
- 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 

- 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。



### 保持前后端实时通信

保持前后端实时通信的方法有以下几种： 

轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。

* 优点就是实现简单，无需做过多的更改。
* 缺点是轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担  

长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，如果没有新消息，就一直等待。有新消息，才会返回给客户端。

* 在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。
* 优点是做了优化，有较好的时效性。
* 缺点是保持连接会消耗资源; 服务器没有返回有效数据，程序超时。

iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。

* 优点是消息能够实时到达；浏览器兼容好。
* 缺点是服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。 

WebSocket是类似Socket的TCP长连接的通讯模式，一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。缺点是浏览器支持程度不一致，不支持断开重连。 SSE(Server-Sent Event)是建立在浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。

SSE 是单向通道，只能服务器向浏览器发送，因为 streaming 本质上就是下载。 优点是SSE 使用 HTTP 协议，现有的服务器软件都支持。SSE 属于轻量级，使用简单；SSE 默认支持断线重连； 

轮询适用于：小型应用，实时性不高 长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天 iframe适用于：客服通信等 WebSocket适用于：微信、网络互动游戏等 SSE适用于：金融股票数据、看板等



## 自我介绍

```md
// 时间1分钟30秒左右

您好,面试官. 我叫xxx, 我面试的岗位是前端开发.
个人目前涉及的技术包括:
 vue2及vuex,vuerouter全家桶系列, UI框架包括elementUI, antUI, vantUI.
 熟悉原生JavaScript;
 了解react,python,SEO/SEM.搭建过Django博客,做过搜索引擎关键字排名及网站推广.
 同时个人也在github上翻译英文仓库.
 
个人做过的项目有:
	商城网站前后台
	国网APP下一个微应用
	
	商城网站用来为客户提供商品的展示和购买服务,使用vue2+elementUI,个人负责及参与的页面包括首页,详情页及支付购买页面.
	国网APP的微应用是是便于国网基层员工对用电单位进行多维度的信息普查工具,使用vue2+vant, 个人负责的是基本信息普查模块.
	
最后,我希望在新的工作岗位上能有更多项目历练及技术提升的机会.
```

