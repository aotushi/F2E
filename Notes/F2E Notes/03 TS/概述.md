## TS开发环境搭建

> 主要是VSCode中配置

### 打开VSCode中TS的所有配置
1. 通过 Ctrl(Command) + Shift + P 打开命令面板，找到「打开工作区设置」这一项
2. 输入'typescript',会筛选出所有 TypeScript 有关的配置.点击左侧的"TypeScript"，会在右侧展示内置的配置.
3. 补全搜索框中的搜索词，使用“typescript inlay hints”, 更新右侧的配置选项.

### 推荐开启的配置
- Function Like Return Types，显示推导得到的函数返回值类型；
  
- Parameter Names，显示函数入参的名称；
  
- Parameter Types，显示函数入参的类型；
  
- Variable Types，显示变量的类型。

> 这些配置的主要能力就是把参数名，参数类型，以及推导得到的类型等等信息直接展示在屏幕上，否则你就需要悬浮鼠标在代码上来查看这些信息了。对于入门阶段的开发者来说，可以开启这些配置项来获得更清晰的类型信息。



### 如何分享TS代码给他人
推荐的方式
* 使用 Web IDE，比如 CodeSandbox
* TS官方的 [TypeScript Playground](https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fplay "https://www.typescriptlang.org/play")


## TS中的类型

基本类型
* boolean
* string
* number
复杂类型
* array
* object
* tuple(元组)
特殊类型
* any
* void
* never
枚举类型
* enum
### 联合类型和交叉类型
* 联合类型
* 交叉类型
### 类型别名
* *

## 原始类型和对象类型

#### 原始类型的类型标注
使用 `: 类型` 的语法来实现，这里的类型其实也就是 string / number / boolean：
```ts
const userName: string = 'linbudu'
const userAge :number = 18
const userMarried: boolean = false
```

#### 数据/对象标注

数组类型有两种标注方法:
> 这两种方式没有明显的区别，获得的类型提示都是完全一致的，仅仅取决于你想把数组成员的类型写在前还是后。
* `Array<数组类型>`
* `数组类型[]`

```ts
const userName1: string[] = [];
const userName1: Array<string> = [];
```

Set类型和Map类型和数组类型标注有点类似.
```ts

const set = new Set<number>();

set.add(1);
set.add('2'); // X 类型“string”的参数不能赋给类型“number”的参数。

const map = new Map<number, string>();

map.set(1, '1');
map.set('2', '2'); // X 类型“string”的参数不能赋给类型“number”的参数。

```




对象类型标注:
使用接口(interface)进行标注:
```ts
interface User {
	userName: string,
	userAge: number,
	userMarried: boolean
}

const user: User = {
	userName: 'test', 
	userAge: 20, 
	userMarried: false,
}
```




#### 接口类型
* 接口的属性类型可以是任意有效的类型，可以是一个接口
* 接口加上数组类型,可以描述一个成员是对象的数组类型
* 可选属性使用`?`当作可选标记

```ts
interface JobModel {
  // ...
}

interface Job {
  currentModel: JobModel;
}

interface User {
  userJob: Job;
}

```

```ts
const userList: User[] = [
  {
    userName: 'test',
    userAge: 20,
    userMarried: false,
  },
  {
    userName: 'test',
    userAge: 20,
    userMarried: false,
  },
  {
    userName: 'test',
    userAge: 20,
    userMarried: false,
  },
];

```


```ts
// 这里的问号意味着，userJob 被标记成了一个可选的属性，也就是说变量即使不具有 userJob 属性，也可以认为是符合了 User 类型：

interface User {
  userName: string;
  userAge: number;
  userMarried: boolean;
  userJob?: string;
}


const user: User = {
  userName: 'test',
  userAge: 20,
  userMarried: false,
};

```

#### 枚举类型 enum

枚举带来的好处:
* 枚举能提供清晰的提示及值
* 对于数值类型的值,可以自动累加值

在JS中通过对象方式定义常量,可以起到注释作用.
```js
const userLevelCode = {
  Visitor: 10001,
  NonVIPUser: 10002,
  VIPUser: 10003,
  Admin: 10010,
  // ... 
}



fetchUserInfo({
  // ...
  // 后续维护者：这到底是个啥？？
  userCode: 10001
})

fetchUserInfo({
  // ...
  // 后续维护者：哦，这里要给访客用户啊
  userCode: userLevelCode.Visitor
})

```

在TS中提供了一个更好的定义常量的方式: 枚举.
```ts

enum UserLevelCode {
  Visitor = 10001,
  NonVIPUser = 10002,
  VIPUser = 10003,
  Admin = 10010,
  // ... 
}

```



## 函数类型

### 函数声明与函数表达式类型描述
```ts
function sum(a: number, b: number): number {
  return a + b;
}

const sum = function(a: number, b: number): number {
  return a + b;
};

```


### 函数表达式的另一种类型描述
使用变量类型标注的方式(`const sum:函数类型=...`)来标注函数表达式类型的.

1. 搭配类型别名
2. 使用变量类型标注方式给函数表达式进行类型标注
```ts
type Sum = (a: number, b: number) => number;

const sum: Sum = function(a,b) {
	return a + b;
}
```


### 函数返回值 void vs undefined
> 在 5.1 版本之前返回值类型标注为 undefined，就需要有显式的 return 语句.在之后，TS 对这个不符直觉的问题进行了修正，即允许了 undefined 作为无显式 return 语句函数的返回值类型，但考虑到发布时间较晚，因此还是有必要了解这个问题的。

```ts

// 5.1之前 返回undefined类型,需要显式使用return; 5.1版本之后,无需显式使用return
function handle(): undefined {
	//....
	return;
}

// void表示函数没有返回值
function handler1(): void {};
```



### 函数重载
> 是函数重载的概念，它指的就是根据不同的入参匹配不同的实际逻辑，实现一个函数名走天下。但是参数名称因为入参类型的多样,无法描述清楚.所以TS支持了类型层面的重载.

```js

function sum(x, y) {
  if (typeof x === 'number' && typeof y === 'number') {
    return x + y;
  } else if (Array.isArray(x) && typeof y === 'number') {
    return x.map((num) => num + y);
  } else if (typeof x === 'number' && Array.isArray(y)) {
    return y.map((num) => num + x);
  } else if (Array.isArray(x) && Array.isArray(y)) {
    if (x.length !== y.length) {
      throw new Error('Arrays must have the same length');
    }
    return x.map((num, index) => num + y[index]);
  } else {
    throw new Error('Invalid arguments');
  }
}

console.log(sum(2, 3)); // 5
console.log(sum([1, 2, 3], 4)); // [5, 6, 7]
console.log(sum(5, [1, 2, 3])); // [6, 7, 8]
console.log(sum([1, 2, 3], [4, 5, 6])); // [5, 7, 9]
console.log(sum('a', 'b')); // Error: Invalid arguments
console.log(sum([1, 2, 3], [4, 5])); // Error: Arrays must have the same length

```

```js
// 函数入参
function sum(numberOrArray, numberOrArray) { }

```


```ts
// 函数重载

function sum(base: number, incre: number): number;
function sum(baseArray: number[], incre: number): number[];
function sum(incre: number, baseArray: number[]): number[];
function sum(baseArray: number[], increArray: number[]): number[];
function sum(x: number | number[], y: number | number[]): number | number[] {
  if (typeof x === 'number' && typeof y === 'number') {
    return x + y;
  } else if (Array.isArray(x) && typeof y === 'number') {
    return x.map((num) => num + y);
  } else if (typeof x === 'number' && Array.isArray(y)) {
    return y.map((num) => num + x);
  } else if (Array.isArray(x) && Array.isArray(y)) {
    if (x.length !== y.length) {
      throw new Error('Arrays must have the same length');
    }
    return x.map((num, index) => num + y[index]);
  } else {
    throw new Error('Invalid arguments');
  }
}

```

> 需要注意的是，在标注了每一种可能的重载的方式以后，在最后那个实际实现的函数类型标注里，我们需要标注各个参数类型和返回值类型，使用上面所有重载可能出现的类型组成的联合类型。但实际上这最后一个函数类型标注并不会被调用方看到，在匹配到对应的调用时，我们就能够获取到与参数组合完全匹配的提示与类型保障：



> TypeScript 中的函数重载还是属于**伪重载**，它只能在类型层面帮你实现重载的效果，而实际的逻辑运行，由于 JavaScript 不支持，它也就束手无策了。真正的函数重载应该是直接定义多个同名的函数，这些函数的内部逻辑是仅服务一套参数组合的，比如上面的例子用 Java 改写：

```java
public class Calculator {
    public int add(int x, int y) {
        return x + y;
    }

    public int[] add(int[] x, int y) {
        // 省略内部实现
    }

    public int[] add(int x, int[] y) {
        // 省略内部实现
    }

    public int[] add(int[] x, int[] y) {
        // 省略内部实现
    }

    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        // 自动根据入参类型分发到对应的方法
        System.out.println(calculator.add(2, 3)); // 5
        System.out.println(Arrays.toString(calculator.add(new int[]{1, 2, 3}, 4))); // [5, 6, 7]
        System.out.println(Arrays.toString(calculator.add(5, new int[]{1, 2, 3}))); // [6, 7, 8]
        System.out.println(Arrays.toString(calculator.add(new int[]{1, 2, 3}, new int[]{4, 5, 6}))); // [5, 7, 9]
    }
}

```



## Class



### 面向过程与面向对象



### 两种方式的比较

> 你可以认为它们是实现同一种效果的不同手段而已。
>
> * 比如类比到做一锅黄焖鸡，
>   * 面向对象要求:你分别建立鸡肉对象、土豆对象、青椒对象、锅对象等等，这些对象携带着自己的信息，只要将它们组合在一起就是一道菜。
>   * 面向过程的范式则是，按照顺序逐步完成这道菜，依次备菜、起锅烧油、煎炒、焖等等。
> * 面向对象强调对象的组合交互; 面向过程强调程序的执行流程
> * 函数与 Class，分别是面向过程和面向对象这两种编程范式中的底层实现依赖。
>
> 



#### 面向对象

Class类如何体现面向对象的特点?

* 封装性:  它将一个对象相关的所有属性和方法封装在 Class 内部，供外界进行交互
* 继承

| 特性   | 面向对象                                                     | 面向过程                           |
| ------ | ------------------------------------------------------------ | ---------------------------------- |
| 封装性 | 一个对象相关的所有属性和方法封装在 Class 内部，供外界进行交互 | 需要通过一个个变量和函数来进行维护 |
| 继承性 | 实现继承                                                     |                                    |



```js
// 封装性


// 函数实现
const person1 = {
  name: 'Linbudu',
  age: 18
}

const getPersonDesc = (person) => {
  return `${person.name} at ${person.age} years old`;
}


// 类class实现
class Person {
  name;
  age;

  constructor(personName, personAge) {
    this.name = personName;
    this.age = personAge;
  }
  
  getDesc(): string {
    return `${this.name} at ${this.age} years old`;
  }
}

// 实例
const person1 = new Person("Linbudu", 18);
const person2 = new Person("Charles", 20);

person1.name; // Linbudu
person1.getDesc(); // Linbudu at 18 years old


// 继承
class School {}

class Student extends Person {
  grade: number;
  school: School;
}

class Job {}

class Worker extends Person {
  salary: number;
  job: Job;
}

```



### class中类型描述

#### 基本介绍

```ts
class Person {
  name: string;
  age: number;

  constructor(personName: string, personAge: number) {
    this.name = personName;
    this.age = personAge;
  }

  getDesc(): string {
    return `${this.name} at ${this.age} years old`;
  }
}

const person = new Person("Linbudu", 18);

console.log(person.getDesc()); // Linbudu at 18 years old

```



#### 类中的重载

```ts
class Person {
  feedPet(catFood: CatFood): void;
  feedPet(dogFood: DogFood): void;
  feedPet(rabbitFood: RabbitFood): void;
  feedPet(food: CatFood | DogFood | RabbitFood): void {}
}

```





#### 作为工具方法的命名空间

例如,可能会在 utils 文件夹下封装很多通用的函数,果这些工具方法都放置在一个文件内部，那使用起来就可能显得混乱.可以考虑使用 Class ，将一批功能类似的方法收拢到一个 Class 内部：

```ts
// util文件 显得混乱

export function isSameDate(){ } // 判断两个日期是否是同一天

export function diffDate(){ } // 判断两个日期的差值

export function getRandomInt(){ } // 获取随机整数

// ...


// util文件 使用class命令空间
export class DateUtils {
  static isSameDate(){ }  // 静态成员
  static diffDate(){ }
}

export class NumberUtils { }
export class UserListUtils { }
// ...



//导入文件并使用
import { DateUtils } from './utils';

DateUtils.isSameDate();

```







## any unknow 类型断言

### any

> 在我们不知道对一个变量提供何种类型时，就可以使用 any 类型来作为临时性的过渡方案
>
> any 类型 = 万能类型 + 放弃类型检查

```ts
let x: any;

function myFunc(param: any): any { ... }

const myArray: any[] = [1, "hello", true];

let myObject: any = { prop1: "hello", prop2: 123 };

```



### unknow

> unknow类型 = 万能类型 + 保留类型检查

```ts
function myFunc(param: unknown) {
  // ...
}

myFunc({});
myFunc([]);
myFunc(true);

```



### 类型断言

它能够修改一个变量的类型——无论是TS自己推导的，还是你手动标注的。



#### 将非具体类型断言为具体类型

```ts
// unknow类型报错

function myFunc(param: unknown) {
  param.forEach((element) => {}); // X “param”的类型为“未知”。
}

// 使用类型断言解决unknow类型报错的问题
function myFunc(param: unknown) {
  (param as unknown[]).forEach((element) => {});
}

```



```ts
// 第二个断言更能体现断言的意义: 

function myFunc(param: unknown) {
  (param as number[]).forEach((element) => {
    element = element + 1;
  });
}

function myFunc(param: unknown) {
  (param as unknown[]).forEach((element) => {
    element = (element as number) + 1;
  });
}

```





#### 将具体类型断言为非具体类型

将一个拥有具体类型的变量断言到 any / unknown 类型：

```ts
const str: string = "linbudu";

(str as any).handler().result.prop; // ...

```

> 为什么我们需要这么做？因为很多时候，你面临的项目中并不会是完全没有类型定义的，这些变量可能最开始也是被维护者精心设计了类型的，但随着项目的不断迭代和维护者的更替，它们才日渐年久失修，导致你在使用这些变量时需要面对大量的类型报错。所以这个时候我们就可以请出类型断言，先将其断言到一个万能类型，然后就重复我们上面学习的，随着一步步调用不断完善类型，然后最后回头补全的过程。



#### 类型断言实践

```ts
interface IUser {
  name: string;
  job?: IJob;
}

interface IJob {
  title: string;
}

const user: IUser = {
  name: 'foo',
  job: {
    title: 'bar',
  },
};

const { name, job = {} } = user;

const { title } = job; // 类型“{}”上不存在属性“title”。

```

由于我们在第一次解构赋值时，为 job 提供了一个空对象作为默认值，TypeScript 会认为此时 job 的类型就是一个空对象，所以我们在第二次解构赋值时，就无法从 job 上获得 title 属性了。要解决这个问题，我们可以在第一次解构赋值时将这个空对象断言到预期的类型：

```ts
const { name, job = {} as IJob } = user;

const { title } = job;

```



## 类型别名,联合类型,交叉类型



### 类型别名

在 TypeScript 中，类型别名起到的就是变量(引用,复用)的作用，它可以存储一个类型，后续你可以直接引用它即可。

#### 使用场景

##### 1.引用复用

```ts
type Handler = () => void;

const handler1: Handler = () => {};
const handler2: Handler = () => {};

```

##### 2.替换接口,实现对对象类型的复用

```ts
type User =  {
  userName: string;
  userAge: number;
  userMarried: boolean;
  userJob?: string;
}

const user: User = { /* ... */ }

```



### 联合类型

#### 语法

定义一个联合类型，需要使用类型别名来存放：

```ts
//语法

A | B | C

// 定义
type PossibleType = string | number | boolean;

// 使用

let foo: PossibleType = 'lin';
foo = 599;
foo = true;

```

#### 使用场景

联合类型对其中的类型成员并没有限制，你可以混合原始类型，字面量类型，函数类型，对象类型等等等等。而在实际应用中，最常见的应该是**字面量联合类型**，它表示一组精确的字面量类型：

##### 字面量联合类型

```ts

type Status = 'success' | 'failure';
type Code = 200 | 404 | 502;

```



##### 接口联合类型

```ts
interface VisitorUser {}
interface CommonUser {}
interface VIPUser {}
interface AdminUser {}

type User = VisitorUser | CommonUser | VIPUser | AdminUser;

const user: User = {
  // ...任意实现一个组成的对象类型
}

```



### 字面量类型

#### 是什么

> 字面量类型是和原始类型以及对象类型对应的.可以将**字面量类型**作为标注类型. 相比它们对应的原始类型，能够提供更精确的类型信息与类型提示.



将变量类型约束在几个特定的字符串值之间.表达“这个变量是字符串类型”和“这个变量只能是'xxx'这个字符串”这两个概念.

```ts
type Status = 'success' | 'failure'; // 组成Status 的这两个“值”，其实就是字面量类型
type Code = 200 | 404 | 502;

const literalString: 'linbudu' = 'linbudu';
const literalNumber: 599 = 599;
const literalBoolean: true = true;
const literalObject: { name: 'linbudu' } = { name: 'linbudu' };
const literalArray: [1, 2, 3] = [1, 2, 3];

```



### 交叉类型

交叉类型的本质，其实就是表示一个同时满足这些子类型成员的类型，所以如果你交叉两个对象类型，可以理解为是一个新的类型内部合并了这两个对象类型. 使用`&`实现交叉类型.

```ts
interface UserBasicInfo {}
interface UserJobInfo {}
interface UserFamilyInfo {}

type UserInfo = UserBasicInfo & UserJobInfo & UserFamilyInfo;

// 类型别名UserInfo表示,需要实现3个对象的所有属性.
```



注意事项:

交叉类型结果为`never`类型(没有任何意义的类型)

```ts
type Test = string & number; // never 类型

```



#### 使用

##### 交叉类型和联合类型同时使用

先交叉再联合

```ts
// 伪代码
type Reward = (FE & React) | (OutstandingAuthors & PostLastMonth);

```

先联合再交叉

```ts
type UnionIntersection = (1 | 2 | 3) & (1 | 2); // 1 | 2
```























