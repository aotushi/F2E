# 云开发简介



## 是什么

云开发可以为Web、小程序、移动应用等提供可靠、丰富的一站式后端能力，并提供多语言 [SDK](https://www.okta.com/identity-101/what-is-an-sdk/)，轻松开发多端应用。

简单的说，就是云开发是一套综合类服务的技术产品，通常开发一个完整的应用（小程序也好，Web、移动应用也好）都需要数据库、存储、CDN、后端函数、静态托管、用户登录等等，但是云开发将这些服务都集成到了一起，而且以一种全新的开发方式，让开发一个应用更加快速、方便、便宜且强大，引领未来技术开发的新趋势。

云开发主要集成的服务以及相关说明如下，这些都会在后面有实战型的深入介绍：

- 云数据库：它是一个性能强大的文档型数据库（非关系型数据库），支持基础读写、聚合搜索、数据库事务、实时推送等功能；
- 云函数：云函数可以以函数的形式运行后端代码，支持SDK的调用或HTTP请求。云函数存储在云端，可以根据函数的使用情况，自动扩缩容；
- 云存储：云开发的云存储提供稳定、安全、低成本、简单易用的云端存储服务，支持任意数量和形式的非结构化数据存储，如图片、文档、音频、视频、文件等；
- 云调用：云调用是云开发提供的基于云函数使用小程序开放接口以及腾讯云的能力，支持在云函数调用服务端开放接口，如发送模板消息、获取小程序码等操作都可以在云函数中完成；



# 项目的创建于配置

要开始小程序云开发，首先就需要先注册一个小程序，开通云开发服务，然后下载开发者工具和翻阅小程序开发与云开发的技术文档。除此之外，还需要在创建云开发项目时，注意一些配置的细节。

## 注册微信小程序

小程序的注册非常方便，打开小程序注册页面，按照要求填入个人的信息，验证邮箱和手机号，扫描二维码绑定你的微信号即可，3分钟左右的时间即可搞定。

**注册页面：**[小程序注册页面](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fwxopen%2Fwaregister%3Faction%3Dstep1)

> 注册小程序时不能使用注册过微信公众号、微信开放平台的邮箱哦，也就是需要你使用一个其他邮箱才行。小程序和微信公众号的登录页都是同一个页面，他们会根据你的不同的注册邮箱来进行跳转。

当我们注册成功后，就可以自动登入到小程序的后台管理页面啦，如果你不小心关掉了后台页面，也可以点击小程序后台管理登录页进行登录。

如果退出了,可以通过[微信公众平台](https://mp.weixin.qq.com/)扫码登录.

进入到小程序的后台管理页后，点击左侧菜单的**开发**进入设置页，然后再点击**开发设置**，在**开发者ID**里就可以看到**AppID(小程序ID)**，这个待会我们有用。



## 开发者工具与云开发文档

### 开发者工具的下载与安装

一般选择稳定版 Stable Build的开发者工具。但是如果你想尝试小程序或者云开发发布的新功能，建议选择下载预发布版RC Build和开发版Nightly Build。

**开发者工具**：[小程序开发者工具下载地址](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fdownload.html)

由于小程序以及云开发在不断新增功能，更新非常频繁，而它的很多更新与开发者工具有着非常紧密的联系，所以要确保自己的开发者工具是最新的。

我们可以在开发者工具的顶部看到当前开发者工具的版本号，注意版本号里包含着日期，比如`1.04.2008042`，这里20是2020年，0804是8月4日的版本，如果你的版本号太低注意及时更新。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fe94fed32ae4a748a8d118ec17cf762~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



### 云开发文档

技术文档大家先只需要**花五分钟左右的时间**了解大致的结构即可，**然后按照我们的教学步骤再来翻阅具体的知识细节**。

**技术文档：**[云开发官方文档](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fwxcloud%2Fbasis%2Fgetting-started.html)



#### 创建云开发模板小程序

下载安装完**小程序开发者工具**之后，我们使用微信扫码登录开发者工具，然后使用开发者工具新建一个小程序的项目：

- **项目名称**：这个可以根据自己的需要任意填写；
- **目录**：大家可以先在电脑上新建一个空文件夹，然后选择它；
- **AppID**：就是之前我们找到的**AppID(小程序ID)**（也可以下拉选择AppID），这里不能使用测试号哦；
- **开发模式**为小程序（默认）；
- **后端服务**选择**小程序·云开发**



### 云开发项目初始化

#### 开通云开发

点击微信开发者工具的“**云开发**”图标（在左上角界面设计(interface designer)图标的右边），在弹出框里点击“**开通**”，同意协议后，会弹出**创建环境**的对话框。这时会要求你输入**环境名称**，以及当前云开发的基础环境配额（建议选择“按量付费”，或者默认即可）。(环境名称点击下拉框,可以新建也可以管理云环境)

按照对话框提示的要求填写完之后，点击**创建**，会初始化环境，环境初始化成功后会自动弹出云开发控制台，这样我们的云开发服务就开通啦。大家可以花**两分钟左右**的时间熟悉一下云开发控制台的界面。

#### 找到云开发的环境ID

点击云开发控制台窗口右侧的**设置(setting)**图标，在**环境变量**的标签页找到**环境名称**和**环境ID**。

> 用户在开通云开发之后就创建了一个云开发环境，微信小程序可拥有最多两个环境，每个环境都对应一整套独立的云开发资源，包括数据库、云存储、云函数、静态托管等，各个环境是相互独立的。每个环境都有一个唯一的环境ID（环境名称不唯一）。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eec399585564598889a8c9fc7130a2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



#### 指定开发者工具的云开发环境

当云开发服务开通后，我们可以在小程序源代码cloudfunctions文件夹名看到你的环境名称。如果在cloudfunctions文件夹名显示的不是环境名称，而是“**未指定环境**”，可以鼠标右键该文件夹，可以看到弹窗的第一项为“当前环境”，有个小三角，在这里可以选择或切换已经建好的云开发环境。如果环境为空白，重启开发者工具，再来选择。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c0133f369d745dbabe51322315020fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



#### 指定小程序的云开发环境

在开发者工具中打开源代码文件夹**miniprogram**里的app.js文件，找到如下代码：

```js
wx.cloud.init({
  // env 参数说明：
  //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源
  //   此处请填入环境 ID, 环境 ID 可打开云控制台查看
  //   如不填则使用默认环境（第一个创建的环境）
  // env: 'my-env-id',
  traceUser: true,
})
```

在 `env: 'my-env-id'`处改成你的环境ID，注意需要填入的是你的环境ID而不是环境名称哦，结果如下：

```js
wx.cloud.init({
  env: 'xly-xrlur',
  traceUser: true,
})
```

> 因为云开发可以创建多个环境，比如微信小程序就可以创建两个免费的云开发环境，一个用于测试，一个用于正式发布。如果你没有在小程序端指定环境，会默认选择为你创建的第一个云开发环境。我们可以通过修改env的参数来切换小程序端用来调用的云开发环境。

云开发能力全局只需要初始化一次即可，这里的traceUser属性设置为true，会将用户访问记录到用户管理中，在云开发控制台的**运营分析**—**用户访问**里可以看到访问记录。



#### 基础库版本与开发者工具设置

除了开发者工具的版本，小程序以及云开发的能力都非常依赖基础库，如果开发者工具的基础库版本过低，就会出现很多API会报错；基础库的版本和微信iOS、安卓、PC和Mac的终端是有对应关系的，高版本的基础库无法兼容低版本的微信客户端，我们可以在开发者工具看到不同的基础库用户终端的占比情况。

点击开发者工具右上角的**详情**，在**本地设置**可以看到除了可以设置基础库以外，还有一些其他设置。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4824b0beda464ee2b15967ddb7ac97bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

- 果是为了体验功能，选择基础库时当然是越高越好，更高版本的基础库意味着更多的功能支持以及更少的bug，基础库新增了哪些功能，做了哪些改动，可以阅读了解一下[基础库的更新日志](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Frelease%2Fv2.html)；不过实际使用时，要考虑用户的分布情况；
- 增强编译可以增强ES6转ES5的能力，小程序端就能支持大部分es6等一些JavaScript的语法，比如表常用的async/await；
- 建议在学习时，勾选“不校验合法域名、业务域名、TLS版本以及HTTPS证书”，让小程序支持调试外部链接；

> 基础库的版本是进行小程序云开发时不容忽视的一个问题，因为基础库版本在不断更新，我们之前开发的项目的基础库的版本可能会大大落后于现有使用最多的基础库版本，在我们使用新的开发者工具进行调试时，可能会出现一些报错；或由于没有更新基础库版本，导致有些新功能使用不了，这个一定要注意。



# 云开发资源的管理

对于初学者来说，我们可以使用微信开发者工具自带的云开发控制台以及腾讯云云开发网页控制台来管理、配置以及监控云开发的云存储、云函数、云调用等云开发资源。

## 两个可视化控制台

### 小程序云开发控制台

开通了云开发服务之后，我们就可以打开微信开发者工具自带的小程序云开发控制台了。能否打开云开发控制台，也是检验你在上一节创建云开发项目时是否出现问题的一个方式。云开发控制台可以可视化管理云开发的资源。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3469e61f9165462dab243aaf545f786e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



云开发控制台有几个模块标签，分别为运营分析、数据库、存储、云函数、静态网站托管、设置、费用管理、工单，我们也可以通过点击这些标签来对云开发有一个大致的了解。

- 运营分析标签：可以查看资源的使用统计，查看小程序的用户访问记录以及云开发资源的总体使用情况；
- 数据库标签：管理数据库集合、记录、权限设置、索引设置以及高级操作的脚本；
- 存储标签：管理云存储空间的文件、权限设置等；
- 云函数标签：管理云函数、查看调用日志、进行云函数的云端测试等





### 腾讯云云开发网页控制台

我们还可以使用[腾讯云云开发网页控制台](https://link.juejin.cn/?target=https%3A%2F%2Fconsole.cloud.tencent.com%2Ftcb)来管理云开发资源，需要注意两点，一个是登录方式需要选择**其他登录方式里的微信公众号**，点击然后使用手机微信扫码，在微信上选择你要登录的小程序；二是要进入腾讯云后台之后切换选择云开发Cloudbase。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf5be222c65d4bc6ad2210c2e9ed1338~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

可以留意图片的登录地址，以及如何切换到后台。腾讯云需要实名认证，这个按照要求操作即可。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc35c58be25b42838fc26472a8849a86~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)





### SDK与HTTP API

除了可以使用可视化管理平台，云开发还提供微信小程序、QQ小程序、Web 应用、Flutter等应用SDK、服务端SDK、管理端SDK和HTTP API来访问云开发资源，而我们在进行微信小程序的云开发时，主要使用的是微信小程序的SDK以及服务端SDK（云函数端）。

尽管微信小程序的云开发技术文档把小程序SDK和云函数端的SDK整合到了一起，而且两者用法也比较一致，但是它们还是有一些区别，一是权限上的区别，二是用法上的区别，这个后面会介绍，还有就是有一些API只支持小程序端或只支持云函数端，这个在使用的时候要注意区分。







### 其他工具与方式

云开发资源还支持其他方式来调用，学有余力的同学可以进行拓展学习：

- CloudBase CLI：我们可以使用云开发提供的命令行工具 [CloudBase CLI](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.cloudbase.net%2Fcli%2Fintro.html) 对云开发环境里面的资源进行批量管理，比如云函数批量下载更新；云存储里面的文件夹批量下载和上传等等；
- 管理端SDK：我们可以将管理端 [manager-node SDK](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.cloudbase.net%2Fapi-reference%2Fmanager%2Fnode%2Fintroduction.html) 部署在本地、云端服务器甚至云函数里对云开发环境里面的资源进行批量管理；
- Tencent CloudBase Toolkit：Tencent CloudBase Toolkit是一款Visual Studio Code的云开发插件，使用这个插件可以更好地在本地进行云开发项目开发和代码调试，并且轻松将项目部署到云端；



# 云函数的配置与部署

















# 生命周期



## 是什么

> 生命周期指的是小程序App和页面Page从被打开到被关闭、卸载的过程，这个过程包含多个有顺序的阶段，比如初始化、资源是否加载完成、页面是否被显示、用户是否将小程序或页面切换到了后台、用户是否卸载了页面等。



## 构造器

> 生命周期指的是小程序App和页面Page从被打开到被关闭、卸载的过程，这个过程包含多个有顺序的阶段，比如初始化、资源是否加载完成、页面是否被显示、用户是否将小程序或页面切换到了后台、用户是否卸载了页面等。



### 小程序构造器和页面构造器

App() 必须在 app.js 中调用，必须调用且只能调用一次，从技术文档我们可以了解小程序构造器有如下属性与方法

```js
App({
  onLaunch: function (options) { //监听小程序初始化
  },
  onShow:function(options){      //监听小程序启动或切前台
  },
  onHide:function(){      //监听小程序切后台
  },
  onError:function(msg){     //错误监听函数     
  },
  onPageNotFound:function(){ //页面不存在监听函数
  },
  onUnhandledRejection:function(){//未处理的 Promise 拒绝事件监听函数   
  },
  onThemeChange:function(){//监听系统主题变化
  }
})
```



Page()则需要写在每个小程序页面的js文件里面来注册小程序中的一个页面，页面构造器有如下属性和方法，而其中onLoad、onShow等就是页面的生命周期函数：

```js
Page({
  data: {//页面的初始数据
  },
  onLoad: function(options) {//监听页面加载
  },
  onShow: function() {//监听页面显示
  },
  onReady: function() {//监听页面初次渲染完成
  },
  onHide: function() {//监听页面隐藏
  },
  onUnload: function() {//监听页面卸载
  },
  onPullDownRefresh: function() {//监听用户下拉动作
  },
  onReachBottom: function() {//页面上拉触底事件的处理函数
  },
  onShareAppMessage: function () {//用户点击右上角转发
  },
  onPageScroll: function() {//页面滚动触发事件的处理函数
  },
  onResize: function() {//页面尺寸改变时触发
  },
  onTabItemTap:function(){//当前是 tab 页时，点击 tab 时触发
  }
})
```



### 页面全局变量

我们可以在`Page({})`对象前添加一些变量，比如我们声明了一个user变量：

user变量可以在Page({})对象的生命周期函数里访问，因为user变量定义在了Page之外，它是整个页面的全局变量

```js
const user = {name:"李东bbsky",address:"深圳"} 
console.log(user.address) //之前介绍过，这里可以访问user对象
Page({
  data: {
    title:"技术杂役"
  },
  onLoad: function(options) {
    console.log(this.data.title)
    console.log(user.name)  //在生命周期函数里访问user对象
  },
})
```



### 页面全局变量变种

全局变量也是相对的，比如我们把变量声明在Page外，这个变量就是Page的全局变量，而有些变量我们可以声明在生命周期函数或事件处理函数的里，如在页面的js里执行以下代码:

对于`this.setData`而言，movielist就是一个全局变量。

```js
Page({
  data: {
    title:""
  },

  onLoad: function (options) {
    const movielist=["肖申克的救赎","霸王别姬","这个杀手不太冷"]
    this.setData({
      title:movielist[1]
    })
    console.log(this.data.title)
  },
})
```



## 生命周期函数

### 小程序生命周期

```js
onLaunch(opts) {
  console.log('onLaunch监听小程序初始化。',opts)  //全局只会触发一次
},
onShow(opts) {
  console.log('onShow监听小程序启动或切前台',opts) //会触发多次
},
onHide() {
  console.log('onHide监听小程序切后台')
},
```



### 页面生命周期

```js
onLoad: function(options) {
  console.log("onLoad监听页面加载",options)
},
onReady: function() {
  console.log("onReady监听页面初次渲染完成")
},
onShow: function() {
  console.log("onShow监听页面显示")
},
onHide: function() {
  console.log("onHide监听页面隐藏")
},
onUnload: function() {
  console.log("onUnload监听页面卸载")
},
```



### 生命周期函数调用api

只需要用户打开小程序、打开某个页面，把小程序切后台等情况时就能触发里面的函数。

例如在app.js的onLaunch生命周期函数里调用`wx.showLoading`的接口，表示小程序正在加载中：

```js
App({
  onLaunch: function () {
    wx.showLoading({
      title: "正在加载中",
    })
  },
  globalData: {

  }
})
```

执行之后我们会发现”正在加载中“的loading动画一直都会在，因为我们需要在表示资源加载完成的生命周期函数里调用`wx.hideLoading`来隐藏这个loading动画，比如小程序 onShow 生命周期函数：

```js
App({
  onLaunch: function () {
    wx.showLoading({
      title: "正在加载中",
    })
  },
  onShow (options) {
    wx.hideLoading({
      success: (res) => {
        console.log("加载完成，所以隐藏掉了")
      },
    })
  },
  globalData: {

  }
})
```



### 小程序进入场景值

在App的onLaunch和onShow打印的对象里有一个scene为1001，这个是场景值。场景值用来描述用户进入小程序的路径方式。用户进入你的小程序的方式有很多，比如有的是扫描二维码、有的是长按图片识别二维码，有的是通过微信群进入的小程序，有的是朋友单聊进入的小程序，有的是通过公众号进入的小程序等等，这些就是场景值，而具体的场景值，可以看技术文档，场景值对产品、运营来说非常重要。

**技术文档：**[场景值列表](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Freference%2Fscene-list.html)

```js
App({
  onLaunch: function (options) {
    console.log('打印小程序启动时的参数',options)
  },
})
```

在options对象里就包含secne这个属性值

```js
path: "" //页面路径
query: {} //页面的参数
referrerInfo: {} //来源小程序、公众号或 App 的 appId
scene: 1047 //场景值
shareTicket: //带 shareTicket 的转发可以获取到更多的转发信息，例如群聊的名称以及群的标识 openGId
```





# 小程序函数与调用



## 给构造器添加函数或数据变量

### 小程序的全局变量

可以在app.js的App({})里添加一个数据变量globalData对象、tcbData对象来存放整个小程序都会使用到的数据：

```js
App({
  globalData: {
    userInfo:{
      username:"李东bbsky",
      title:"杂役"
    }
  },

  tcbData: {
    title:"云开发训练营",
    year:2019,
    company:"腾讯Tencent"
  },
})
```



### 小程序的全局变量调用

需要用到`getApp()`来获取小程序全局唯一的App实例，就可以在其他任意页面调用到app.js里声明的数据变量了。

```js
const app = getApp() 

//在Page外调用
console.log(app.globalData.userInfo.username)
console.log(app.tcbData.title)
console.log(app)
Page({
  //在data对象里调用
  data: {
    userInfo:app.globalData.userInfo
  },

  //在生命周期函数里面调用
  onLoad: function (options) {
    console.log(app.globalData.userInfo.username)
    console.log(app.tcbData.title)
    console.log(app)
    console.log(this.data.userInfo)
  }
})
```

如果我们想在app.js里调用globalData、tcbData对象里的数据，只需要使用this即可，不要使用`getApp()`。



### 函数的调用

有的时候要执行一个功能需要写很多个函数，或者有时候我们希望能够把一些特定的功能给封装成一个函数，如果把这些函数整个都写到生命周期函数或事件处理函数里面来调用就很不方便了。

比如一个博客小程序每篇文章发布成功之后，最好给用户一个发布成功的反馈以及会返回上一页，也就是一个功能里面需要执行多个函数，而且这个功能还比较常用，我们可以用如下方式：

```js
Page({
  onLoad: function (options) {
    this.publishSuc() //this调用的是我们封装好的函数publishSuc
  },

  publishSuc(){
    wx.showToast({
      title: '文章发布成功',
      icon: 'success',
      duration: 1000
    },
    setTimeout(function() {
			wx.navigateBack({
				delta: 1
			})
		},2000))
  }
})
```

上面的案例没有给函数传递参数，回顾前面形参和实参的知识，我们可以在调用函数的时候用如下的方法传递参数，message和title的名称虽然不一样，但是也没有关系：

```js
Page({
  onLoad: function (options) {
    const message = "发布失败"
    this.publishSuc(message)
  },

  publishSuc(title){
    wx.showToast({
      title: title,
      icon: 'success',
      duration: 1000
    })
  }
})
```

> 在小程序页面的js文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。



# 用户登录与信息获取

## 了解wx.login wx.getSetting

```js
App({
  onLaunch: function () {
    wx.login({
      success(res){
        console.log('wx.login得到的数据',res)
      }
    })
 
    wx.getSetting({
      success(res){
        console.log('wx.getSetting得到的数据',res)
      }
    })
  },
 
  globalData: {
    userInfo: null
  }
})
```



wx.login返回的res对象里会包含errMsg和code，这个code是用户的登录凭证。

wx.getSetting返回的res对象里包含errMsg和用户当前的[权限设置authSetting](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Fsetting%2FAuthSetting.html)，包含是否允许获取用户信息，是否允许获取用户位置，是否允许使用手机相册等权限。我们可以根据打印的结果结合技术文档来深入理解。

**技术文档：**[获取用户登录凭证wx.login](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Flogin%2Fwx.login.html)

**技术文档：**[获取用户登录凭证wx.login](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Flogin%2Fwx.login.html)

> 如果要让小程序和自己的服务器账号打通，仅仅获取用户登录凭证是不够的，需要将这个code以及你的小程序appid和appSecret传回到你的开发服务器，然后在自己的服务器上调用[auth.code2session](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi-backend%2Fopen-api%2Flogin%2Fauth.code2Session.html)接口，得到用户的openid和session_key。由于openid是当前用户的唯一标识，可以用来判断该用户是否已经在自己的服务器上注册过，如果注册过，则根据openid生成自定义登录态并返回给小程序，整个过程非常复杂。
>
> 而由于**云开发与微信登录鉴权无缝整合**，这些内容都不会涉及，所以这里不多介绍。



## 获取用户信息wx.getUserInfo

我们要获取用户信息，首先需要判断用户是否允许，可以从authSetting对象里看scope.userInfo属性是否为true，如果为true，那我们可以调用wx.getUserInfo()接口来获取用户信息。

使用开发者工具给上面的wx.getSetting()函数添加内容，最终代码如下：

```js
wx.getSetting({
  success(res) {
    console.log('wx.getSetting得到的数据', res)
    if (res.authSetting['scope.userInfo']) {
      wx.getUserInfo({
        success(res) {
          console.log('wx.getUserInfo得到的数据: ', res)
        }
      })
    }
  }
})
```



## globalData

用户信息的数据是所有页面都需要用到的，放在**app.js**里公用是应该的，但是我们要怎么才能调用到这个数据呢？

在上面的wx.getUserInfo的success回调函数里将获取到的userInfo对象赋值给globalData对象的userInfo属性。

```js
wx.getUserInfo({
    success(res){
    console.log("wx.getUserInfo得到的数据",res)
    this.globalData.userInfo = res.userInfo
  }
})
```

但是会提示 `Cannot read property 'globalData' of undefined;`报错



### 无法访问this的解决方案

#### 使用箭头函数

```js
wx.getSetting({
  success: (res) => {
      if (res.authSetting['scope.userInfo']) {
        wx.getUserInfo({
          success(res) {
            that.globalData.userInfo = res.userInfo
          }
        })
      }
  }
})
```





#### 使用变量that

```js
let that = this;    
wx.getSetting({
      success(res) {
        if (res.authSetting['scope.userInfo']) {
          wx.getUserInfo({
            success(res) {s
              that.globalData.userInfo = res.userInfo
            }
          })
        }
      } 
    })
```



## getApp()

如何在页面的js里调用globalData呢，这个时候就需要用到getApp()函数啦。

**技术文档：**[getApp()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Freference%2Fapi%2FgetApp.html)

例如我们在user页面中访问globalData中的数据.

在user.js的Page()函数前面添加如下代码：

```js
let app = getApp()
console.log('user页面打印的app', app)
console.log('user页面打印的globalData', app.globalData.userInfo)
console.log('user页面打印的tcbData',app.tcbData.eventInfo)
```

这样我们就能获取app.js里的globalData和自定义的属性了。

> 这里还会有一个问题，就是尽管我们已经获取到了globalData，我们也能在globalData.userInfo的打印日志里看到用户的信息，但是当我们想获取里面的值时，还是会报错，这是因为 wx.getUserInfo是异步获取的信息，这里涉及到的异步，我们之后会详细介绍。





## 通过button获取用户信息

 在我们使用wx.getUserInfo的方式来获取用户信息时，控制台会报错：获取 wx.getUserInfo 接口后续将不再出现授权弹窗，请注意升级。也就是小程序官方已经不建议开发者用wx.getUserInfo来获取用户信息，而是建议通过button的方式来获取，对用户的体验更好，也就是**只有用户点击了按钮，用户信息才会被获取**。

创建一个button组件，要获取到用户信息，有两个必备条件，一是 open-type="getUserInfo"，必须是这个值；二是绑定事件处理函数的属性名为bindgetuserinfo（类似于bindtap，但是属性名必须为bindgetuserinfo，至于事件处理函数的名称可以自定义）

```js
<button open-type="getUserInfo" bindgetuserinfo="getUserInfomation"> 点击获取用户信息 </button>
```

这里的getUserInfomation和之前点击事件的事件处理函数是一致的，点击组件触发getUserInfomation，仍然会收到事件对象，我们把它打印出来，在user.js里添加以下代码：

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
},
```

当我们点击“**点击获取用户信息**”的button按钮后，在控制台可以查看到getUserInfomation打印的事件对象，事件对象里有个detail属性，里面就有userInfo的数据.

页面中获取用户信息的固定套路:

1.首先在页面中data对象中初始化一个userInfo对象,用来接收数据

```js
data: {
  userInfo: {}
}
```

2.然后在事件处理函数getUserInfomation获取到的userInfo通过this.setData赋值给它，也就是getUserInfomation的函数为

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
  this.setData({ 
    userInfo: event.detail.userInfo, 
  })
},
```

3.获取到用户信息,可以在wxml文件中使用

```js
<view>{{userInfo.nickName}}</view>
<view>{{userInfo.country}}</view>
<image mode="widthFix" style="width:64px;height:64px" src="{{userInfo.avatarUrl}}"></image>
```



## 将用户信息写进app.js

上面这种方式只能在页面中才能获取到用户信息，限制非常大，那我们应该怎么做呢？

我们要把获取到的用户信息写到app.js成为页面的公共信息，以后可以跨页面只需在user页面点击一次按钮即可。

在getUserInfomation将获取到的用户信息传给globalData的userInfo属性：

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
  app.globalData.userInfo = event.detail.userInfo
  this.setData({ 
    userInfo: event.detail.userInfo, 
  })
},
```



> 获取用户信息还有一种方式，就是通过组件`<open-data>`来展示







# 云函数

> 云函数可以以函数的形式自动运行后端代码以响应API调用和HTTPS触发的事件，开发者只需关注业务代码本书，无需关心后端运维、计算资源等，平台会根据负载自动进行扩缩容。各个云函数相互独立，执行环境相互隔离。



## 云函数快速入门

云函数在操作上与以往的开发方式会有所不同，不过它依然还是JavaScript知识的应用。在这一章，我们会来讲解云函数如何新建、如何部署、如何调用，在操作上我们需要注意哪些细节等。



### 云函数的新建和调用

#### 新建一个云函数

使用开发者工具，鼠标右键云函数根目录如cloudfunctions，在弹出的窗口选择**新建Node.js云函数**，然后输入云函数的名称比如`sum`(可以先右键同步云函数列表，保证没有重名),按Enter确认后，微信开发者工具会在本地（你的电脑）创建出**sum云函数目录**，同时也会在线上环境中创建出对应的云函数（也就是自动部署好了，可以到云开发控制台云函数列表里看到）。

```md
cloudfunctions //云函数根目录       
├── sum // 云函数目录
│   └── index.js 
│   └── config.json
│   └── package.json  //云函数的Node包管理
miniprogram //小程序根目录  
├── ...    
```

打开sum云函数目录下的index.js并将里面的代码修改为如下，然后右键index.js文件，选择**云函数增量上传:（更新文件）**，这样一个用来求两个参数之和的云函数就更新好了：

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV }) // 使用当前云环境

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  const sum = event.a + event.b
  return {
    sum,
    event,
    openid: wxContext.OPENID,
    appid: wxContext.APPID,
    unionid: wxContext.UNIONID,

  }
}
```

这里的`event`对象指的是触发云函数的事件，在小程序端调用时，`event`是小程序端调用云函数时传入的参数对象，也就是说要计算`sum`，我们需要在小程序端调用云函数时传入两个参数`a`和`b`。



#### 云函数的调用

在小程序中调用这个云函数前，我们还需要先将该云函数部署到云端。在云函数目录上右键，在右键菜单中，我们可以将云函数整体打包上传并部署到线上环境中。

部署完成后，我们可以在小程序中调用该云函数.

要调用云函数有**很多种方式**，比如我们可以在调试器的console控制台调用接口、在生命周期函数里调用，还可以通过组件绑定一个事件处理函数来调用等等，这些方式都是大同小异，都是在调用`wx.cloud.callFunction()`接口。

两种调用方式:

```js
wx.cloud.callFunction({
  // 云函数名称
  name: 'add',
  // 传给云函数的参数
  data: {
    a: 1,
    b: 2,
  },
  success: function(res) {
    console.log(res.result) // 3
  },
  fail: console.error
})
```



```js
wx.cloud.callFunction({
  name: 'sum',    // 要调用的云函数名称，这里为sum
  data: {         // 传递给云函数的event参数，这里为a和b
    a: 15,
    b: 23,
  }
}).then(res => {
  console.log("云函数返回的结果",res.result)
}).catch(err => {
  console.log("云函数调用失败",err)
})
```

返回值res.result就是云函数返回的对象.



#### 云函数的返回值与渲染

使用开发者工具将sum云函数的代码修改为如下，我们让云函数返回更多类型的数据，修改完之后，右键index.js文件，选择**云函数增量上传:（更新文件）**：

```js
```

> 值得注意的是，云函数返回的时间和小程序端返回的时间(北京时间)是不一样的，这是因为云函数中的时区为 UTC+0，不是 UTC+8，格式化得到的时间和在国内的时间是有8个小时的时间差，但是时区不会影响时间戳，所以尽量不要在云函数端将时间字符串化。



### 云函数的初始化

#### 关于wx-server-sdk

wx-server-sdk是微信小程序服务器端的SDK，SDK包括用于微信免鉴权的私有协议、云数据库、云存储、云调用等基础能力，因此每一个云函数都会使用到wx-server-sdk这个Node包。由于每个云函数实例之间是相互隔离的（没有公用的内存或硬盘空间），所以每个云函数都要求**单独**安装wx-server-sdk，Node包在云函数实例之间不存在复用的关系。而要调用这个包都需要安装好Node.js环境才能在本地电脑的开发者工具进行本地调试。

给云函数安装依赖时，在开发者工具上右键云函数目录如sum，选择开发者工具自带的终端（更建议）或外部终端窗口，直接输入`npm install`即可。npm包管理器自动会安装好package.json的dependencies写好的包，可以将wx-server-sdk的版本号换成latest（生产环境以稳定兼容的版本为准）：

```json
"dependencies": {
  "wx-server-sdk": "latest"
}
```

sum安装好node依赖之后，就会在云函数目录里有一个node_modules的文件夹。当我们要将本地的云函数部署到云开发环境时，可以右键云函数目录选择**上传并部署所有文件**（更建议）或**上传并部署：云端安装依赖（不上传node_modules）**。

如果云函数本地没有安装依赖，就没法在开发者工具对云函数进行本地调试，部署上传云函数时，选择**上传并部署所有文件**就会报错，截图如下：

![4bfa24048d6f487b995a613ddbc5dc34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp (996×364) (byteimg.com)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bfa24048d6f487b995a613ddbc5dc34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

wx-server-sdk只是云函数必备的一个依赖，云函数还可以通过package.json安装更多功能丰富的Node包。当在package.json里新增了其他依赖时，都需要使用`npm install`进行依赖的下载。



#### 云函数的初始化

在云函数中调用其他API前，同小程序端一样，也需要执行一次初始化方法，首先使用require引入wx-server-sdk依赖，然后在初始化`cloud.init()`中指定云开发的环境，方法如下：

```js
const cloud = require('wx-server-sdk')
// 给定字符串环境 ID：接下来的 API 调用都将请求到环境 some-env-id
cloud.init({
  env: 'some-env-id'
})
```

或者

```js
const cloud = require('wx-server-sdk')
// 给定 DYNAMIC_CURRENT_ENV 常量：接下来的 API 调用都将请求到与该云函数当前所在环境相同的环境
// 请安装 wx-server-sdk v1.1.0 或以上以使用该常量
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
```



以上两种方法对应的的实际案例:

```js
//方法一，直接使用字符串envId指定环境
const cloud = require('wx-server-sdk')
cloud.init({
  env: 'xly-9gssrn8d637383e4' //换成你的云函数envId
})

//方法二，使用cloud.DYNAMIC_CURRENT_ENV常量，也就是使用云函数当前所在环境
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV //注意它不是字符串，不要加引号
})
```

- 尽管直接使用`cloud.init()`不指定环境在某些特定情况下仍然可以使用，比如你的云函数就部署在你创建的第一个云开发环境里，但是非常不推荐这种写法；
- `cloud.DYNAMIC_CURRENT_ENV`标志的是云函数当前所在的环境，也就是你将云函数部署到哪个环境，它就是指哪个环境；
- 我们可以在云开发环境A直接调用同一个账号下云开发环境B的资源，只需要在云环境初始化时指定B的envId即可，在开发时切换生产环境、测试环境非常方便；
- 我们还可以在云函数里分别调用不同云开发环境里的云存储、云数据库、云函数等的资源，比如`env:{"database":"xly-xrlur","storage":"xly-1o7da","functions":"xly-oau0j"}`；
- 如果调用云函数时，提示`找不到对应的FunctionName`，可能是你的小程序账号之下有多个云开发环境，而你在云函数初始化时没有指定envId。



### 开发者工具右键操作说明

#### 同步云函数列表

当我们右键云函数根目录cloudfunctions时，会有一个**同步云函数列表**的选项，它可以拉取当前云开发环境所有云函数的列表，右键指定的云函数选择**下载**就可以将云端的代码给下载到本地电脑。也就是说，上传到云开发环境的云函数以及代码都会存储在云端，你可以在其他设备上通过这种方式进行同步，除非你在云开发控制台将这个云函数给删掉了。

当我们在开发者工具本地或使用云开发控制台将云函数删掉之后，**建议先同步云函数列表**，不然在重新上传部署同名的云函数的时会出现一些报错。





#### 新建Node.js云函数

选择**新建Node.js云函数**可以直接在云端新建一个云函数，同时会自动在云端给新建的云函数安装好wx-server-sdk依赖，并将该云函数在云端部署的情况反馈到开发者工具，即开发者工具本地的云函数目录图标会变色（注意区分同步和没有同步的云函数目录图标的不同）。



#### 增量上传? 



## 本地调试与云端测试

### 云函数的开发流程

为了能够让大家更加清楚的了解：**完整操作一个云函数的流程**以及**本地调试与云端测试的重要性**，我们以长方形的边长（a、b）求周长、面积这个简单的数学公式为例。

#### 新建云函数

首先我们右键点击**云函数根目录**（也就是**cloudfunctions文件夹**），选择**新建Node.js云函数**，函数名为长方形的英文rectangle，然后打开index.js，将代码修改为如下：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  const {width,height} = event
  console.log("长方形的周长与面积",[(width+height)*2,width*height])
  return {
    circum:(width+height)*2,
    area:width*height
  }
}
```

建好云函数之后，我们右键点击云函数目录，也就是rectangle文件夹，选择**在终端中打开**，使用npm install来安装依赖。

```bash
npm install
```



#### 本地调试云函数是否正确

对于一个复杂的云函数，我们最好是先在本地测试一下云函数是否正确，然后再部署上传到云端。

那如何本地测试呢？右键点击云函数目录，也就是rectangle文件夹，选择**本地调试**（这种方式进入本地调试会默认开启rectangle的本地调试）。

我们可以根据情况来选择**手动触发**和**模拟器触发**，使用手动触发需要我们在本地调试输入参数之后，点击**调用**：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7dfff165c7c4ff1b55c1bd7f2375c77~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们给参数宽度width和高度height赋值（**注意传递的是JSON格式，最后一个参数结尾不能有逗号,**），比如赋值为3和7：

```json
{
  "width": 3,
  "height":7
}
```

然后点击**调用**，如果显示函数执行成功(注意仍然是在调试的console标签)，并得到周长circum和面积area的结果分别为20、21，那证明云函数没有写错。

> 当开启了本地调试，我们在开发者工具调试器的console控制台（非本地调试的console标签页）调用云函数时也会调用本地的云函数。在本地调试窗口无论是选择手动触发、模拟器触发亦或是通过其他云函数来调用云函数，取决于你的云函数的调用方式，比如如果云函数调用是在页面的生命周期函数里调用，我们本地调试时就可以使用模拟器触发。



#### 云端测试云函数是否正确

云测试之前需要上传和部署, 之后打开**云开发控制台**的**云函数**标签，找到rectangle云函数，点击**云端测试**，同样我们给参数赋值，将以下代码进行修改，比如给宽度width赋值为4，高度height赋值为7，即代码修改为：

```js
{
  "width": 4,
  "height": 7
}
```

然后点击运行测试，（会等一段时间），再来查看测试的结果，如果返回结果如下，则表示在云端的云函数可以正常调用.



云函数的调用采用**事件触发模型，小程序端的调用、本地调试和云端测试**都会触发云函数的调用事件，其中本地调试调用的不是云端的云函数，而是小程序本地的云函数；而在云端测试调用云函数的结果是可以在云开发控制台云函数的日志里查看到的。

#### 云函数的在线编辑

上传到云端的云函数，我们还可以通过云开发的网页控制台（登录方式）在线修改代码。通过在线编辑，我们不仅可以检查代码是否更新成功，还可以脱离微信开发者工具、Cloudbase CLI等来临时修改代码。

**云开发网页登录**

> 我们还可以使用[腾讯云云开发网页控制台](https://link.juejin.cn/?target=https%3A%2F%2Fconsole.cloud.tencent.com%2Ftcb)来管理云开发资源，需要注意两点，一个是登录方式需要选择**其他登录方式里的微信公众号**，点击然后使用手机微信扫码，在微信上选择你要登录的小程序；二是要进入腾讯云后台之后切换选择云开发Cloudbase。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682071f1c4a241948fd5247ecaf69218~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



### return与console

#### 云函数日志

当调用云函数时，在开发者工具调试器里并没有看到console.log打印的结果，但我们可以打开**云开发控制台**–**云函数**–**日志**，**按函数名筛选**，选择rectangle云函数，可以看到云函数被调用的日志记录了（日志也可以在云开发网页控制台查看）。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f057bddb5b2a4f39a16fa7fc35d8a49d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

在云函数日志里，我们除了可以在**返回结果**里看到return返回的对象，还可以在日志里查看到云函数执行的时间点（使用的是服务端时间，时区为UTC+0），以及云函数里使用console.log打印的日志。

云函数调试的时候，不能只依赖小程序端的`wx.cloud.callFunction`使用return返回的报错，因为它只是反馈云函数的调用结果以及调用是否出现错误error，更多的还是要在云函数里使用`console.log`打印云函数在执行过程中的一些日志情况。也就是说，return只会返回中断函数执行的一些报错，而比如函数是否获取到参数，参数是什么数据类型，以及是否包含你想要的预期值，这些都需要勤使用console.log来反馈。

#### return与报错

在小程序端调用云函数时，我们经常会使用到return，return语句可以终止函数的执行并返回一个值给小程序端，因此很多人会依赖return返回的这个值来了解云函数是否获取到了最终想要的结果。对于复杂的云函数，仅仅只是使用return并不能精确定位到云函数在执行过程中哪里出错。

而小程序端的报错，只能显示云函数为什么没有等到执行return就中断了，比如以下案例集合名本为cloudbase，但是在书写的过程中，却不小心写错了：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async (event, context) => {
  return await db.collection("cloubase").where({
    _id:_.exists(true)
  }).get()
}
```

这种错误由于会中断云函数的执行，因此会被返回到小程序端，报错也会显示集合或记录不存在，截图如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3052f36b8d4533a9a532dc8975e016~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

当然出现这个报错，首先要检查你调用的集合与云数据库的集合名是否一致（或确实不存在这个集合），如果都没有问题，则需要检查云函数的初始化是否正确的选择了集合所在的云开发环境。

大多数情况下，可能云函数里并没有出现中断函数执行的错误error，但是return却并没有返回到预期的结果，比如前面介绍的rectangle云函数，我们可以在开发者工具的调试器console里调用云函数：

```js
wx.cloud.callFunction({name:"rectangle"}).then(res=>{console.log(res)})
```

在调用时，我们忘记了传入参数，或者参数名写错了，或者由于异步的问题参数其实没有值等等原因，云函数可以正常执行，但是return的值却为`result: {circum: null, area: null}`，对于这样的错误如果不通过日志，就很难反馈出来。

注意 **错误(Error)** 与 **异常(Exception)** 是完全不一样的，错误会中断JavaScript函数的执行，而异常不会导致JavaScript进程被终止，通过return只能返回错误而不能获取到异常，要获取云函数执行的异常需要通过`try..catch`的方式。



### 云函数的错误处理



#### try...catch

在云函数中，return只能返回错误，而有些异常我们可以通过`try..catch`来返回，`try..catch`的语法如下。

```js
try {
  // 代码...
} catch (err) {
  // 错误捕获
}
```

也就是如果在try块中有任何一个语句或函数抛出异常，控制会立即转向catch子句。如果在try块中没有异常抛出，则会跳过catch子句。我们写的每一个云函数都建议采用`try..catch`的方式来进行错误处理。

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async (event, context) => {
  try{
    const data = await db.collection("cloubase").where({
      _id:_.exists(true)
    }).get()
    return data
  }catch(err){
    return err
  }
}
```

前面通过return获取不到的异常，通过`try...catch`的方式就能获取到了，异常返回如下：

```js
errCode: -502005
errMsg: "[ResourceNotFound] Db or Table not exist. Please check your request, but if the problem cannot be solved, contact us.; 
```

#### error对象不支持遍历

不过对于一些异常，Node.js存在error对象的字段不支持遍历，所以序列化成字符串时会忽略所有的字段，比如下面的代码不仅集合不存在，连upData这个变量也没有声明，直接返回error显示的会为空：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async (event, context) => {
  try {
    const result =await db.collection('users').where(upData).get()
    return result
  }catch (error) {
    //return error有时候返回不了一些异常，可以通过通过返回error的具体属性
    // return { name: error.name, message: error.message, stack: error.stack }
    return error
  }
}
```

我们可以通过返回error对象的name、message、stack的方式来获取异常，如catch子句里我们可以使用`return { name: error.name, message: error.message, stack: error.stack }`，这样就可以返回报错了。



#### 云函数的日志与高级日志

不过更加建议的方式是在做云函数错误处理时结合使用console.log或高级日志的方式来记录报错，因为即使采用了`try...catch`的方式，还是有一些错误、异常无法被反馈，而console.log强大的调试测试能力却可以做到。

比如下面的一个云函数，需要我们在调用云函数时给云函数传入两个参数`a`和`b`，云函数会将获取到的参数相加并返回：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  try {
    const {a,b} = event
    const sum = a + b
    console.log("获取到的a,b,sum的值",[a,b,sum])
    return sum
  }catch (e) {
    console.log(e)
    return { name: error.name, message: error.message, stack: error.stack }
  }
}
```

如果我们在调用云函数时忘记传入参数，比如在控制台输入以下代码，即使在用了`try...catch`的情况下也是无法准确定位到错误的：

```javascript
wx.cloud.callFunction({name:"rectangle"}).then(res=>{console.log(res)})
```

我们可以在try语句打印云函数参数获取的情况`console.log("获取到的a,b,sum的值",[a,b,sum])`，在云函数的调用日志里面查看就能发现问题：

```javascript
获取到的a,b,sum的值 [ undefined, undefined, NaN ]
```

当小程序发布之后，通过筛选“调用失败”只能获取到中断云函数执行的错误，而对于一些bug或异常，则需要通过云函数日志。但是云函数调用次数非常多，而console.log日志却没办法筛选，这个时候我们可以使用云开发提供的高级日志服务。高级日志服务实现日志采集和检索分析等功能，方便开发者通过日志快速的发现和定位问题。每条日志可最长存储30天，超过 30 天的日志将被自动清理。



### 云函数的监控



#### 云函数的状态监控与消耗

在云函数日志里，我们可以看到云函数的执行时间、内存和内存消耗，比如`Duration:5ms Memory:256MB MemUsage:35.218750M`，意思是整个云函数执行时间为5ms，当前云函数的内存为256MB，内存消耗为35.218750M。

云函数的执行时间和内存是一个非常关键的指标，比如云函数执行时间可以反映该云函数的性能，如果执行时间过长，比如超过500ms，云函数就应该尽可能优化一下；而同时云函数的计费也与执行时间和内存（也就是256M，非内存消耗）相关，云函数资源使用量 = 函数配置内存（256M） X 运行计费时长（5ms）。



#### network面板

调用云函数时，我们还可以在开发者工具调试面板的NetWork标签查看调用云函数的情况。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57c6ce80da534bc684a79f37bf92c83f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)





## 云函数的调用与返回

调用云函数的方式有很多，如小程序端、管理端调用、定时触发器、HTTP访问服务、云函数等，不同的方式存在哪些差异？我们知道调用云开发资源可以通过小程序端SDK和云函数端的SDK，这两种方式有什么不同？在调用云函数的过程中，我们需要注意哪些问题？

### 云函数的传参与返回

在小程序端我们可以使用`wx.cloud.callFunction`接口调用云函数并向云函数传递参数。参数的来源和参数的数据类型有很多.

比如在小程序function页面的function.js里输入以下代码，我们知道页面js的data对象常用于事件处理的过渡，通过数据渲染可以控制小程序的页面；这里我们将data对象里面的数据以参数的形式传递给云函数：

```js
Page({
  data:{
    rectangle:{
      width:22,
      height:33,
    }
  },

  onLoad(){
    this.getData()
  },
  getData(){
    wx.cloud.callFunction({
      name:"invoke",
      data:{
        rectangle:this.data.rectangle
      }
    }).then(res=>{
      console.log("res对象",res)
    })
  }
});
```

在这里调用的云函数是invoke，那invoke云函数应该如何接收小程序端传递的参数呢？

在不熟悉或开发时建议可以先通过打印了解参数传递的状态或参数的数据类型。使用开发者工具新建一个云函数，名称如invoke，然后输入以下代码并部署上传到云端：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
exports.main = async (event, context) => {
  console.log("event对象",event)
}
```

通过invoke云函数的日志可以了解到event对象里参数的情况，然后再使用解构赋值将参数取出，如:

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
exports.main = async (event, context) => {
  console.log("event对象",event)
  const {rectangle:{width,height}} = event
  return {
    circum:(width+height)*2,
    area:width*height
  }
}
```

而在小程序端如果需要对云函数return返回的数据进一步处理，既可以使用**callback回调函数**的方式，也可以使用**Promise**的方式，还可以将获取的数据**赋值给变量**，而要对返回的数据有更清晰的了解，也通过需要在开发时多打印或调试，而不能靠蒙或猜：

```js
async getData(){
  const result = await wx.cloud.callFunction({
    name:"invoke",
    data:{
      rectangle:this.data.rectangle
    }
  })

  console.log("result对象",result) 
  const {result:{circum,area}} = result  //注意这里有两个result，有着不同的含义，注意区分，使用时也可以采用不同的变量名
  console.log({circum,area})
  this.setData({
    circum,area
  })
}
```



### 不同调用方式下的event与context

云函数的调用方式很多，不同的调用方式传入给云函数的参数对象也会有所不同。每个云函数的传入参数有两个对象：event对象和context对象。其中event对象指的是SDK触发云函数时传入的事件；而context对象则包含此调用的调用信息和函数的运行状态。采用不同的调用方式以及调用链条，返回的event对象和event对象的值是不一样的。

#### 通过打印了解event与context对象

将invoke云函数的index.js代码修改为如下，并将文件更新上传到云端，接下来我们会通过多种方式来调用这个云函数，只要云函数被触发，我们就可以在日志里查看到打印的event和context对象到底有何不同：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
exports.main = async (event, context) => {
  console.log("event对象",event)
  console.log("context对象",context)
}
```



在开发者工具调试器的console控制台调用云函数可以直接在控制台输入以下命令：

```js
//但实际上在开发者工具调试器控制台console中是获取不到云函数打印的内容的 原作者没有明确
wx.cloud.callFunction({name:"invoke"}).then(res=>{console.log(res)})

```

我们也可以把上面的代码写在其它地方:

* 小程序首页如function.js的onLoad生命周期函数里，通过开发者工具的调试以及真机调试来调用云函数；
* 而要在管理端调用云函数，可以打开云开发控制台，对该云函数进行云端测试。

打印的event对象和context对象大致如下：

```js

event对象 {
  "userInfo": {
    "appId": "wx597d2f8ac9b22e20",
    "openId": "oPZis4n0e8D3JSPcSEoesFnAav-s"
  }
}
context对象 {
  "callbackWaitsForEmptyEventLoop": true,
  "memory_limit_in_mb": 256,
  "time_limit_in_ms": 3000,
  "request_id": "f062593b-d290-4ab4-bc78-1148515a0a83",
  "environment": "{\"SCF_NAMESPACE\":\"xly-9gssrn8d637383e4\",\"TCB_CONTEXT_CNFG\":\"{\\\"TCB_SDK_GRAY_0\\\":true,\\\"URL\\\":\\\"http://169.254.0.131:80/admin\\\"}\",\"TCB_CONTEXT_KEYS\":\"TCB_ENV,TCB_SEQID,TRIGGER_SRC,TCB_ISANONYMOUS_USER,TCB_SOURCE,TCB_ROUTE_KEY,TCB_CONTEXT_CNFG\",\"TCB_ENV\":\"xly-9gssrn8d637383e4\",\"TCB_ISANONYMOUS_USER\":\"false\",\"TCB_ROUTE_KEY\":\"32\",\"TCB_SEQID\":\"1682492710193_0.6397125710806393_33614847\",\"TCB_SOURCE\":\"wx_devtools\",\"TENCENTCLOUD_SECRETID\":\"AKIDkO7dbBq-nVcv6L8bVHNNQm_Z-ftfQ_hFo9OPKb6Ze6prklOPAe46HyZwvXDgI_Uz\",\"TENCENTCLOUD_SECRETKEY\":\"aA3AHTV94u/BPYJcB1ip77fNK2pLzr77sAMW6ZuHb/o=\",\"TENCENTCLOUD_SESSIONTOKEN\":\"Y9BRSpG1HsbYj7EkTocbugZtzNHElFka92c35a08851ba738ed33911f6b9d966diKGwyuOIu9_FLk0tw2utwUSyBCbozxarzQfsS6VJeuPTJX-8rUxbagy1qy4EnQ1881RHiouAYYLGm0-AO_NBXZDEpa5NIrYzgIhqNvfAlrVD2mqECt3zFvsab-rzNLlEN7XrB4kCVTPiTXjkkirseIZXxANmh55UvcPnLMX4h-8X1JNJuIv0-g_ZjNLtxmayyDBWJY-UL1C1ornMTrpUpQU8nsOV7PNFYtXqr-ptmuJyctVZtM5nO2qVctfQ3fkOCujBAf4Uk2ME5tZntLhEUY8DgAc4DElY_Bnuc5ke-LaSyI66hcF4xvrf7qWLHXZ88lrgFQ2H3aKHQcoOKeISX8gsNkjtI2iFtFX4KW6DSDkO_M5N4eQtE3SwPZ_PJC8z\",\"TRIGGER_SRC\":\"tcb\",\"WX_API_TOKEN\":\"eyJFbmNyeXB0QWxnbyI6IkVOQ1JZUFRfQUxHT19BRVNfQ0dNIiwiVmVyc2lvbiI6MSwiS2V5VmVyc2lvbiI6MjU1LCJFbmNyeXB0S2V5IjoielZkZzRhWk9IMFdwZUFBQXcyZmNlZ0hWeFlpYytCRlpoQnNQK3RDWEorQT0iLCJ0aWNrZXQiOiJDUE1CRW9BRWd0cU1vOGZ2Y3M2ZHFWTXBoQmJBeXRTaUJEL0lGSXRPYmRkT2orME9KcTdlajQ2NE9mbkZYOVBLang1Y09JYmZObHN6L2k4MFZYb205Z3RkamFhRWFzQTVMTVNTMEVBaHIvbnJKeUZxUEFzbkNKbDA5NUxxRm5PbXB4Z3NnVE9DR2RYQ3pRRFJIMm9LNklLczFLNkFjVkdjTUw5Uzg3V1UvNU8yMkRwK1RIalhnbkg1TnVvdk1pRkwxOTNCNWxveXM1VmdpcDQ0UERSSk1PVFcyVXdLVG1nREx6N1NIbFZNWHJlSnc3cEtoNyt5R1pDUE1RL25BdGJDdDBPbkVTaHpWYW81dFoyZGJGTXRseUhJekkxdVN0NmR1dTZEWWo5WTAzNGNMb2JCbTlKV1RVRVJ0Q3d1ZGczK0FFZW8zWjNDeFFMbU9vK0p0QTFFVkJyeFJBaExTUU5ua1lXZ2t4d29GdWpqLyt5cDZNUTRsb2NVZUQxVkR0eUVxZis5VlMrY1AxUkhsZVUwVHl6Q0Z4ckgzWjRiTFRiN3RhTmNubFdubmR5T24zWmMweDRHVHlURjROdGxYOGZoamVKWWZHT2ErN1BuU2QwZ3FndkR2WHM3Q0EzZ3QrS21ONThCaGp4bzNYSnk5bDdRUExNZUZ3bzcwK01yT0M4d0VMTlo2R1hHRVAybVN3Umg0OW1iblRWVzcxNm03RG54bFlZTnV3L1ZHMU0rU2tTU3RQUjFOUTViUzF1b2ZyaEpPdnQ2eFBZcVFwOXdpclpMbGt1eFJwbTY1eGlhdE9qQmp0NDI5WWQ4Y0JCdFlLNXRjVGFJa3d4UWY0bnNtNTF1VlFJRUxOdUZ0dGlobmI2MjNXc1djVS9zZlhzZFVNNTVJYjB6VlgyWkNYRWsyUExIL0hVWUFDQUEiLCJldmVudElkIjoiSE92dGs1MHM5blQ2ZzRLRlhBVFRGMlA3NFNXQ0FJWk43eTI2MlZfWDNRdUJNRVIzcjBjMmJCenNUQWtPM2NrWC1nYVFPLTRDMEREUXEyMzZWeGoyRnJnTmFSNFdPS2plbDZHeDdjckNUQmpnIn0=\",\"WX_APPID\":\"wx597d2f8ac9b22e20\",\"WX_CLIENTIP\":\"111.194.48.127\",\"WX_CLIENTIPV6\":\"::ffff:111.194.48.127\",\"WX_CONTEXT_KEYS\":\"WX_UNIONID,WX_CLIENTIP,WX_CLIENTIPV6,WX_FROM_APPID,WX_FROM_OPENID,WX_FROM_UNIONID,WX_OPEN_DATA_INFO,WX_APPID,WX_OPENID,WX_API_TOKEN\",\"WX_FROM_APPID\":\"\",\"WX_FROM_OPENID\":\"\",\"WX_FROM_UNIONID\":\"\",\"WX_OPENID\":\"oPZis4n0e8D3JSPcSEoesFnAav-s\",\"WX_OPEN_DATA_INFO\":\"\",\"WX_UNIONID\":\"\"}",
  "environ": "WX_FROM_OPENID=;WX_OPENID=oPZis4n0e8D3JSPcSEoesFnAav-s;WX_CONTEXT_KEYS=WX_UNIONID,WX_CLIENTIP,WX_CLIENTIPV6,WX_FROM_APPID,WX_FROM_OPENID,WX_FROM_UNIONID,WX_OPEN_DATA_INFO,WX_APPID,WX_OPENID,WX_API_TOKEN;TCB_ISANONYMOUS_USER=false;TENCENTCLOUD_SECRETID=AKIDkO7dbBq-nVcv6L8bVHNNQm_Z-ftfQ_hFo9OPKb6Ze6prklOPAe46HyZwvXDgI_Uz;TENCENTCLOUD_SECRETKEY=aA3AHTV94u/BPYJcB1ip77fNK2pLzr77sAMW6ZuHb/o=;SCF_NAMESPACE=xly-9gssrn8d637383e4;WX_OPEN_DATA_INFO=;WX_API_TOKEN=eyJFbmNyeXB0QWxnbyI6IkVOQ1JZUFRfQUxHT19BRVNfQ0dNIiwiVmVyc2lvbiI6MSwiS2V5VmVyc2lvbiI6MjU1LCJFbmNyeXB0S2V5IjoielZkZzRhWk9IMFdwZUFBQXcyZmNlZ0hWeFlpYytCRlpoQnNQK3RDWEorQT0iLCJ0aWNrZXQiOiJDUE1CRW9BRWd0cU1vOGZ2Y3M2ZHFWTXBoQmJBeXRTaUJEL0lGSXRPYmRkT2orME9KcTdlajQ2NE9mbkZYOVBLang1Y09JYmZObHN6L2k4MFZYb205Z3RkamFhRWFzQTVMTVNTMEVBaHIvbnJKeUZxUEFzbkNKbDA5NUxxRm5PbXB4Z3NnVE9DR2RYQ3pRRFJIMm9LNklLczFLNkFjVkdjTUw5Uzg3V1UvNU8yMkRwK1RIalhnbkg1TnVvdk1pRkwxOTNCNWxveXM1VmdpcDQ0UERSSk1PVFcyVXdLVG1nREx6N1NIbFZNWHJlSnc3cEtoNyt5R1pDUE1RL25BdGJDdDBPbkVTaHpWYW81dFoyZGJGTXRseUhJekkxdVN0NmR1dTZEWWo5WTAzNGNMb2JCbTlKV1RVRVJ0Q3d1ZGczK0FFZW8zWjNDeFFMbU9vK0p0QTFFVkJyeFJBaExTUU5ua1lXZ2t4d29GdWpqLyt5cDZNUTRsb2NVZUQxVkR0eUVxZis5VlMrY1AxUkhsZVUwVHl6Q0Z4ckgzWjRiTFRiN3RhTmNubFdubmR5T24zWmMweDRHVHlURjROdGxYOGZoamVKWWZHT2ErN1BuU2QwZ3FndkR2WHM3Q0EzZ3QrS21ONThCaGp4bzNYSnk5bDdRUExNZUZ3bzcwK01yT0M4d0VMTlo2R1hHRVAybVN3Umg0OW1iblRWVzcxNm03RG54bFlZTnV3L1ZHMU0rU2tTU3RQUjFOUTViUzF1b2ZyaEpPdnQ2eFBZcVFwOXdpclpMbGt1eFJwbTY1eGlhdE9qQmp0NDI5WWQ4Y0JCdFlLNXRjVGFJa3d4UWY0bnNtNTF1VlFJRUxOdUZ0dGlobmI2MjNXc1djVS9zZlhzZFVNNTVJYjB6VlgyWkNYRWsyUExIL0hVWUFDQUEiLCJldmVudElkIjoiSE92dGs1MHM5blQ2ZzRLRlhBVFRGMlA3NFNXQ0FJWk43eTI2MlZfWDNRdUJNRVIzcjBjMmJCenNUQWtPM2NrWC1nYVFPLTRDMEREUXEyMzZWeGoyRnJnTmFSNFdPS2plbDZHeDdjckNUQmpnIn0=;TCB_SEQID=1682492710193_0.6397125710806393_33614847;TCB_CONTEXT_CNFG={\"TCB_SDK_GRAY_0\":true,\"URL\":\"http://169.254.0.131:80/admin\"};WX_CLIENTIPV6=::ffff:111.194.48.127;WX_FROM_UNIONID=;TCB_CONTEXT_KEYS=TCB_ENV,TCB_SEQID,TRIGGER_SRC,TCB_ISANONYMOUS_USER,TCB_SOURCE,TCB_ROUTE_KEY,TCB_CONTEXT_CNFG;TCB_ROUTE_KEY=32;WX_UNIONID=;WX_CLIENTIP=111.194.48.127;WX_FROM_APPID=;WX_APPID=wx597d2f8ac9b22e20;TCB_ENV=xly-9gssrn8d637383e4;TRIGGER_SRC=tcb;TCB_SOURCE=wx_devtools;TENCENTCLOUD_SESSIONTOKEN=Y9BRSpG1HsbYj7EkTocbugZtzNHElFka92c35a08851ba738ed33911f6b9d966diKGwyuOIu9_FLk0tw2utwUSyBCbozxarzQfsS6VJeuPTJX-8rUxbagy1qy4EnQ1881RHiouAYYLGm0-AO_NBXZDEpa5NIrYzgIhqNvfAlrVD2mqECt3zFvsab-rzNLlEN7XrB4kCVTPiTXjkkirseIZXxANmh55UvcPnLMX4h-8X1JNJuIv0-g_ZjNLtxmayyDBWJY-UL1C1ornMTrpUpQU8nsOV7PNFYtXqr-ptmuJyctVZtM5nO2qVctfQ3fkOCujBAf4Uk2ME5tZntLhEUY8DgAc4DElY_Bnuc5ke-LaSyI66hcF4xvrf7qWLHXZ88lrgFQ2H3aKHQcoOKeISX8gsNkjtI2iFtFX4KW6DSDkO_M5N4eQtE3SwPZ_PJC8z;SCF_NAMESPACE=xly-9gssrn8d637383e4",
  "function_version": "$LATEST",
  "function_name": "invoke",
  "namespace": "xly-9gssrn8d637383e4",
  "tencentcloud_region": "ap-shanghai",
  "tencentcloud_appid": "1317954245",
  "tencentcloud_uin": "100031013316"
}
```



通过管理端调用云函数，无论是event对象还是context对象都是获取不到用户的openId、appId、unionid等信息的，也就是说通过管理端调用云函数是获取不到用户的登录态信息的。

???? 打印信息中不是有openId



#### getWXContext()

context对象里的environment、environ过于复杂，云开发有专门的接口`cloud.getWXContext()`可以获取到其中比较关键的信息，比如会返回小程序用户的openid、小程序appid、小程序用户的unionid等。

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  console.log("wxContext对象",wxContext)
}
```

和context对象一样，通过不同的调用方式，`cloud.getWXContext()`返回的值也会有所不同，

```js
{ UNIONID: '',//用户的unionid，只有绑定了开放平台，且在用户授权（允许获取用户信息、关注、支付）的情况下才有
  CLIENTIP: '10.22.213.71',//小程序客户端的网络IPv4地址
  CLIENTIPV6: '::ffff:10.22.213.71',//小程序客户端的网络IPv6地址
  APPID: 'wxda99....b57046',//小程序AppID
  OPENID: 'oUL-m5FuRmuVmxvbYOGuXbuEDsn8',//小程序用户的openid
  ENV: 'xly-xrlur',
  SOURCE: 'wx_devtools' //云函数调用来源，wx_devtools开发者工具调用，wx_client小程序调用，wx_http	HTTP API 调用，wx_unknown	微信未知来源调用等
}
```







#### 登录态与openid的获取

由于context是调用云函数时传入的上下文对象，而getWXContext与context对象有关，因此调用`cloud.getWXContext()`接口时，不能在exports.main外。同时，openId、AppId、unionid等用户信息只有在小程序端调用时才能获取到。

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  const {OPENID} = wxContext
  return OPENID
}
```

不过值得一提的是，尽管我们在小程序端非常需要用户的openid这个值，但是更多的时候，我们没有必要浪费云函数资源来获取openid的值。比如，不少人在使用云开发时，都会先调用云函数返回用户的openid，然后在用户CRUD云数据库时云开发资源时传入获取到的openid。我们可以在用户读写云开发使用`.where({_openid:'{openid}'})`以及借助安全规则的方式，这样就不需要先获取用户的openid的具体值。



### main函数与return

云函数主要执行的是index.js中的main方法，因此要确保云函数中含有main函数，而return除了会返回数据给云函数的调用方，同时也会终结云函数的执行。

在main函数的其他函数里要注意一些写法，比如云函数是支持async/await的，不过在await再用then链式写法，而没有返回值，那data对象就会是undefined，而云函数调用的结果为空

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async(event, context) => {
  const data = await db.collection("china")
  .where({
    _id:_.exists(true)
  })
  .get()
  .then(res=>{
    console.log("then打印的结果",res)//会返回数据库查询的结果
  })
  console.log("data对象",data)//data为undefined
  return data //返回的data为空
}
```

面对这个问题，有两个解决方法，一是不要使用then链式，二是在then方法里return一个返回值，更加土建采用第一种方式。

```js
//方法一，不使用then链式
const data = await db.collection("china")
.where({
  _id:_.exists(true)
})
.get()

//方法二，使用return返回一个data
const data = await db.collection("china")
.where({
  _id:_.exists(true)
})
.get()
.then(res=>{
  console.log("then打印的结果",res)
  return res
})
console.log("data对象",data)
```

注意方法二里尽管我们在then方法里使用了return，但是return只是终结数据库请求，以及返回数据给data，并不会中断云函数的执行，也不会把res的数据返回给main。因此，下面的方法调用云函数时也的返回值也会是null：

```js
await db.collection("china") //const data = await db.collection("china") 同样也不会给main返回任何数据
.where({
  _id:_.exists(true)
})
.get()
.then(res=>{
  console.log("then打印的结果",res)
  return res
})
```



## 云函数的配置与进阶

云函数在云端Node.js的运行机制与本地Node.js会有一些差异，主要表现在云函数实例是由事件触发不是始终运行的（执行完随时会销毁），各个实例之间在横向上是相互隔离的（没有公用的内存或硬盘空间），在纵向上是无状态的（云函数的执行不能调用上一次云函数的执行信息）。云函数平台通过弹性伸缩实例来支持高并发，实例也存在冷启动、热启动（实例复用）的情况。除了机制不同，云函数是无服务器Serverless架构，配置上与传统的Node.js服务器也有所不同。

### 云函数的环境变量

#### 云开发环境的process.env

在配置云函数的环境变量之前，我们需要先来了解云函数的process.env属性，它会返回包含用户环境的对象。process对象是Node.js的全局对象，无需使用require()就可以使用。

比如在invoke云函数里输入以下代码，上传部署到云端之后，在开发者工具的console调用，然后查看云函数的日志就可以看到env环境变量对象：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async(event, context) => {
  console.log("env环境变量",process.env)
}
```

env环境变量里包含一些内置的环境变量key，比如以`SCF_`、`QCLOUD_`、 `TECENTCLOUD_ `开头的key是无法配置的。env对象的一些属性，我们可以在云函数中直接获取到它的具体值并在代码中会用。

比如SCF_RUNTIME函数运行时的Node.js版本，SCF_FUNCTIONVERSION是云函数的版本，TENCENTCLOUD_APPID是云开发对应的腾讯云账号APPID，使用方法如下：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async(event, context) => {
  const {SCF_RUNTIME,SCF_FUNCTIONVERSION,TENCENTCLOUD_APPID} = process.env
  return {SCF_RUNTIME,SCF_FUNCTIONVERSION,TENCENTCLOUD_APPID}
}
```



### 环境变量的配置与应用

打开云开发控制台云函数标签页，我们可以选择一个云函数比如invoke，然后点击**版本管理**，云函数更新迭代比较频繁且版本变更比较频繁时，就需要对新版本的云函数发布一个灰度版本以来了解新版云函数的执行情况，这时候就可以使用云函数的灰度/版本管理（这里就不深入介绍了）。 ![云函数灰度/版本管理](https://i.hackweek.org/img/4/WX20200924-152135@2x.png) 而我们要配置云函数的环境变量，可以点击**配置**，进入云函数的配置页，在环境变量处，我们可以给云函数以key和value的方式配置环境变量。

在配图中，我们写了一些环境变量的大致示例，这些变量的值可以通过`process.env.key`来获取，环境变量常用于如下应用场景：

- 可变值提取：我们可以把业务中有可能会变动的值提取至环境变量中，这样就能避免需要根据业务变更而修改云函数的代码了；
- 加密信息外置：我们可以把认证、加密等敏感信息的key，从代码中提取至环境变量，就能避免key硬编码而引起的安全风险了；
- 环境区分：针对不同开发阶段所要进行的配置和数据库信息，也可提取到环境变量中，这样仅需要修改环境变量的值，分别执行开发环境数据库和发布环境数据库即可；
- 云开发环境的时区：云开发环境的默认时区为UTC+0，比北京时间UTC+8晚了8小时，配置函数的环境变量，设置`TZ`为`Asia/Shanghai` 即可。



### 内存与超时时间

#### 云函数的内存配置

在云函数的调用日志里，我们可以看到云函数被调用的执行时间和执行内存。默认情况下，云函数的配置内存为256MB，而一般情况下云函数的执行内存都会在100MB以内。

如果根据项目需要，你希望使用云函数来执行图片、音视频、爬虫等任务的处理，云函数的执行内存可能会超过256M，这个时候你可以将云函数的内存升级到512M、1024M等；而如果你只是使用云函数处理一些简单的任务，你可以将云函数的内存将配到128M。

在前面我们已经说过，云函数有个计费指标资源使用量GBs，它的值为云函数的配置内存 X 运行计费时长，也就是说根据业务情况合理配置云函数的内存，可以降低云函数的成本.



#### 云函数的执行时间与超时时间

云函数默认的超时时间是3秒钟，通常情况下，这个时长已经足够了；一般来说，如果日志里云函数的执行时长超过300毫秒，就应该检查云函数是否需要优化了。不仅如此，对于一些密集型的任务，也建议使用定时触发器来解决，比如当需要使用云函数发送几十万条短信时，可以借助于定时触发器分批发送，如每5秒，而不是使用云函数一次性发送完（关于定时触发器，教程后面有介绍）。

不过如果根据业务需求，云函数会下载一些文件，或处理的链路比较长，或处理的量相对比较大（比如几千条短信之类的），3s的执行时间可能会不够，这时候就需要将云函数的超时时间的值设置更大一些。云函数的超时时间最大可以设置为60s，不过建议一般不要超过20s。



### 云函数模块与实例复用



#### 云函数模块的创建与引入

使用开发者工具在invoke云函数目录下新建一个common文件用于存放一些模块文件，然后再在common文件夹下新建common.js文件：

```md
invoke // 云函数目录
├── common //common文件夹
│   └── common.js //common.js文件
└── index.js
└── config.json 
└── package.json 
```

在common.js输入以下代码，在common文件里就包含一些通用的数据对象、函数等：

```js
const key = {
	AppID: 'wxda99ae45313257046',  
	AppKey: 'josgjwoijgowjgjsogjo', 
}

const getName = (msg) => {
  return msg+'李东bbsky';
};

//判断是否为数字
const validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;
//元素在数组的index位置
const indexOfAll = (arr, val) => arr.reduce((acc, el, i) => (el === val ? [...acc, i] : acc), []);
exports.key = key
exports.getName = getName
exports.validateNumber = validateNumber
exports.indexOfAll = indexOfAll
```

在index.js里输入以下代码，注意模块文件的引入以及模块里的数据对象、函数等接口的调用方法：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const common = require('./common/common.js');
const {key,getName,validateNumber,indexOfAll} = common

exports.main = async(event, context) => {
  const msg = "你好啊"
  console.log(getName(msg)) 
  console.log(key.AppID)
  console.log(validateNumber(msg))
  console.log(indexOfAll([1, 2, 3, 1, 2, 3], 1))
}
```



#### 关于实例复用

建议在云函数的exports.main函数之外只定义常量或者公共方法，不要定义变量。main函数之外声明的变量可能会被缓存，而不是每次都执行：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
let i = 0; //比如这里在main函数之外定义了一个变量i
exports.main = async(event, context) => {
  i++;
  console.log(i);
  return i;
};
```

在第一次调用该云函数的时候函数返回的结果为1，这是符合预期的。但如果连续调用这个云函数，返回值有可能是2或从2开始递增，也有可能又变成1，这便是实例复用的结果。

当云函数热启动时，执行函数的Node.js进程会被复用，进程的上下文也得到了保留，所以变量i自增。当云函数冷启动时，Node.js进程是全新的, 代码会从头完整的执行一遍，此时就会返回1。所以，开发者在编写云函数时，应注意保证云函数是无状态的、幂等的，即当次云函数的执行不依赖上一次云函数执行过程中在运行环境中残留的信息。



#### 云函数调用进阶

使用云函数也可以使用`cloud.callFunction`接口来调用其他云函数（可以是同一云开发环境的云函数，也可以是同一账号下或跨账号其他云开发环境里的云函数）。比如云支付的支付成功回调函数就是用云函数调用云函数。对于日常的业务，通常不太建议这种调用链路过长的方式，会比较影响性能。

我们还可以使用`switch...case`将多个云函数集成到一个云函数里，其中switch语句会评估一个表达式，将表达式的值与case子句匹配，并执行与该情况相关联的语句：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async(event, context) => {
  console.log(event.action)
  switch (event.action) { //根据调用云函数时传入的action的值来调用不同的函数
    case 'addPost': {
      return addPost(event)
    }
    case 'deletePost': {
      return deletePost(event)
    }
    case 'updatePost': {
      return updatePost(event)
    }
    case 'getPost': {
      return getPost(event)
    }
    default: {
      return 
    }
  }
};

async function addPost(event) {
  return '创建一篇文章' //这里只是返回一个字符串，可以换成其他的函数，比如在数据库里创建一篇文章
}
async function deletePost(event) {
  return '删除一篇文章'
}
async function updatePost(event) {
  return '更新一篇文章'
}
async function getPost(event) {
  return '获取一篇文章'
}
```

调用云函数时，

```js
wx.cloud.callFunction({
  name:"post",
  data:{
    action:"addPost" //
  }
}).then(res=>{
  console.log(res)
})
```

> 将多个云函数集成到一个云函数里除了可以通过`switch...case`的方法外，还可以使用tcb-router和severless-http，这些在教程的第三部分、第四部分都有详细的讲解。





# 云数据库

**任何**一个大型的应用程序和服务，都**必须**会使用到**高性能的**数据存储解决方案，用来**准确**、**快速**、**可靠**地**存储和检索**用户的账户信息、商品以及商品交易信息、产品数据、资讯文章等等，而云开发就自带高性能、高可用、高拓展性且安全的文档型数据库。



## 云数据库基础知识

### 云数据库的基础知识

#### 云数据库与Excel、MySQL的对应理解

我们可以结合Excel以及MySQL（之前没有接触过MySQL也没有关系，只看与Excel的对应就行）来理解云开发的数据库。

| 云数据库        | **MySQL数据库**     | **Excel文件**            |
| --------------- | ------------------- | ------------------------ |
| 数据库database  | 数据库 **database** | 工作簿                   |
| 集合 collection | 表 **table**        | 工作表                   |
| 记录 record/doc | 记录**row**         | 数据表除开第一行的每一行 |
| 字段field       | 数据列**column**    | 数据表的每一列           |

在操作数据库时，我们要对**数据库database**、**集合collection**、**记录doc**以及**字段field**要有一定的了解，首先要**记住这些对应的英文单词**，当你要操作某个记录doc的字段内容时，就像投送快递一样，要先搞清楚它到底在哪个数据库、在哪个集合、在哪个记录里，一级一级的去找。操作数据库通常都是对数据库、集合、记录、字段进行**增、删、改、查**，而增删改查则是对应数据库的请求。比如下面是更新某个字段的值：

```js
wx.cloud.database().collection('集合名').where({
  _id:'记录的id'
}).update({
  "字段名":"字段值"
})
```



#### 集合的创建与数据类型

云开发数据库支持的数据类型有字符串String、数字Number、对象Object、数组Array、布尔值Bool、时间Date、多种地理位置类型Geo以及Null。

我们现在来创建一个**books**的集合（相当于创建一张Excel表），用来存放图书馆里面书籍的信息，比如这样一本书：

| 书名title           | JavaScript权威指南(第6版) |                |
| ------------------- | ------------------------- | -------------- |
| 作者author          | 弗兰纳根(David Flanagan)  |                |
| 标准书号isbn        | 9787111376613             |                |
| 出版信息publishInfo | 出版社press               | 机械工业出版社 |
|                     | 出版年份year              | 2012           |

打开云开发控制台的数据库标签，新建集合books，然后选择该集合，给books里添加记录（类似于填写Excel含字段的第一行和其中一行关于书的信息记录），依次添加字段：

- 字段名：title，类型：string，值： JavaScript权威指南(第6版)
- 字段名：author，类型：string，值：弗兰纳根(David Flanagan)
- 字段名：isbn，类型：string，值：9787111376613
- 字段名：publishInfo，类型：object
- 然后我们再在publishInfo的下面（二级）添加字段press，类型为string，值为：机械工业出版社；year，类型为number，值为：2012



我们可以依照这个方法创建更多的记录，也可以给该记录添加更多字段。以上记录在云开发控制台的效果如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49f2eda988454f2e87d5017434bbcf74~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



> 如果我们创建记录时，没有指定_id字段的值，后台会自动生成一个`_id`，如果指定了 _id的值，该值就不能和当前集合下已有的记录冲突，也就是`_id`需是独一无二的，类似于MySQL里的primary key。



### 数据库的导出与导入

#### 数据库的导出

云开发数据库支持用**json**和**csv**文件的方式导出和导入数据。比如我们将上面的创建的数据以json的形式导出，结果大致如下：

```js
{
  "_id": "7853e7b85ee9665a00069fb805e816d1",
  "author": "弗兰纳根(David Flanagan)",
  "isbn": "9787111376613",
  "publishInfo": {
    "press": "机械工业出版社",
    "year": 2012
  },
  "title": "JavaScript权威指南(第6版)"
}
{
  "_id": "7853e7b85ee9665a00069fb919c91ca1",
  "author": "泽卡斯(Zakas. Nicholas C.) ",
  "isbn": "7115275793",
  "publishInfo": {
    "press": "人民邮电出版社",
    "year": 2012
  },
  "title": "JavaScript高级程序设计(第3版)"
}
{
  "_id": "7853e7b85ee9665a00069fbb3aaef4d6",
  "isbn": "9787121198854",
  "publishInfo": {
    "press": "电子工业出版社",
    "year": 2013
  },
  "title": "高性能MySQL（第3版）",
  "author": "Baron Schwartz，Peter Zaitsev，Vadim Tkachenko"
}
```



为了方便大家阅读与编辑json文件的内容，推荐大家使用Visual Studio Code编辑器。使用VS Code编辑器打开json文件，发现数据的内容与写法我们都比较熟悉，各个记录对象之间是使用回车分隔，而不是逗号`,`，这一点需要大家注意。

数据库还支持CSV的导出，那对象里的字段应该怎么导出呢，我们可以使用点表示法，比如上面的数据，我们在导出CSV的时候，可以在字段里填写如下内容：

```js
_id,isbn,title,author,publishInfo.press,publishInfo.year
```



#### 数据库的高级操作

在我们做数据库的开发学习时，如果创建记录是像之前在控制台一个字段一个字段的添加，非常的繁琐且不方便，这时推荐使用控制台数据库的**高级操作**，高级操作支持数据库的增删改查以及聚合等操作。

![Cloud Base > Database](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772f2080ee2e477e8193f9201d02d689~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

在控制台数据库管理页中可以编写和执行数据库脚本，这些脚本的语法会跟我们之后会学习的SDK 数据库语法一样，可以作为我们**日常“调试”数据库的一种基础方式**，也就是我们可以把这个作为类似于控制台console一样。



#### json文件的导入

在调用数据库之前，需要先有一个比较贴近实际的数据库案例，为此我们把知乎日报apid的数据整理出了一个json数据库文件。

**数据库下载：**[知乎日报文章数据](https://link.juejin.cn/?target=https%3A%2F%2Ftcb-1251009918.cos.ap-guangzhou.myqcloud.com%2Fdata.json)

右键点击链接，将data.json存储到电脑。打开云开发控制台，在数据库里新建一个集合**zhihu_daily**，导入该json文件，导入时会有冲突模式选择，看下面的介绍，推荐大家使用upsert：

- Insert：总是插入新记录
- Upsert：如果记录存在则更新，否则插入新记录

导入后，发现数据库自动给每一条数据（记录）都加了唯一的标识 **_id** ，



#### csv文件的导入

右键点击链接另存为[中国城市经济数据](https://link.juejin.cn/?target=https%3A%2F%2Ftcb-1251009918.cos.ap-guangzhou.myqcloud.com%2Fchina.csv)，然后在云开发控制台里新建一个china集合，将china.csv导入到集合当中，这里我们也准备了一份线上excel版本：[中国城市经济线上excel版](https://link.juejin.cn/?target=https%3A%2F%2Fshimo.im%2Fsheets%2FHHwXWQ9qHqvG8xDw%2FMODOC%2F)



# 云数据库快速上手

## 权限的设置

在集合创建之后，我们**首先需要**在云开发控制台-数据库-集合的权限设置标签对数据库进行**权限设置**。数据库的权限分为小程序端和服务端（云函数、云开发控制台的高级操作）。服务端拥有读写所有数据的读写权限，所以这里的权限设置只是在设置小程序端的用户对数据库的操作权限。



### 简易权限控制与安全规则

权限控制我们可以采用简易权限控制或自定义权限（也就是安全规则），**建议开发者用安全规则取代简易的权限控制**，也就是我们在配置集合的权限时，不再选择简易的权限控制，而是建议使用**自定义权限**。

使用简易权限配置和使用安全规则，在用法上有比较大的差异，这个在后面的学习里我们都会详细说明。要使用自定义权限来取代简易的权限控制，我们需要了解**4个简易的权限控制**所表示的意思，以及安全规则应该如何一一取代它们，填写与之对应的json规则即可。

**所有用户可读，仅创建者可读写**

比如用户发的帖子、评论、文章，这里的**创建者是指小程序端的用户**，也就是**存储UGC**（用户产生内容）的集合要设置为这个权限；

```js
{
  "read": true,
  "write": "doc._openid == auth.openid"
}
```



**仅创建者可读写**

比如私密相册，用户的个人信息、订单，也就是只能**用户自己读与写**，**其他人不可读写**的数据集合；

```js
{
  "read": "doc._openid == auth.openid",
  "write": "doc._openid == auth.openid"
}
```



**所有人可读**

比如资讯文章、商品信息、产品数据等你想让**所有人可以看到，但是不能修改**的内容；

```js
{
  "read": true,
  "write": false
}
```



**所有用户不可读写**

如后台用的不暴露的数据，**只能在云开发控制台或云函数进行读写**；

```javascript
{
  "read": false,
  "write": false
}
```



### 服务端获取不了用户登录态

注意，这里的创建者指的不是管理者，也不是开发者（或者你本人），而是用户里的一个角色。云开发控制台是无法获取用户的登录态的，所以如果集合里的数据是通过云开发控制台创建或导入的，那么就没有用户是这些数据的创建者。

> 管理者指的是可以登录控制台和使用云函数的虚拟角色。你如果只是在小程序端请求数据库，你的角色就是用户；如果作为用户的你在小程序端创建了记录，那么你就这条记录的创建者；只有你通过控制台和云函数进行操作时，此时的你才能称之为管理者。你到底是什么角色，取决于你操作数据库的方式，不要混淆。

而在云开发控制台新建的集合，默认的权限为“**仅创建者可读写**”，而这个权限设置会限制小程序端用户对数据库的调用，如果你不把集合的权限修改为“**所有用户可读，仅创建者可读写**”，不然在云函数服务端可以调用（权限设置对服务端无效），但是在小程序端是调用不了的哦，在小程序端查询时明明数据库里有数据，但是返回的却是空数组。

那如果数据是在小程序端创建的，数据库又是怎么区分这条数据是由哪个用户创建的呢？



### _openid与集合权限

使用云开发控制台新建一个集合，比如user集合，此时user集合默认的权限为“**仅创建者可读写**”。我们再在开发者工具的Console里输入以下代码来新建一个简单的记录:

```js
wx.cloud.database().collection('user').add({
  data:{
    name:"李东bbsky"
    }
  }).then(res=>console.log(res))
```

我们在云开发控制台可以看到这条记录，发现和导入的数据或使用高级操作不同的是，在小程序端新增记录，都会自动添加一个_openid的字段，它的值就是用户的openid，而这个用户才是这个记录的创建者。

```js
{
  _id:"5efaaa445ee987d2000069bf6dbec068",
  _openid:"oPZis4n0e8D3JSPcSEoesFnAav-s",
  name:"测试"
}
```



## 小程序端调用数据库

在小程序端调用数据库的方式很简单，我们可以把下面的代码写到一个事件处理函数里，然后点击组件触发事件处理函数来调用；也可以直接写到页面的生命周期函数里面；还可以把它写到app.js小程序的生命周期函数里面。

使用开发者工具，新建一个dbtest的页面，然后再在dbtest.js的页面生命周期函数OnLoad里输入以下代码，先使用`wx.cloud.database()` 获取数据库的引用（相当于连接数据库）;再使用`db.collection()`获取集合的引用；再通过Collection.get来获取集合里的记录:

```js
const db = wx.cloud.database() //申明一个变量，简化后面的写法
db.collection('zhihu_daily')
  .get()
  .then(res => {
    console.log(res.data)
  })
  .catch(err => {
    console.error(err)
  })
```

编译之后，就能在控制台看到调用的20条数据库记录了，res.data是一个数组。注意，小程序端最多只能get 20条记录。



## 云函数端调用数据库

### 云函数端调用数据库

使用云函数也可以调用数据库，使用开发者工具**右键点击**云函数根目录也就是cloudfunctions文件夹，选择**新建Node.js云函数**，云函数的名称命名为zhihu_daily，然后打开index.js，输入以下代码：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
const db = cloud.database()  //注意这里不是wx.cloud.database()
exports.main = async (event, context) => {
  const result = await db.collection('zhihu_daily')
    .get()
  return result
}
```

然后右键点击index.js，选择**上传和部署：所有文件**，我们既可以使用云函数的本地调试（要本地调试需要使用npm install安装wx-server-sdk依赖），也可以使用**云端测试**来了解云函数调用数据库的情况。



### 将云函数获取到的数据返回到小程序端

使用开发者工具在login.wxml里输入以下代码，也就是我们通用点击按钮触发事件处理函数：

```xml
<button bindtap="getDaily">获取日报数据</button>
```

再在事件处理函数里调用云函数，在login.js里输入getDaily事件处理函数来调用zhihu_daily云函数：

```javascript
getDaily() {
  wx.cloud.callFunction({
    name: 'zhihu_daily',
    success: res => {
      console.log("云函数返回的数据",res.result.result.data)
    },
    fail: err => {
      console.error('云函数调用失败：', err)
    }
  })
},
```

在模拟器里点击**获取日报数据**的button按钮，就能在控制台里看到云函数返回的查询到的结果，大家可以通过setData的方式将查询的结果渲染到小程序页面，这里就不介绍啦。



### 获取数据的写法

怎么将从数据库里获取到的数据赋值给一个变量呢？这里有几个写法可以参考一下，比如常见的有：

```js
const db = wx.cloud.database() 
db.collection('zhihu_daily')
  .get()
  .then(res => {
    console.log(res.data)  //数据在res.data里
    this.setData({
      daily:res.data   //在小程序端将数据赋值给Page里的data对象的daily
    })
    const daily = res.data //在回调里将数据赋值给变量
  })
  .catch(err => {
    console.error(err)
  })
```

我们还可以直接将数据赋值给一个变量，值得注意的是如果不使用async/await，因为异步问题，result的值返回的会是一个Promise对象，也就是说如果你要将数据库请求的结果赋值给一个变量，要么使用`then...catch`这种回调的方式，要么采用同步的方式，建议用async/await：

```js
const db = wx.cloud.database() 
async getData(){
  //注意，因为数据是在get请求对象的data里，所以写法如下
  const daily = (await db.collection('zhihu_daily').get()).data
  //我们也可以分两次写，注意await 是在async函数里
  const result = await db.collection('zhihu_daily').get()
  const daily = result.data
  console.log(daily)
}
```

尽管我们还可以使用Callback的形式，但是Callback只支持小程序端，不支持云函数端，为了统一，建议不要使用Callback的写法，而使用`then...catch`

```js
//数据库查询请求get的Callback写法
.get({
  success: console.log,
  fail: console.error
})
//相应的链式写法如下：
.get()
.then(res=>{console.log(res)})
.catch(err=>{console.log(err)})
```





# 数据的查询与统计

查询集合collection里的记录是云开发数据库操作最重要的知识，在前面我们已经将中国城市经济数据china.csv的数据导入到了集合china之中，并已经设置好了集合的权限为“**所有人可读，仅创建者可读写**”（或使用安全规则），接下来我们就以此为例来讲解数据库的查询。

在[中国城市经济线上excel版](https://link.juejin.cn/?target=https%3A%2F%2Fshimo.im%2Fsheets%2FHHwXWQ9qHqvG8xDw%2FMODOC%2F)以及云开发控制台china集合里，我们可以看到中国332个城市的**名称city**、**省份province**、**市区面积city_area**、**建成区面积builtup_area**、**户籍人口reg_pop**、**常住人口resident_pop**、GDP的数据。



### 快速了解数据查询

查询中国**GDP在3000亿元以上**的**前10个城市**，并要求**不显示_id字段**，**显示城市名、所在省份以及GDP**，并按照**GDP大小降序排列**。

使用开发者工具新建一个chinadata页面，然后再在chinadata.js的onLoad生命周期函数里输入以下代码。操作集合里的数据涉及的知识点非常繁杂，下面的案例相对比较完整，便于大家有一个整体性的理解：

```js
const db = wx.cloud.database()  //获取数据库的引用
const _ = db.command     //获取数据库查询及更新操作符
db.collection("china")  //获取集合china的引用
  .where({              //查询的条件操作符where
    gdp: _.gt(3000)     //查询筛选条件，gt表示字段需大于指定值。
  })
  .field({             //显示哪些字段
    _id:false,         //默认显示_id，这个隐藏
    city: true,
    province: true,
    gdp:true
  })
  .orderBy('gdp', 'desc')  //排序方式，降序排列
  .skip(0)                 //跳过多少个记录（常用于分页），0表示这里不跳过
  .limit(10)               //限制显示多少条记录，这里为10
 
  .get()                   //获取根据查询条件筛选后的集合数据  
  .then(res => {
    console.log(res.data)
  })
  .catch(err => {
    console.error(err)
  })
```

大家可以留意一下数据查询的**链式写法**， wx.cloud.database().collection('数据库名').where().get().then().catch()，前半部分是数据查询时对对象的引用和方法的调用；后半部分是Promise对象的方法，Promise对象是get的返回值。写的时候为了让结构更加清晰，我们做了换行处理，写在同一行也是可以的。get查询会先进行权限匹配，再来查询，也就是如果集合里没有符合权限的记录，是查不到数据的。





### 构建查询条件的5个方法

不过值得注意的是这5个方法顺序不同查询的结果有时也会有所不同（如orderBy和skip多次打乱顺序的情况下），查询性能也会有所不同。通常skip最好放在后面，不要让skip略过大量数据。skip().limit()和limit().skip()效果是等价的。

构建查询条件的5个方法是基于集合引用Collection的，就拿where来说，不能写成`wx.cloud.database().where()`，

也不能是 `wx.cloud.database().collection("china").doc.where()`，

只能是 `wx.cloud.database().collection("china").where()`，也就是只能用于查询集合collection里的记录。

这五个方法是可以单独拆开使用的，比如只使用where或只使用field、limit，也可以从这5个中抽几个组合在一起使用，还可以一次查询里写多个相同的方法，比如orderBy、where可以写多次的。查询返回的结果都是记录列表，是一个数组。



#### 查询条件 where

与记录的值本身相关的条件都会写在where方法里，where里可以是值匹配（如`gdp: _.gt(3000)`）；后面我们会介绍的**command查询操作符**比如筛选字段大于/小于/不等于某个值的比较操作符，同时满足多个筛选条件的逻辑操作符等，以及**模糊查询的正则**都是写在where内。

通过where构建条件来筛选记录，不仅可以用于查询get，还可以用于删除remove、更新update、统计记录数count以及实时监听watch（add不必用where）。



#### 指定返回哪些字段field

查询时只需要传入 true|false（或 1|-1）就可以返回或不返回哪些字段，在上面的案例里我们就只返回city、province、gdp三个字段的值。

我们可以使用field不返回我们不需要的字段和字段值，这会减少返回的数据的体积，这也是性能优化比较重要的。



#### 数据排序orderBy

排序的语法为`orderBy('字段名', '排序方式')`，里面为排序的条件，这里的字段名不受field的限制（不在field内只是不返回，但是还是会起作用）。

排序方式只支持**desc降序**、**asc升序**这两种方式，如果字段里面的值时数字就按照大小，如果是字母就按照先后顺序，**不支持中文的排序方式**。

排序支持按多个字段排序，多次调用orderBy即可，多字段排序时的顺序会按照orderBy调用顺序先后对多个字段排序。

如果需要对嵌套字段排序，可以使用点表示法，比如上面的books根据出版年份year从旧到新排序，可以写为orderBy('publishInfo.year','asc')



#### 分页显示skip

skip常与limit一起用于分页，比如商品列表一页只显示20个商品，第1页显示整个数据的0~20个，那么第2页我们用skip(20)可以跳过第一页的20条数据，第3页则跳过40个数据，第N页则是skip((n-1)*20)个数据。



#### 限制数量上限的limit

数据查询的数量上限limit在小程序端默认为20，上限也是20；在服务端（云函数）默认为100，上限则是1000，比如limit(30)在小程序端还是只会显示20条数据。



#### 统计记录

count()方法可以用来统计查询条件匹配到的记录数，和get()一样，count与集合权限设置有关，在小程序端一个用户仅能统计其有**读权限**的记录数，而云函数端由于不受权限设置的控制，可以统计集合内所有符合条件的记录数。

```js
const db = wx.cloud.database()
const _ = db.command
db.collection("china")
  .where({             
    gdp: _.gt(3000)    
  })
  .count().then(res => {
    console.log(res.total)
  })

//或者我们可以这样写，注意要写在async里，云函数的main自带async，小程序端要加async
const count = await db.collection("china")
  .where({             
    gdp: _.gt(3000)    
  })
  .count()
```

field、orderBy、skip、limit对count是无效的，只有where才会影响count的结果，count只会返回记录数，不会返回查询到的数据。注意count请求不能和get、remove、update等混用，如果你既想查询数据又想获取count值，只能分两次查询了。





### 数据查询需要注意的问题

#### 简易权限控制

当集合使用的是简易权限控制，我们在小程序端进行数据库请求（如get、count、update等）时，都会默认给where添加一个条件：

```js
.where({              
   _openid:"当前用户的openid"    
})
```

所以这就是为什么尽管集合里面有数据，但是由于有了这个条件，只要记录里没有_openid或openid不匹配就查询不到记录。也就是说如果你的集合使用的是简易权限控制，进行数据库请求时，会既受到权限的约束，也会受到以上这个查询条件的约束。

比如在小程序端A用户是不能修改B用户创建的记录的，简易权限控制里没有跨用户来写记录的权限，在小程序端用户A只能修改当前用户A创建的数据。如果想实现跨用户写记录的操作，要么开启安全规则（自定义权限），要么在云函数端进行操作。

#### 数据查询的数量

前面也提到过，小程序端自带limit限制为20条，在手机端一页显示20条数据也已经足够，如果想显示更多，可以翻页，或使用云函数获取（默认100条，最多1000条），或使用聚合。

在MySQL里，是**不允许直接**查询数据表里的所有数据的，如果表里有几万、几十万乃至上百万的数据，不对查询的条件和数量有限制，会大大降低数据库的性能，但是云开发的数据库却可以直接查，正是因为云开发数据库在小程序端和云函数有默认的数据查询限制。



#### 数据查询的速度

这里有**三个数据查询的速度**要比较：1、在小程序端查询集合的速度；2、云函数端查询集合的速度；3、小程序端调用云函数来查询数据并将数据返回给小程序端的速度；

- 重新编译加载chinadata页面，然后打开控制面板的**Network**标签，我们可以看到db.collection.where.get的Type、size以及Time，这个是**在小程序端查询集合的速度**；
- 打开云开发控制台，在云函数标签找到zhihu_daily云函数，点击云端测试，直接运行测试，就能触发云函数，调用成功后我们可以看到日志里包含返回的数据，以及**Duration**云函数的执行时间和MaxMemoryUsed执行时最大内存（拉到日志的最后，或者可以通过云函数的日志来查看），这里的**Duration**可以看成是**云函数查询集合**的整个时间（背后原理更容易），通常会比小程序端查询集合的速度要快；
- 在模拟器里点击**获取日报数据**的button按钮，然后打开控制面板的**Network**标签，我们可以看到wx.cloud.callFuntion.zhihu_daily的Type、size以及Time，这个就是我们在小程序端调用云函数来查询数据，然后并将数据返回给小程序端的速度，这个速度是三种方法里面最慢的。



# 查询操作符

操作符Command主要分为**查询操作符**和**更新操作符**，查询操作符用于db.collection的where条件筛选（也就是都会写在where条件内），而更新操作符则是用于update请求的字段的更新里。查询操作符主要对**字段的值**进行比较和逻辑的筛选判断。



## 查询操作符基础

### 比较、逻辑、字段查询操作符

下面我们把查询操作符的比较操作符和逻辑操作符整理成了一张表格，并附上相应的技术文档，方便大家对它们有一个清晰而整体的认识。

| 查询操作符之比较 |              |      |                    |
| ---------------- | ------------ | ---- | ------------------ |
| gt               | 大于         | lt   | 小于               |
| eq               | 等于         | neq  | 不等于             |
| lte              | 小于或等于   | gte  | 大于或等于         |
| in               | 在数组中     | nin  | 不在数组中         |
| 查询操作符之逻辑 |              |      |                    |
| and              | 条件与       | or   | 条件或             |
| not              | 条件非       | nor  | 都不               |
| 查询操作符之字段 |              |      |                    |
| exists           | 字段存在判断 | mod  | 字段值取模运算判断 |



#### 查询操作符的写法

首先我们要明确的是查询操作符只能写在where内，查询操作符是基于database数据库引用的，我们以**大于gt**在小程序端（以大于3000为例）的完整写法为例：

```js
//简化前
const db = wx.cloud.database()
db.collection("china")
  .where({             
    gdp: wx.cloud.database().command.gt(3000)   
  })

//简化后，注意变量db和_的声明一定要有哦，这个可以作为一个全局变量，比如写在Page()对象的外面
const db = wx.cloud.database()
const _ = db.command
db.collection("china")
  .where({             
    gdp: _.gt(3000)   
  })
```

为了简便，通常我们会把`wx.cloud.database()`会赋值给一个变量db，而把db.command又会赋值给`_`，使用时最终被简化为`_.gt(3000)`。通过一层一层的声明变量并赋值，大大简化了操作符的写法，大家可以在其他操作符都沿用这种写法。



#### 通过打印了解操作符

我们可以在开发者工具的Console控制台输入以下命令，来了解云开发在小程序端到底有哪些操作符：

```javascript
wx.cloud.database().command
```

操作符包含查询操作符、更新操作符以及聚合操作符，而在云函数里我们也可以通过打印来了解云函数端有哪些操作符：

```javascript
console.log(cloud.database().command)
```



###  比较操作符

#### 用法丰富的等于eq操作符

相比于其他的比较操作符等于eq和不等于neq操作符的用法非常丰富，它可以**进行数值比较**，我们查询某个字段比如GDP等于某个数值如17502.8亿的城市：

```javascript
.where({
  gdp: _.eq(17502.8),
})
```

它还可以进行**字符串的匹配**，比如我们查询某个字段比如city完整匹配一个字符串如深圳：

```javascript
.where({
  city: _.eq("深圳"),
})
```

> 注意：在查询时，`gdp: _.eq(17502.8)`的效果等同于`gdp:17502.8`，而`city: _.eq(“深圳”)`等同于`city:”深圳”`，虽然两种方式查询的结果都是一致的，但是它们的原理不同，前者用的是等于操作符，后者用的是传递对象值（匹配查询）。

eq操作符接受一个字面量，除了可以是number, boolean, string以外，还可以是object, array, Date类型，值为数组和对象的情况，后面章节我们会来介绍。



#### 在where中规定多值的in操作符

使用in和nin，可以在where条件中规定多值，而这多个值要写在一个数组内，比如我们想同时查询北上广深四个城市的经济数据，可以使用：

```javascript
const db = wx.cloud.database()
const _ = db.command
db.collection("china")
  .where({             
    city: _.in(["北京","上海","广州","深圳"])   
  })
```

数组里的值也可以是数字，比如取值为10、20这两个值，写法为`_.in([10,20])`，这里不要错误理解为10到20。



### 逻辑操作符

#### 字段内的逻辑操作符

查询**广东省内**、**GDP在3000亿以上且在1万亿以下**的城市。在广东省内也就是让字段province的值等于”广东”，而GDP的要求则是GDP这个字段同时满足大于3000亿且小于1万亿，这时就需要用到and（条件与，也就是且的意思）：

```js
.where({
  province:_.eq("广东"),
  gdp:_.gt(3000).and(_.lt(10000))
})
```

> 操作符支持链式调用其他操作符，多个操作符之间是逻辑与的关系，比如`gdp:_.gt(3000).and(_.lt(10000))`可以简写成`gdp:_.gt(3000).lt(10000)`也就是省掉了and操作符。and的写法还可以写成如下：`gdp:_.and(_.gt(3000), _.lt(10000))`,三种写法都是一样的。



#### 跨字段的逻辑操作符

上面的案例中where内的两个条件，`province:_.eq("广东")`和 `gdp:_.gt(3000).and(_.lt(10000))`带有跨字段的**条件与and（也就是且）\**的关系，那如何实现跨字段的\**条件或or**呢？

查询中国**GDP在3000亿元以上且常住人口在500万以上或建城区面积在300平方公里以上**的**前20个大城市**。这里常住人口和建成区面积只需要满足其中一个条件即可，这就涉及到条件或or（**注意下面代码的格式写法**）：

```javascript
.where(
  {
    gdp: _.gt(3000),
    resident_pop:_.gt(500), 
    },
  _.or([{
    builtup_area: _.gt(300)}
    ]), 
)
```

注意上面三个条件，`gdp: _.gt(3000)`和`resident_pop:_.gt(500)`是逻辑与，而与 `builtup_area: _.gt(300)}`的关系是逻辑或。 `_.or([{条件一},{条件二}])`内是一个数组，条件一与条件二又构成逻辑与的关系。

> 一般不太建议把逻辑操作符写得过于复杂，要尽可能的简单，这也是数据库请求的一个基本原则；在使用逻辑操作符时，能用“是”，就不要用“非”。



#### 字段字符串的模糊查询

正则表达式能够灵活有效匹配字符串，可以用来检查一个串里是否含有某种子串，比如“CloudBase技术训练营”里是否含有”技术”这个词。云数据库正则查询支持UTF-8的格式，可以进行中英文的模糊查询。**正则查询也是写在where字段的条件筛选里。**

我们可以用正则查询来查询某个字段，比如city城市名称内，包含某个字符串比如”州”的城市

```javascript
const db = wx.cloud.database()
db.collection("china")
  .where({
    city: db.RegExp({
      regexp: '州',
      options: 'i',
    })
  })
```

注意这里的city是字段，db.RegExp()里的regexp是正则表达式，而options是flag，i是flag的值表示不区分字母的大小写。当然我们也可以直接在where内用JavaScript的原生写法或调用 RegExp对象的构造函数。比如上面的案例也可以写成：

```javascript
//JavaScript原生正则写法
  .where({
     city:/州/i
  })
 
//JavaScript调用RegExp对象的构造函数写法
  .where({
    city: new db.RegExp({
      regexp: "州",
      options: 'i',
    })
  })
```



# 操作集合里的记录 ?





# 操作记录里的字段?









# 更新操作符?







# 数组的查询更新操作符?









# 操作嵌套数组的对象?







# 数据库变量处理?







# 聚合快速入门?







# 聚合阶段?







# 聚合操作符入门?







# 小程序端图片操作?



## 小程序端图片操作



### 获取手机相册或拍照的图片

`wx.chooseImage()`的API，我们只需要结合前面的点击事件、事件处理函数以及调用API、传入技术文档里面指定的参数就能很容易做到。

**技术文档：**[wx.chooseImage()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fmedia%2Fimage%2Fwx.chooseImage.html)



#### 上传一张图片

使用开发者工具新建一个file的页面，然后在file.wxml里输入以下代码：

```js
<button bindtap="chooseImg">选择图片</button>
<image mode="widthFix" src="{{imgurl}}"></image>
<view>上传的图片</view>
```

然后在file.js的data里给imgurl设置一个初始值，由于链接src是一个字符串类型，我们这里可以设置为一个字符串空值，完成imgurl的初始化：

```js
data: {
  imgurl: ''
}
```

再在file.js里添加事件处理函数chooseImg，在chooseImg里我们来调用上传函数的API`wx.chooseImage()`，其中count、sizeType、sourceType都是API已经写好的属性，API调用成功（图片上传成功）之后，会在success回调函数里返回图片的一些信息，返回的信息可以看技术文档。

```js
chooseImg:function(){
  const that=this
  wx.chooseImage({
    count: 1,
    sizeType: ['original', 'compressed'],
    sourceType: ['album', 'camera'],
    success(res) {
      const imgurl = res.tempFilePaths
      that.setData({
        imgurl
      })
    }
  })
},
```



虽然在开发者工具的模拟器也可以看到效果，但是`wx.chooseImage()`是一个与手机客户端交互性很强的API，我们最好在手机上体验。点击开发者工具的**预览**，在手机微信里查看效果，点击选择图片按钮，上传一张图片或拍照看看。

- **count**：可以选择的照片数量，默认为9张（由于imgurl声明的是字符串，多张照片需为数组Array，后面有上传多张图片的案例）
- **sourceType**：选择图片的来源，album就是图片可以来自手机相册；而camera是可以来自手机拍照，两个都写就是来自相册或拍照都可以；
- **sizeType：**所选的图片的尺寸，original为原图，compressed为压缩图，为了减轻服务器压力，建议为压缩图；
- **tempFilePaths**为临时文件的**路径列表**，**tempFiles**为临时**文件列表**，注意这两个值都为数组。



#### 空值的处理

我们可以看到由于imgurl为空值，image组件有默认宽度300px、高度225px（会随css而改变大小），所以显示**上传的图片**会与**选择图片**的button有一段空白，处理的方法有三种：

**方法一：** 我们可以给imgurl弄一张初始图片的链接，为了让界面更加美观、交互性更好，通常都会设置一个默认的图片，比如默认的头像，当用户上传时，setData就会取代初始图片；

**方法二：** 判断imgurl是否有内容，比如我们可以加一层逻辑判断，当Page()里的data下的imgurl属性非空时，组件才会显示；空时就不显示。

```js
<view wx:if="{{!!imgurl}}">
    <image mode="widthFix" src="{{imgurl}}"></image>
</view>
```

**方法三：** 这个方法和方法二类似，设置一个逻辑判断，比如在data里设置一个boolean属性比如hasImg，初始值为false，

```js
 data: {
    hasImg:false,
  },
```

当chooseImg回调成功之后，在that.setData里把hasImg修改为true，也就是将`wx.chooseImage()`的success回调函数里的that.setData()修改为：

```js
that.setData({
  imgurl,
  hasImg:true,
})
```

这样是否有图片就进入到了回调函数的逻辑里了，接着我们把file.wxml的代码改为如下：

```xml
<view wx:if="{{hasImg === false}}">
  <button bindtap="chooseImg">选择图片</button>
</view>
<view wx:if="{{hasImg === true}}">
  <image mode="widthFix" src="{{imgurl}}"></image>
</view>
```

没有图片也就是hasImg的值为false时，会显示**选择图片**的button；而当有图片时，没有button只有图片，在一定的场合用户体验会更好（button要是一直在，用户就还会去点，体验不好）。

> **注意：** 这里所说的上传图片与我们日常生活中的上传图片不是一样的哦，日常生活中上传图片，图片不仅会显示在小程序（网页、App）上，还会继续上传到存储服务器里面，而我们这里只是进行了第一步，上传的图片只是存储在临时文件里面，所以重新编译，图片就不显示了。后面会有临时文件的内容以及会在云开发部分将图片上传到云存储。



#### 上传多张图片

如果上传的是多张照片，那么imgurl的初始值就不能是字符串了，而是一个数组Array，

```js
data: {
    imgurl:[],
},
```

而file.wxml的代码也要相应的改为列表渲染即可，这种写法在代码上通用性比较强，上传一张图片、多张图片都可以，不过具体还是要看实际产品开发需求。

```xml
<view wx:for-items="{{imgurl.tempFiles}}" wx:for-item="item" wx:key="*this">
  <image mode="widthFix" src="{{item}}"></image>
</view>
```



### 操作图片

#### 获取图片信息

无论是存储在小程序本地，还是存储在临时文件、缓存、网络上的图片，使用`wx.getImageInfo()` 都可以获取到该图片的宽度、高度、路径、格式以及拍照方向。

**技术文档：**[wx.getImageInfo()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fmedia%2Fimage%2Fwx.getImageInfo.html)



使用开发者工具在file.js里添加以下代码，我们使用`wx.getImageInfo()` 来获取之前上传的图片的信息。由于获取图片信息需要等上传图片成功之后才能执行，因此我们可以在wx.chooseImage()的success回调函数里来调用`wx.getImageInfo()`，而获取图片信息之后才能返回图片信息，因此这又是一个回调函数：

```js
chooseImg:function(){
  let that=this
  wx.chooseImage({
    count: 9,
    sizeType: ['original', 'compressed'],
    sourceType: ['album', 'camera'],
    success(res) {
      const imgurl = res.tempFilePaths
      console.log('chooseImage回调打印的res',res)
      that.setData({
        imgurl
      })
      wx.getImageInfo({
        src: res.tempFilePaths[0],
        //也可以这么写：src: that.data.imgurl[0],这里只能看到第一张照片的信息，其他照片的信息需要遍历来获取
        success(res){
          console.log('getImageInfo回调打印的res',res)
        }
      })
    }
  })
},
```

编译之后，我们再来上传一张图片，图片上传成功之后，在控制台console里可以看到打印的信息。在上面的代码里，我们发现success回调函数嵌套success回调函数。





#### 预览所有上传的图片

预览图片就是在新页面里全屏打开图片，预览的过程中用户可以进行保存图片、发送给朋友等操作。可以预览一张照片或者多张照片。

**技术文档：**[wx.previewImage()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fmedia%2Fimage%2Fwx.previewImage.html)

使用开发者工具在file.wxml里输入以下代码，我们要预览的是从手机相册里上传的图片（**保留上面的代码，接着写**），如果没有上传图片，那就把**预览图片**的按钮给隐藏，我们来写一段完整的代码：

```js
<view wx:if="{{hasImg === true}}">
  <button bindtap="previewImg">预览照片</button>
</view>
```



#### 保存图片到相册

小程序**不支持直接将网络图片**保存到本地手机的系统相册，支持临时文件路径和小程序本地路径。

**技术文档：**[wx.saveImageToPhotosAlbum()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fmedia%2Fimage%2Fwx.saveImageToPhotosAlbum.html)

比如我们在小程序的根目录下新建一个image文件夹并放一张图片到里面比如background.jpg，然后再在file.wxml里输入以下代码，让image组件绑定事件处理函数saveImg：

```xml
<image mode="widthFix" src="/images/background.jpg" bindtap="saveImg"></image>
```

然后在file.js里添加事件处理函数saveImg，

```js
saveImg:function(e){
  wx.saveImageToPhotosAlbum({
    filePath: "/images/background.jpg",
    success(res) { 
      wx.showToast({
        title: '保存成功',
      })
    }
  })
}
```

编译之后预览在手机里体验，点击图片就会触发事件处理函数saveImg，调用`wx.saveImageToPhotosAlbum()` API，filePath为小程序文件的永久链接，文件就会保存到手机相册（没有相册权限会提示）。

> 当然永久链接实际开发用得不会太多，使用最多的场景是把**网络图片下载到临时链接（因为不能直接保存网络图片），再将临时链接的图片保存到相册**，只需把上面的永久链接换成临时链接就可以了。最重要的是要搞清楚图片到底在哪里，在网络上？还是在小程序本地？还是在临时文件里？还是在缓存里？



#### 压缩图片

小程序是有压缩图片的API的[wx.compressImage()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fmedia%2Fimage%2Fwx.compressImage.html)，尤其是在上传图片时，为了减轻存储服务器的压力，不能让用户上传分辨率过高的照片。

- 可以先让用户上传图片；
- 图片上传成功之后（也就是在上传图片的**success回调函数**里）再来获取图片的信息；
- 获取信息成功后（也就是在获取图片信息的**success回调函数**里）判断宽度或高度是否过大，如果图片过大，就压缩图片，
- 压缩图片成功后（也就是在压缩图片的**success回调函数**里），再把压缩好的图片上传到服务器

上传图片、获取图片信息、压缩图片、上传图片到服务器，每一步都依赖上一步，所以会不断在success回调函数里写函数，实际开发涉及的业务会更复杂，就会不断回调，这被称之为**回调地狱**。这就是为什么会有**Promise**写法的原因，这个我们会在以后提及。

> 由于压缩图片使用到的场景不算太多，毕竟我们在上传照片时可以不支持上传原图original，只支持压缩compressed就能保证上传图片的大小了。而且[wx.compressImage()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fmedia%2Fimage%2Fwx.compressImage.html)压缩图片的API也比较简单，所以这里就不写实际案例了，相信大家看文档也能玩得明白。





# 小程序端文件操作

## 小程序端上传文件

小程序不仅支持上传图片image，还支持上传视频、Excel、PDF、音频等等其他文件格式，但是我们只能从**客户端会话**里（也就是微信单聊、群聊的聊天记录里）选择其他格式的文件。

**技术文档：**[wx.chooseMessageFile()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fmedia%2Fimage%2Fwx.chooseMessageFile.html)

### 上传文件到小程序本地

使用开发者工具在file.wxml里添加以下代码，给选择文件的button绑定事件处理函数chooseFile：

```xml
<button bindtap="chooseFile">选择文件</button>
```

在file.js文件里添加事件处理chooseFile，并打印上传成功后回调函数里的参数对象。

```javascript
chooseFile: function () {
  let that = this
  wx.chooseMessageFile({
    count: 5,
    type: 'file',
    success(res) {
      console.log('上传文件的回调函数返回值',res)
    }
  })
},
```

使用**开发者工具**上传一张图片或其他格式的文件，在控制台console我们可以看到打印的res对象里有tempFiles的数组对象Array，tempFiles对象包含文件的名称**name**、文件的临时路径**path**、文件的大小**size**、选择的文件的会话发送时间戳**time**、文件的类型**type**。



### 渲染文件信息

我们可以把上传的文件所取得的信息给渲染到页面上，在file.wxml里添加列表渲染的代码，也就是

```xml
<button bindtap="chooseFile">选择文件</button>
<view wx:for-items="{{tempFiles}}" wx:for-item="item" wx:key="*this">
  <view>{{item.path}}</view>
</view>
```

在Page()的data里初始化一个属性tempFiles，初始值为一个空数组Array：

```javascript
data: {
  tempFiles:[],
},
```

然后再在chooseFile的success回调函数里将数据使用setData赋值给tempFiles:

```javascript
chooseFile: function () {
  let that = this
  wx.chooseMessageFile({
    count: 5,
    type: 'file',
    success(res) {
      let tempFiles=res.tempFiles
      that.setData({
        tempFiles
      })
    }
  })
},
```

编译之后预览在微信上体验，看看什么效果？**注意需选择微信有文件的会话框**。还是再强调一下，这个上传和我们实际里的上传还是不一样的，这里只是把文件上传到了一个临时文件里面，并没有上传到服务器。



### 上传地理位置

除了可以上传图片、音视频以及各种文件格式以外，小程序还支持上传地理位置。 **技术文档：**[wx.chooseLocation()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Flocation%2Fwx.chooseLocation.html)

使用开发者工具在file.wxml里输入以下代码，前面我们上传了文件，这一次我们把手机的位置给上传并渲染出来：

```xml
<button bindtap="chooseLocation">选择地理位置</button>
<view>{{location.name}}</view>
<view>{{location.address}}</view>
<view>{{location.latitude}}</view>
<view>{{location.longitude}}</view>
```

然后在file.js的Page()的data里初始化location

```javascript
data: {
  location:{},
},
```

在file.js里添加事件处理函数chooseLocation，

```javascript
chooseLocation: function () {
  let that= this
  wx.chooseLocation({
    success: function(res) {
      const location=res
      that.setData({
        location
      })
    },
    fail:function(res){
      console.log("获取位置失败")
    }
  })
},
```

编译之后预览用手机点击选择地理位置的button，就会弹出地图选择位置（这个位置既可以是你当前的位置，也可以自己选择一个位置），然后点击确定，就能在小程序上看到我们上传的位置了。要让位置信息显示在地图上，可以在file.wxml里添加一个地图组件：

```xml
<map style="width: 100%; height: 300px;"
  latitude="{{location.latitude}}"
  longitude="{{location.longitude}}"
  show-location
></map>
```

> **小任务：** 上传地理位置，将该地址显示在地图上，并添加该地理位置的markers。关于markers的知识，可以去看map组件的技术文档。





### 下载文件

我们可以使用`wx.downloadFile`下载文件资源到小程序本地，调用接口时会直接发起一个 HTTPS GET 请求，返回文件的本地临时路径 (本地路径)，单次下载允许的最大文件为 50MB。

在file.wxml里输入以下代码，我们新建一个下载文件的button，已给button绑定一个事件处理函数，比如downloadFile：

```xml
<button bindtap="downloadFile">下载文件</button>
<image src="{{downloadFile}}"></image>
```

再在Page()的data里初始化一个属性downloadFile，值为一个空字符串：

```js
data: {
  downloadFile: ''
}
```

然后再在事件处理函数downloadFile里，调用`wx.downloadFile`接口，在success回调里将下载到本地的临时路径赋值给data里的downloadFile：

```js
downloadFile(){
  const that = this
  wx.downloadFile({
    url: 'https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/weapp.jpg', //链接可以替换为你的云存储里面的下载地址
    success (res) {
      console.log("成功回调之后的res对象",res)
      // 只要服务器有响应数据，就会把响应内容写入文件并进入 success 回调，业务需要自行判断是否下载到了想要的内容
      if (res.statusCode === 200) {//如果网络请求成功
        that.setData({
          downloadFile:res.tempFilePath
        })
      }
    }
  })
},
```

我们在开发者工具的控制台来查看一下打印的res对象，在res对象里除了可以看到：

- 下载成功之后文件在本地的临时路径tempFilePath；
- 服务器返回的HTTP状态码statusCode，状态码为200表示请求成功，关于HTTP状态码更多的信息，可以去搜索了解一下，比如以2开头的200，以3开头的301，以4开头的404，以5开头的502等等，这些都是网络请求比较常见的，可以去了解一下；
- 还有文件大小dataLength以及http请求的消息头header对象，而关于header对象里面的参数，大家可以自行搜索了解一下。

当文件比较大的时候，我们还可以监听文件下载的状态，比如下载的百分比进度`progress`，已经下载的数据大小`totalBytesWritten`。

```js
downloadFile(){
  const downloadTask = wx.downloadFile({
    url: 'https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/weapp.jpg', //在小程序里下载文件也就是请求外部链接是需要域名校验的，如果使用云开发来下载云存储里面的文件，就不会有域名校验备案的问题
    success (res) {
      if (res.statusCode === 200) {
        that.setData({
          downloadFile:res.tempFilePath
        })
      }
    }
  })

  downloadTask.onProgressUpdate((res) => {
    console.log('下载进度', res.progress)
    console.log('已经下载的数据长度', res.totalBytesWritten)
    console.log('预期需要下载的数据总长度', res.totalBytesExpectedToWrite)
  })
},
```

在小程序里我们除了可以下载文件外，还可以将手机本地的文件上传到服务器，上传文件到服务器所使用的接口为`wx.uploadFile`，不过由于需要文件服务器来接收文件才能看到效果而且处理起来比较麻烦，所以这里就不多做介绍了，后面会介绍如何将文件上传到云开发的云存储里。



# 文件管理器

小程序有**临时文件、本地文件、文件缓存和数据缓存**，

文件在上传时比如使用`wx.chooseMessageFile`、`wx.chooseImage`会先将文件从相册或微信对话里上传至临时文件；

而文件下载时，比如使用`wx.downloadFile`会将文件从远程服务器下载到临时文件，下载的临时文件最大50M；

使用文件管理器，可以将临时文件移至本地文件，并进行读取、写入、重命名、解压等操作；

文件缓存主要用来存储Office文档，而数据缓存我们会在下一节来介绍。

## 预览文档

使用`wx.downloadFile`除了可以下载图片视频以外，还可以下载Word、Excel、ppt以及PDF等文档，但是这些文档只是下载到临时文件，而我们要在小程序里查看文档的内容，可以借助`wx.openDocument()`的接口新开一个页面打开文档。

在file.wxml里输入以下代码，新建一个下载并打开文档的button，以及给button绑定一个事件处理函数，比如openDoc：

```xml
<button bindtap="openDoc">下载并打开文档</button>
```

然后再在事件处理函数openDoc里，先调用`wx.downloadFile`接口下载一个PDF文档，然后再在success回调函数里调用`wx.openDocument()`打开文档：

```javascript
openDoc(){
  wx.downloadFile({
    url: 'https://786c-xly-xrlur-1300446086.tcb.qcloud.la/bkzy20203_11.pdf', //链接可以替换为云存储里面的下载地址，文档格式需要是pdf、word、excel、ppt
    success (res) {
      console.log("成功回调之后的res对象",res)
      if (res.statusCode === 200) {
        wx.openDocument({
          filePath: res.tempFilePath,
          success: function (res) {
            console.log('打开文档成功')
          },
          fail:function(err){
            console.log(err)
          }
        })
      }
    }
  })
},
```

点击按钮，就能在小程序的新窗口打开文档了，新窗口没有分享的菜单，需要调用`wx.showShareMenu`来显示转发的菜单。



## 保存文件与文件缓存

上面的案例，打开一个来自远程服务器的PDF文档，都需要先经过一个下载的过程，当用户关闭了小程序页面就又需要重复下载，那能不能将下载好的文档保存起来，当用户再次访问的时候，就不用再下载了？除了文档以外，还有音乐的循环播放、一些相对来说比较大的图片在上传和下载的过程中等也是这样的场景。这个时候就要用到`wx.saveFile`来将文件由临时文件保存到本地。

> **注意：** 尽管上传图片和上传文件都是把图片或文件先上传到临时文件里，但是 **保存图片wx.saveImageToPhotosAlbum()** 和 **保存文件wx.saveFile()** 是完全不同的概念，保存图片是把图片保存到手机本地相册；而保存文件则是把图片由临时文件移动到本地存储里，而本地存储每个小程序用户只有10M的空间。

在file.wxml里输入以下代码，我们新建一个下载并保存PDF文档的button，以及打开PDF文档的button，也就是下载与打开两个功能分离了：

```xml
<button bindtap = "downloadPDF">下载PDF</button>
<button bindtap= "openPDF">打开PDF</button>
```

然后再在事件处理函数downloadPDF里先调用`wx.downloadFile`将远程服务器里的PDF下载到临时文件，再调用`wx.saveFile`将临时文件移到小程序的文件缓存里，并将文件缓存的路径存储到页面的data对象的`savedFilePath`里；然后再在事件处理函数openPDF调用`wx.openDocument`打开这个路径就可以啦：

```js
downloadPDF(){
  const that = this
  wx.downloadFile({
    url: 'https://786c-xly-xrlur-1300446086.tcb.qcloud.la/bkzy20203_11.pdf', //链接可以替换为云存储里面的下载地址，文档格式需要是pdf、word、excel、ppt
    success (res) {
      console.log("成功回调之后的res对象",res)
      if (res.statusCode === 200) {
        wx.saveFile({
          tempFilePath: res.tempFilePath,
          success (res) {
            console.log(res)
            that.setData({
              savedFilePath:res.savedFilePath
            })

          }
        })
      }
    }
  })
},

openPDF(){
  const that = this
  wx.openDocument({
    filePath:that.data.savedFilePath,
    success: function (res) {
      console.log('打开文档成功')
    },
    fail:function(err){
      console.log(err)
    }
  })
}
```

也就是说，我们以后再来打开这个PDF文档，就不用再下载了，因为这个文档已经被我们放到了小程序里的文件缓存里。这个文件缓存不会因为我们刷新页面就不在了，保存的时间相对会比较久一些（只要不强制卸载这个小程序）。



## 操作文件缓存

我们可以使用`wx.saveFile`将图片、音视频、文档保存到文件缓存里，但是文档缓存里到底缓存了哪些文件？以及前面介绍到文件缓存总共也就10M的空间，我们应该怎么删掉一些过期的呢？

#### 获取已保存的缓存文件列表

打开微信开发者工具的console控制台，我们可以通过调用`wx.getSavedFileList`接口，直接输入以下代码来了解一个终端（开发者工具、小程序）里有哪些缓存：

```javascript
wx.getSavedFileList({
  success (res) {
    console.log(res.fileList)
  }
})
```

在控制台我们就能看到小程序里到底缓存了多少个文件，以及它的存储地址、文件的大小以及文件缓存的时间戳。注意：使用开发者工具和小程序缓存的文件地址形式是有不同的（可以用一个button绑定一个事件处理函数调用上面这个接口，并使用真机调试就可以看到了），而且缓存的文件的名称比较长，和原文件的名称是完全不一样的。

#### 获取缓存文件的信息

这里需要注意的是获取临时文件的信息，使用的是`wx.getFileInfo`的接口，需要传入临时文件的路径filePath，而获取缓存文件调用的信息，使用的则是`wx.getSavedFileInfo`，需要传入缓存文件的路径，临时文件与缓存文件也有所不同。

比如我们可以在控制台console输入以下代码，就可以了解该缓存文件的大小、创建的时间戳：

```javascript
wx.getSavedFileInfo({
  filePath:"http://store/wxda99ae4531b57046.o6zAJs291xB-a5G1FlXwylqTqNQ4.QLqnQQOBAsQdb075540bff922617a582ff0b8b953df0.pdf",//这是开发者工具的缓存文件的路径，要换成自己的哦
  success(res){
    console.log(res)
  }
})
```



## 文件管理器

临时文件、缓存文件，这些文件我们无法对他们进行进一步操作，比如修改文件名；如果文件是文本文件，比如txt、json、html等格式的文本文件，你想不只是下载或上传，而是可以进一步操作它们；或者你想将用户在小程序里处理的内容写成文件，并上传到服务器。这个时候，我们可以使用到文件管理器。

> 前面介绍的`wx.getSavedFileInfo`、`wx.saveFile`这些都可以被文件管理器的`FileSystemManager.getSavedFileList`、`FileSystemManager.saveFile`取代，或者说它们是文件管理器的一个简化版。



### 1.文件管理器与用户目录

要使用文件管理器，我们可以先调用`wx.getFileSystemManager()`来获取全局唯一的文件管理器，下面的`fs`你可以任意命名：

```js
const fs =  wx.getFileSystemManager()
```

所谓全局唯一，就是你在不同页面或者说在整个小程序获取到的文件管理器都是这一个，就跟后面会介绍的背景音乐一样，你给背景音乐接口赋多个不同的值，背景音乐只会被覆盖，不会同时有多个背景音乐。

此外，我们在使用文件管理器之前，还需要了解一下小程序的环境变量，以及文件系统中的用户目录路径 (本地路径)`USER_DATA_PATH`，使用开发者工具在console控制台打印一下：

```javascript
wx.env
```

通过打印我们可以了解到`wx.env.USER_DATA_PATH`在开发者工具里它的值为`http://usr`，在手机端，它的值为`wxfile://usr`，使用文件管理器主要管理的就是`wx.env.USER_DATA_PATH`目录里的文件。



### 2.使用文件管理器写入并读取文件

使用文件管理器，我们可以在`wx.env.USER_DATA_PATH`目录里新建一个文件夹，并在这个文件夹里创建一个文本文件，并往这个文本文件里写入内容，还可以读取这个内容等诸多操作，就跟我们使用脚本编程语言操作文件一样。

我们可以在控制台打印如下代码来了解一下文件管理器：

```js
const fs =  wx.getFileSystemManager()

//使用文件管理器创建一个文件夹
fs.mkdir({
  dirPath:wx.env.USER_DATA_PATH+"/cloudbase",
  success(res){
    console.log(res)
  },
  fail(err){
    console.log(err)
  }            
})

//读取文件夹下有哪些文件，会返回文件夹内文件列表
fs.readdir({
  dirPath:wx.env.USER_DATA_PATH,
  success(res){
    console.log(res)
  },
  fail(err){
    console.log(err)
  }  
})

//新建一个文本文件test，并往文件里写入数据
fs.writeFile({
  filePath:wx.env.USER_DATA_PATH+"/cloudbase"+"/test",
  data:"云开发技术训练营",
  encoding:"utf8",
  success(res){
    console.log(res)
  }
})

//往之前建好的test文本文件里，新增一些内容
fs.appendFile({
  filePath:wx.env.USER_DATA_PATH+"/cloudbase"+"/test",
  data:"CloudBase Camp",
  encoding:"utf8",
  success(res){
    console.log(res)
  }
})

//读取test文本文件里的内容
fs.readFile({
  filePath:wx.env.USER_DATA_PATH+"/cloudbase"+"/test",
  encoding:"utf-8",
  success(res){
    console.log(res)
  }
})
```

文件管理器还可以复制文件、解压文件、重命名文件、删除文件等等，使用方法大致与上面相同，可以参考技术文档，自己去研究一下。





# 数据缓存

相比于临时文件、文件缓存，小程序的数据缓存可以维持的时间存储的时间更长，除非用户主动删除小程序，数据缓存里面的数据就一直有效；数据缓存的空间也有10M的大小，可以用来存储用户的阅读记录、购买记录、浏览记录、登录信息等比较关键的信息，增强用户的体验。

> **点击事件生成的事件对象**也好，使用**数据表单提交的数据**也好，还是**上传下载的图片、文件**也好，这些数据和文件如果不保存到文件缓存或数据缓存里，只要我们重新编译小程序，这些数据都会消失。

## 将图片存储到缓存里

在了解logs的数据缓存之前，我们先来看一个将上传的图片由临时文件保存到缓存的案例，使用开发者工具在file.wxml里输入以下代码：

```xml
<view>临时文件的图片</view>
<image mode="widthFix" src="{{tempFilePath}}" style="width:100px"></image>
<view>缓存保存的图片</view>
<image mode="widthFix" src="{{savedFilePath}}" style="width:100px"></image>
<button  bindtap="chooseImage">请选择文件</button>
<button  bindtap="saveImage">保存文件到缓存</button>
```

然后在file.js的data里初始化临时文件的路径tempFilePath和本地缓存的路径savedFilePath：

```js
data: {
  tempFilePath: '',
  savedFilePath: '',
},
```

再在file.js里添加事件处理函数chooseImage和saveImage（函数名有别于之前的chooseImg和saveImg，不要弄混了哦）：

```js
chooseImage:function() {
  const that = this
  wx.chooseImage({
    count: 1,
    success(res) {
      that.setData({
        tempFilePath: res.tempFilePaths[0]
      })
    }
  })
},
saveImage:function() {
  const that = this
  wx.saveFile({
    tempFilePath: this.data.tempFilePath,
    success(res) {
      that.setData({
        savedFilePath: res.savedFilePath
      })
      wx.setStorageSync('savedFilePath', res.savedFilePath)
    },
  })
},
```

我们还需要在file.js的onLoad生命周期函数里将缓存里存储的路径赋值给本地缓存的路径savedFilePath：

```js
onLoad: function (options) {
  this.setData({
    savedFilePath: wx.getStorageSync('savedFilePath')
  })
},
```

编译之后，点击**请上传文件**的button，会触发chooseImage事件处理函数，然后调用上传图片的API `wx.chooseImage`，这时会将图片上传到临时文件，并将取得的临时文件地址赋值给tempFilePath，有了tempFilePath，图片就能渲染出来了。

然后再点击**保存文件到缓存**的button，会触发saveImage事件处理函数，然后保存文件API `wx.saveFile`，将tempFilePath里的图片保存到缓存，并将取得的缓存地址赋值给savedFilePath（**注意tempFilePath也就是临时路径是保存文件的必备参数**），这时缓存保存的图片就渲染到页面了。然后会再来调用缓存API wx.setStorageSync()，将缓存文件的路径保存到缓存的key savedFilePath里面。**有些参数名称相同但是含义不同，这个要注意**。

通过wx.setStorageSync()保存到缓存里的数据，可以使用wx.getStorageSync()获取出来，我们在onLoad里把获取出来的缓存文件路径再赋值给savedFilePath。编译页面，看看临时文件与缓存文件的不同，临时文件由于小程序的编译会被清除掉，而缓存文件有10M的空间，只要用户不刻意删除，它就会一直在。

> **注意：\**打开开发者工具调试面板的\**Storage标签页**，小程序的缓存记录都会在这里可以直观的看到，调试时可以留意，这一点非常重要。



## 将数据存储到缓存里

使用开发者工具新建的模板小程序里（不使用云开发服务），有一个日志logs页面，这个日志logs虽然简单，但是包含着非常复杂的JavaScript知识，是一个非常好的学习参考案例，这里我们来对它进行一一解读。

### 模块化与引入模块

在实际开发中，日期、时间的处理经常会使用到，但是使用Date对象所获取到的时间格式与我们想要展现的形式是有非常大的差异的。这时我们可以把时间的处理抽离成为一个单独的 js 文件比如util.js（util是utility的缩写，表示程序集，通用程序等意思），作为一个模块。

> 把通用的模块放在util.js或者common.js，把util.js放在utils文件夹里等就跟把css放在style文件夹，把页面放在pages文件夹，把图片放在images文件夹里是一样的道理，尽管文件夹或文件的名称你可以任意修改，但是为了代码的可读性，文件结构的清晰，推荐大家采用这种一看就懂的方式。



使用开发者工具在小程序根目录新建一个utils文件夹，再在文件夹下新建util.js文件，在util.js里输入以下代码（也就是参考模板小程序的logs页面调用的util.js）

```js
const formatTime = date => {
  const year = date.getFullYear()  //获取年
  const month = date.getMonth() + 1  //获取月份，月份数值需加1
  const day = date.getDate()  //获取一月中的某一天
  const hour = date.getHours() //获取小时
  const minute = date.getMinutes()  //获取分钟
  const second = date.getSeconds() //获取秒
 
  return [year, month, day].map(formatNumber).join('/') + ' ' + [hour, minute, second].map(formatNumber).join(':')  //会单独来讲解这段代码的意思
}
 
const formatNumber = n => {  //格式化数字
  n = n.toString()
  return n[1] ? n : '0' + n 
}
 
module.exports = {  //模块向外暴露的对象，使用require引用该模块时可以获取
  formatTime: formatTime,
  formatNumber: formatNumber
}
```

我们再来在file.js里调用这个模块文件util.js，也就是在file.js的Page()对象前面使用require引入util.js文件（需要引入模块文件**相对于当前文件的相对路径**，不支持绝对路径）

```javascript
const util = require('../../utils/util.js')
```

然后再在onLoad页面生命周期函数里打印看看这段时间处理的代码到底做了什么效果，这里也要注意调用模块里的函数的方式。

```javascript
onLoad: function (options) {
  console.log('未格式化的时间',new Date())
  console.log('格式化后的时间',util.formatTime(new Date()))
  console.log('格式化后的数值',util.formatNumber(9))
},
```

util.formatTime()就调用了模块里的函数，通过控制台打印的日志可以看到日期时间格式的不同，比如：

```javascript
未格式化的时间 Mon Sep 02 2019 11:25:18 GMT+0800 (中国标准时间)
格式化后的时间 2019/09/02 11:25:18
```

显然格式化后的日期时间的展现形式更符合我们的日常习惯，而9这个数值被转化成了字符串”09″。那这段格式化日期时间的代码是怎么实现的呢？这里就涉及到高阶函数的知识，一般函数调用参数，而高阶函数会调用其他函数，也就是把其他函数作为参数。



### map的应用

相信格式化数字的代码比较好理解，如果是15日里的15，由于n[1]是15的第二位数字5，为true会直接return返回n，也就是15；比如9月里的数字9，n[1]不存在，也就是没有第二位数，于是执行` '0' + n`给它加一个0，变成09；而formatNumber是一个箭头函数。

```javascript
const formatNumber = n => {  //格式化数字
  n = n.toString() //将数值Number类型转为字符串类型，不然不能拼接
  return n[1] ? n : '0' + n //三目运算符，如果字符串n第2位存在也就是为2位数，那么直接返回n；如果不存在就给n前面加0
}
```

而格式化日期时间则涉及到map，比如下面的这段代码就有map，

```javascript
return [year, month, day].map(formatNumber).join('/') + ' ' + [hour, minute, second].map(formatNumber).join(':')
```

map也是一个数据结构，它背后的知识非常复杂，但是我们只需了解它是做什么的就可以，如果**你想对数组里面的每一个值进行函数操作并且返回一个新数组，那你可以使用map**。

上面这段代码就是对数组`[year, month, day]`和`[hour, minute, second]`里面的每一个数值都进行格式化数字的操作，这一点我们可以在file.js的onLoad里打印看效果就明白了：

```javascript
onLoad: function (options) {
  console.log('2019年9月2日map处理后的结果', [2019,9,2].map(util.formatNumber))
  console.log('上午9点13分4秒map处理后的结果', [9, 13, 4].map(util.formatNumber))
},
```

从控制台打印的结果就可以看到数组里面的数字被格式化处理，有两位数的不处理，没有2位数的前面加0，而且返回的也是数组。至于数组Array的join方法，就是将数组元素拼接为字符串,以分隔符分割，上面`[year, month, day]`分隔符为`/`，`[hour, minute, second]`的分隔符为`:`。

#### 3、将数据存储到缓存里

我们再回头看logs的缓存案例，在小程序app.js的生命周期函数onLaunch里输入以下代码，也就是在小程序初始化的时候就执行日志进行记录：

```javascript
//  ||为逻辑与，就是声明logs为获取缓存里的logs记录，没有时就为空数组
var logs = wx.getStorageSync('logs') || []

//unshift()是数组的操作方法，它会将一个或多个元素添加到数组的开头，这样最新的记录就放在数组的最前面，
//这里是把Date.now()获取到的时间戳放置到数组的最前面
logs.unshift(Date.now())

//将logs数据存储到缓存指定的key也就是logs里面
wx.setStorageSync('logs', logs)
console.log(logs)
console.log(Date.now())
```

当我们不断编译，logs数组里面的记录会不断增加，增加的值都是时间戳。那如何把缓存里面的日志给渲染到页面呢？

在file.wxml里添加以下代码，由于logs是数组，我们使用列表渲染，这里有个数组的index值，由于index是从0开始记录，给index加1，符合我们日常使用习惯。

```xml
<view wx:for="{{logs}}" wx:for-item="log">
  <view>{{index + 1}}. {{log}}</view>
</view>
```

然后在file.js的data里初始化logs

```javascript
data: {
  logs: []
},
```

然后再在file.js的生命周期函数onLoad里把缓存里的日志取出来通过setData赋值给data里的logs

```javascript
onLoad: function () {
  this.setData({
    logs: (wx.getStorageSync('logs') || []).map(log => {
      return util.formatTime(new Date(log))
    })
  })
},
```

结合前面所了解的map、模块化知识就不难理解上面的这段代码了。缓存有同步API和异步API的区别，结合之前我们了解的同步和异步的知识，看看缓存的同步API与异步API的区别。

> 缓存的好处非常多，比如用户的浏览文章、播放视频的进度（看了哪些文章，给个特别的样式，免得用户不知道看到哪里了）、用户的登录信息（用户登录一次，可以很长时间不用再登录）、自定义的模板样式（用户选择自己喜欢的样式，下次打开小程序还是一样）、最经常使用的小图片（保存在缓存，下次打开小程序速度更快）等等。



# 云存储快速入门

我们可以将图片、文档、音频、视频、文件等数据存储到云存储里，云存储默认支持CDN加速，并提供免费的CDN域名。CDN会将云存储的内容分发至最接近用户的节点，直接由服务节点快速响应，可以有效降低用户访问延迟。

> 云存储与云开发的用户身份验证无缝集成的，用户在小程序端上传文件时会有该用户的身份标识openid，以及云存储默认的权限是“所有用户可读，仅创建者可读写”，因此在使用云存储时，
>
> 一是要先初始化云开发环境，
>
> 二是要注意小程序端上传文件和管理端（控制台和云函数）上传文件的不同，
>
> 三是要注意云存储的权限问题。



## 上传文件到云存储

要在小程序端把图片上传到云存储，会使用到`wx.cloud.uploadFile`，它可以把本地资源也就是临时文件里的文件上传到云存储里，而在前面的章节里我们了解到如何把图片上传并获取图片的临时路径；还有文件的云存储路径**cloudPath**，这个包含文件上传到云存储的目录以及文件名。

### 上传文件到云存储的案例

使用开发者工具在file.wxml里添加以下代码，一个是绑定了事件处理函数的button，还有一个就是用来渲染上传之后图片的image组件：

```xml
<button bindtap="chooseImg">选择并上传图片</button>
<image mode="widthFix" src="{{imgurl}}"></image>
```

然后在file.js的data里初始化imgurl，这里imgurl是一个空字符串，

```js
data: {
  imgurl: ''
}
```

然后在file.js里添加事件处理函数chooseImg，：

```js
chooseImg: function () {
  const that = this
  wx.chooseImage({
    count: 1,
    sizeType: ['compressed'],
    sourceType: ['album', 'camera'],
    success: function (res) {
      console.log("上传文件的临时路径列表",res.tempFilePaths) /
      const filePath = res.tempFilePaths[0] //上传第一张图片
      const cloudPath = `${Date.now()}-${Math.floor(Math.random(0, 1) * 1000)}` + filePath.match(/.[^.]+?$/)[0]
      
      wx.cloud.uploadFile({
        cloudPath,
        filePath,
        success: res => {
          console.log('上传成功后获得的res：', res)
          that.setData({
            imgurl:res.fileID
          })
        },
        fail:err=>{
          console.log(err)
        }
      })
    }
  })
}
```

保存编译后，点击**选择并上传图片**的button上传一张图片，在控制台里我们可以看到`res.tempFilePaths`是一个数组格式，而`wx.cloud.uploadFile`的filePath是一个字符串，所以在上传时，把第一张图片的路径（字符串）赋值给了filePath。



### 文件后缀的处理

我们知道一个文件由**文件名称**和**文件后缀**构成，比如tcb.jpg和cloudbase.png，jpeg说明图片的格式是JPG格式，而png说明图片是PNG格式。将文件上传到云存储时，如果文件名称相同**且**格式相同就是出现覆盖，如果我们随意更改了**文件的后缀**，大多数文件就会打不开。所以要把**cloudPath云存储的路径**需要我们把文件名和后缀给处理好。

当我们把图片上传到小程序的临时文件后，我们可以查看一下临时路径是什么样子的，临时路径的文件名就不是原来的文件名，会变成一段长字符，但文件的格式还是原来的文件格式（后缀）：

```js
http://tmp/wx7124afdb64d578f5.o6zAJs291xB-a5G1FlXwylqTqNQ4.esN9ygu5Hmyfccd41d052e20322e6f3469de87f662a0.png
```

那**cloudPath**要输入文件的路径，就需要填写文件名和文件格式，这个要怎么处理呢？我们可以使用如下方式：

```js
const cloudPath = 'my-image' + filePath.match(/.[^.]+?$/)[0]
```

也就是它把上传的所有图片命名为**my-image**，而文件的后缀还是原来的文件后缀（也就是文件格式不变）。这里的`filePath.match(/.[^.]+?$/)[0]`是**字符串的正则处理**，我们可以在开发者工具的控制台输入以下代码了解一下它的功能，打印可以得到临时文件的后缀，这里为`.png`。

```javascript
const filepath="http://tmp/wx7124afdb64d578f5.o6zAJs291xB-a5G1FlXwylqTqNQ4.esN9ygu5Hmyfccd41d052e20322e6f3469de87f662a0.png"
filepath.match(/.[^.]+?$/)[0]
```



### 文件名的处理

我们要上传的图片、音视频、文档等文件，除了格式种类很多，我们不能随意更改（更改之后文件就打不开了），通过上面文件后缀名的处理，可以获取到文件原本的格式；但是文件的数量也有很多，这种把所有文件都命名为**my-image**的做法，会导致当文件的后缀相同时文件会被覆盖，如果不希望文件被覆盖，我们需要给文件命不同的名字，我们可以这样处理：

```javascript
const cloudPath = `${Date.now()}-${Math.floor(Math.random(0, 1) * 1000)}` + filePath.match(/.[^.]+?$/)[0]
```

给文件名加上时间戳和一个随机数，时间戳是以毫秒计算，而随机数是以1000内的正整数，除非1秒钟（1秒=1000毫秒）上传几十万张照片，不然文件名是不会重复的。

编译之后，我们再次上传一张图片就会打印上传成功之后的res对象，里面包含**图片在云存储里的fileID**，而由于部分小程序组件（如image、video、cover-image等）和接口（如getBackgroundAudioManager、createInnerAudioContext、previewImage等），支持传入云文件的fileID。所以我们可以直接通过fileID把图片在小程序端渲染出来。



## 下载和删除云存储里的文件

在小程序端下载云存储里的文件调用的是`wx.cloud.downloadFile`和`wx.cloud.deleteFile`，这两个接口我们只需要传入云存储里的文件的fileID就可以。比如我们可以在控制台调用这些接口：

```javascript
wx.cloud.downloadFile({
  fileID: 'cloud://xly-xrlur.786c-xly-xrlur-1300446086/1571902980622-737.xls' //换成自己云存储里的fileID
})
.then(res => {
  console.log(res.tempFilePath)
}).catch(error => {
  console.log(error)
})

wx.cloud.deleteFile({
  fileList: ['cloud://xly-xrlur.786c-xly-xrlur-1300446086/1571902980622-737.xls', 'cloud://xly-xrlur.786c-xly-xrlur-1300446086/1572315793628-366.png'],//换成自己云存储里的fileID
}).then(res => {
  console.log(res.fileList)
}).catch(error => {
  console.log(error)
})
```

从云存储里下载的文件会被存储到小程序的临时路径，可以说小程序的临时路径是图片上传和下载的一个过渡存储空间，都需要先经过它，而不是直接上传。在小程序端删除文件的时候，注意文件的默认权限是“所有用户可读，仅创建者可读写”，所以如果不是用户通过小程序上传的文件，在小程序端是删除不了的，也就是说如果你的文件是通过控制台或云函数上传的，由于该文件没有上传者openID，就无法识别谁是创建者。

### 云函数上传图片到云存储

云开发不仅在小程序端可以上传文件到云存储，还可以通过云函数也就是云端上传图片到云存储（这里会涉及到一点Node.js的知识）。注意云函数上传图片的API属于服务端API`cloud.downloadFile`，与小程序端`wx.cloud.uploadFile`有一些不同，我们先来看下面的案例。

使用开发者工具**右键点击**云函数根目录也就是cloudfunctions文件夹，选择**新建Node.js云函数**，云函数的名称命名为uploadimg，右键点击uploadimg文件夹，选择**硬盘打开**，然后拷贝一张图片如demo.jpg进去，文件结构如下：

```bash
uploadimg云函数目录        
├── index.js 
├── package.json 
├── demo.jpg
```

然后打开index.js，输入以下代码，这里的`fs`、`path`是Node.js的内置模块（内置模板不需要npm install就可以使用），这里先只需要简单的了解即可：

- 在Node.js里，所有与文件操作都是通过`fs`核心模块来实现的，包括文件目录的创建、删除、查询以及文件的读取和写入，下面的createReadStream方法类似于读取文件；
- `path`模块提供了一些用于处理文件路径的API，比如下面的join方法用于连接路径；
- `__dirname`是指当前模块的目录名。

```javascript
const cloud = require('wx-server-sdk')
const fs = require('fs')
const path = require('path')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
})
exports.main = async (event, context) => {
  const fileStream = fs.createReadStream(path.join(__dirname, 'demo.jpg'))
  return await cloud.uploadFile({
    cloudPath: 'tcbdemo.jpg',
    fileContent: fileStream,
  })
}
```

然后右键点击uploadimg文件夹，选择**在终端中打开**，输入npm install安装依赖，再点击uploadimg云函数目录，选择**上传并部署所有文件**（这时图片也一并上传到了云端）。

我们可以直接在开发者工具console控制台执行以下事件处理函数，通过调用`wx.cloud.callFunction`来在小程序端调用uploadimg云函数，从而调用uploadFile API将服务端/云端的图片上传到云存储里面啦，可以打开云开发控制台的云存储查看是否有tcbdemo.jpg这张图片。

```javascript
uploadimg() {
  wx.cloud.callFunction({
    name: 'uploadimg',
    success: res => {
      console.log(res)
    }
  })
},
```

注意通过云函数上传到云存储的图片，是没有上传者openid的，在云存储里查看这张图片的详细信息，会看到**上传者的Open ID**为空。



### 获取文件在云存储的https链接

上传图片到云存储返回的是文件在云存储的fileID，而图片的下载地址，不过我们可以使用fileID换取云存储空间指定文件的https链接（云存储提供免费的CDN域名）。

- 公有读的文件获取的 https 链接不会过期，比如默认情况下的权限就是公有读，获取的链接永久有效；
- 私有读的文件获取的 https 链接为临时链接，比如您可以结合用户身份认证和安全规则设置文件的权限为仅文件的上传创建者或管理员可读，此时只有通过了云开发身份验证的用户才有权限换取临时链接；
- 有效期可以动态设置，超过有效期再请求临时链接时会被拒绝，保证了文件的安全；
- 一次最多可以取 50 个，更多需分批处理。

比如我们在小程序端调用`wx.cloud.getTempFileURL` 方法，只需要传入文件的fileID，就可以换取云存储空间指定文件的https链接，这个https链接我们可以在浏览器里打开，也可以做为图床来使用：

```javascript
wx.cloud.getTempFileURL({
  fileList: ['cloud://xly-xrlur.786c-xly-xrlur-1300446086/1571902980622-737.xls', 'cloud://xly-xrlur.786c-xly-xrlur-1300446086/1572315793628-366.png'],
})
.then((res) => {
  console.log(res.fileList);
});
```





### fileID是云存储与数据库的纽带

不经过数据库直接把文件上传到云存储里，这样文件的上传、删除、修改、查询是**无法和具体的业务对应的**，比如文章商品的配图、表单图片附件的添加与删除，都需要图片等资源能够与文章、商品、表单的ID能够一一对应才能进行管理（**在数据库里才能对应**），而这些文章、商品、表单又可以通过数据库与用户的ID、其他业务联系起来，可见数据库在云存储的管理上扮演着极其重要的角色。

每一个上传到云开发的文件都有一个全网唯一的fileID，而将fileID传入到云存储的API就可以对文件进行下载、删除、获取文件信息等操作，非常方便。从上面可以看出，云存储与数据库就是**通过fileID来取得联系**的，数据库**只记录文件在云存储的fileID**，我们可以访问数据库相应的fileID属性进行记录的增删改查操作，与此同时调用云存储的上传文件、下载文件、删除文件等API，这样云存储就被数据库给管理起来了。



# 创建个人相册

当我们要开始创建一个实际的小程序项目时，除了要考虑原型设计（产品经理扮演的角色）与页面的重构（设计前端开发的工作）以外，首先需要思考的是各个功能所对应的页面、组件等的交互逻辑（最终转化为项目的文件结构、各种函数、模块、component以及一个个API）以及这些功能的背后所依赖的各项数据（最终转化为数据库的结构设计、数据字典等）。接下来我们就以创建一个个人相册的项目为例，来具体进行讲解。

## 数据库的设计与结构

和Excel表、关系型数据库（如MySQL）以行和列、多表关系来设计表结构不同的是，云开发的数据库是基于文档的。我们可以在一个记录里嵌套多层数组和对象，把每个文档所需要的数据都嵌入到一个文档里，而不是分散到多个不同的集合。

比如我们想做一个网盘小程序，用来记录用户信息，以及创建的相册、文件夹，这里相册和文件夹因为可以创建很多个，所以它是一个数组；而每一个相册对象和文件夹对象里都可以存储一个照片列表和文件列表，我们发现在云开发数据库里一个元素的值是数组，数组里又嵌套对象，对象里又有元素是数组是非常常见的事情。

以下是网盘小程序的数据库设计，包含了一个用户的信息，上传的所有文件和照片等信息：

```js
{
  "_id": "",   //自动生成的ID，也可以自定义，云数据库无法像MySQL一样ID自增，自定义时要注意_id的唯一性
  "_openid": "oUL-m5FuRmuVmxvbYOGuXbuEDsn8",  //用户在当前小程序的openid
  "nickName": "李东bbsky",  //用户的昵称，可以将微信的昵称存储在这个字段
  "avatarUrl": "https://thirdwx.qlogo.cn/mmopen/vi_32/77Vejpiabfr62gPczlm4SicRqQxE1RBCs29NrdPqZZMtRu1uO47VichN1mrguRaNict5urtyyS3mFlkfGicH3bicoibMQ/132", //用户的头像链接，同样可以来自微信的userInfo信息
  "albums": [      //相册，用来存储照片
    {
      "albumName": "风景",  //相册名称
      "coverURL": "",//相册封面地址，可以从相册里随机取一张照片或取第一张照片
      "photos": [    //照片的数组，存储一个相册里N张照片
        {
          "comments": "云开发线下活动合影",//照片的备注或描述
          "fileID": "" //照片的地址，可以是云存储的fileID或https链接
        }
      ]
    }
  ],
  "folders": [   //文件夹，用来存储各种文档
    {
      "folderName": "工作周报",//文件夹名称
      "files": [     //文件的数组，存储文件夹里的N个文件
        {
          "name": "25周工作总结",  //文件名称
          "fileID": "cloud://xly-xrlur.786c-xly-xrlur-1300446086/1571902980622-737.xls", //文件的地址，可以是云存储的fileID或https链接
          "comments": "第25周工作的内容，主要包括小程序的宣传运营"//文件备注、描述
        }
      ]
    }
  ]
}
```

在我们开始开发一个项目之前，就先规划好类似于上面的数据库结构设计，这样开发的时候就能清楚有哪些字段，字段用的是什么数据类型，字段与字段之间有什么联系。有了这些规划，我们再来思考这些数据怎么获取，是通过什么函数、什么API、什么交互来获取。比如用户的信息可以来自`wx.getUserInfo()`的userInfo，也可以根据情况在用户登录之后自定义填写一些信息，比如职业等数据。

如果是用关系型数据库，就会建user表来存储用户信息，albums表存储相册信息，folders表存储文件夹信息，photos表存储照片信息，files表存储文件信息，相信大家可以通过这个案例对云数据库是面向文档的数据库有一个大致的了解。

> 当然云开发的数据库也是可以把数据分散到不同集合的，需要视不同的情况而定，在后面章节我们会介绍。这种将每个文档所需的数据都嵌入到一个文档内部的做法，我们称之为**反范式化**（denormalization），将数据分散到多个不同的集合，不同集合之间相互引用称之为**范式化**（normalization），也就是说反范式化文档里包含子文档，而范式化呢，文档的子文档则是存储在另一个集合之中。



## UI与文件结构

### 文件结构

一般来说，制作一个小程序需要先梳理清楚你要做的这个项目的产品需求，比如大致的页面结构、包含哪些功能、页面设计大致是怎样的风格、页面间的跳转、组件的触发等交互是怎样进行的等等，会根据这些先做出一个原型图，然后根据原型图的要求做出设计稿，最后才轮到开发。如果是自己独立开发虽然不必这么复杂，但是小程序的草图也是要“成竹在胸”才行。

当我们拿到设计稿时，就可以规划UI使用什么框架，比如WeUI、Vant Weapp、Color UI、iView、Lin UI等，会封装哪些函数、模块、组件，规划会有哪些云函数及相应的功能、云存储的文件目录等，以及规划项目的文件结构。

```js
project
├── cloudfunctions //云函数根目录
│   └── folder //云函数
├── miniprogram //小程序目录
│   └── pages   //存放页面，页面的创建方法可以参考第一部分的教程
│       └── folder
│       └── file
│       └── album
│       └── photo
│       └── user
│   └── images  //存放图片元素
│   └── style   //存放封装好的样式
│   └── utils   //存放封装的模块
│   └── components //存放封装好的组件
│   └── app.js 
│   └── app.json
│   └── app.wxss
└── project.config.json 
```

将设计稿的交互逻辑转化为函数的逻辑，也就是会调用哪些API，代码根据条件遵循怎样的流程，前后端、页面、组件、本地与数据库之间的参数、数据的处理等，是将交互设计稿转化为实际的代码最为核心的工作。



### 引入WeUI拓展

在前面我们了解过如何引入WeUI，作为官方出品的UI框架，WeUI支持更简单的引入方式以及有着比较丰富的实用组件。WeUI的使用方法在官方技术文档的**拓展能力**标签页有相对比较完善的介绍。

在app.json里添加useExtendedLib的配置，就能引入WeUI了，使用这种方式不会计入代码包大小，以及不需要使用import直接使用即可(当然你可以右键miniprogram打开终端输入`npm install weui-miniprogram`然后再引入)。

```js
{
  "useExtendedLib": {
    "weui": true
  }
}
```

当需要在页面比如folder.wxml中使用组件时，只需要把需要用到的组件在相应页面的json文件（这里为foler.wxss）里引入即可（不使用的虽然引入了也没有关系，但是建议只引入用到的）

```js
{
  "usingComponents": {
    "mp-dialog": "weui-miniprogram/dialog/dialog",
    "mp-toptips": "weui-miniprogram/toptips/toptips"
  },
  "navigationBarTitleText": "文件夹列表"
}
```

我们可以在folder.wxml里输入以下代码来验证模块是否引入成功（模拟器的小程序的前端展示可以看得到内容即可）：

```xml
<mp-toptips msg="组件引入成功，提示5秒后消失" type="error" show="true" delay="5000"></mp-toptips>

<mp-dialog title="WeUI引入成功" show="true" bindbuttontap="" buttons="{{[{text: '确定'}]}}">
  <view>看得到这个界面说明WeUI拓展引入成功</view>
</mp-dialog>
```



### 建立用户与数据的联系

打开云开发控制台的**数据库**标签，新建一个clouddisk的集合，并使用安全规则修改它的权限为“所有人可读，仅创建者可读写”，即`{"read": true,"write": "doc._openid == auth.openid" }`。使用开发者工具新建一个folder的页面（更加建议你在页面文件结构规划的时候就把这些页面给建好了），然后在folder.js的页面生命周期函数onLoad里输入以下代码：

```js
this.checkUser()
```

然后再在Page()对象里输入以下代码，代码的意思是如果clouddisk里没有用户创建的数据，那就在clouddisk里新增一条记录；如果有数据，就返回数据：

> 无论你是用简易版的权限设置，还是使用安全规则，在这里我们都不需要事先获取用户的openid，因为如果你使用的是简易版权限，对数据库进行增删改查时都会自带`where({_openid:'{openid}'})`的条件；而如果使用时安全规则，你可以直接使用这个条件，它不需要我们知道用户的openid具体是什么。也就说，我们没有必要先用云函数返回用户的openid，省了这样一个操作，能提升小程序的加载速度以及节省云开发资源。



> 获取用户信息文档更新： 
>
> [小程序用户头像昵称获取规则调整公告 | 微信开放社区 (qq.com)](https://developers.weixin.qq.com/community/develop/doc/00022c683e8a80b29bed2142b56c01)
>
> [头像昵称填写 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/userProfile.html)
>
> 

```js
const app = getApp()
async checkUser() {
  //获取clouddisk是否有当前用户的数据，注意这里默认带了一个where({_openid:"当前用户的openid"})的条件
  const userData = (await db.collection('clouddisk').where({
    _openid:'{openid}' //一定要开启安全规则，不开安全规则{openid}会失效，没有开启安全规则，数据库查询自带openid的权限，就不需要写这个条件了
  }).get()).data
  console.log("当前用户的数据对象",userData)

  //如果当前用户的数据data数组的长度为0，说明数据库里没有当前用户的数据
  if(userData.length === 0){      
    //没有当前用户的数据，那就新建一个数据框架，其中_id和_openid会自动生成
    await db.collection('clouddisk').add({
      data:{
        //nickName和avatarUrl可以通过getUserInfo来获取，这里不多介绍
        "nickName": "", 
        "avatarUrl": "",
        "albums": [ ],
        "folders": [ ]
      }
    })
    wx.switchTab({   //如果数据库不存在用户，除了在数据库创建一条空记录以外，还跳转到user页面，尽管用户已经登录了，但是还需要借助button的open-type="getUserInfo"来获取用户的信息
      url: '/pages/user/user'
    })
  }else{ //如果有数据，就做两件事情，一是使用setData提供页面渲染数据，二是将数据存储到全局对象
    this.setData({
      userData
    })
    app.globalData.userData = userData
    console.log('用户数据',userData)
  }
},
```



根据数据库的设计，这里一个用户只能创建一条记录，用户创建的相册、文件夹，上传的照片、文件都会存储到这个记录里。当用户打开小程序的时候执行checkUser函数，如果是新用户就在数据库里创建一条记录；如果不是新用户，就会返回数据并将数据传递给Page对象的data里。

> 在创建记录时，我们有规划的事先就将一些字段给预填充了，也就是在add的data里添加了一些必要的字段，如nickName等，这方便我们后续可以直接使用update的更新指令给字段更新数据。



### 获取用户信息并存储到数据库

在前面我们了解到，由于云开发的免鉴权，当用户打开小程序时就有了一个独一无二的openid，也就是自动登录了。不过光有openid，在展示上没有用户的头像和昵称等信息交互体验会不太好，我们可以把用户的这些信息获取之后存储到数据库，以后用户的这些信息可以只来自于数据库，永远不再需要用户的授权了（不过微信用户会经常修改自己的昵称和头像，你需要用户可以手动同步更新时就需要用户授权），你还可以让用户自定义头像和昵称（增删改查云数据库）。



#### 获取用户信息

使用开发者工具新建一个user页面（在规划页面文件结构就建好了），然后在user.wxml里输入以下代码，我们通过组件的方式来获取用户的信息：

```js
<button open-type="getUserInfo" bindgetuserinfo="getUserInfo" lang="zh_CN">点击获取用户信息</button>
<image src="{{avatarUrl}}"></image>
<view>{{city}}</view>
<view>{{nickName}}</view>
```

在user.js的data里初始化avatarUrl、nickName以及city，没有获取到用户信息时，用一张默认图片代替，昵称显示用户未登录，city显示为未知：

```js
data: {
  avatarUrl: '',  //可以预填充一个用户未登陆的灰色图片
  nickName:"用户未登陆", //预填充，提醒用户登录
  city:"未知",    //预填充
},
```

然后在user.js文件里输入以下代码，在事件处理函数getUserInfo我们可以打印event对象，`open-type=”getUserInfo”`的组件的event对象的detail里就有userInfo：

```js
getUserInfo: function (event) {
  console.log('getUserInfo打印的事件对象', event)
  let { avatarUrl, city, nickName}= event.detail.userInfo
  this.setData({
    avatarUrl,city, nickName
  })
},
```

将获取的avatarUrl，city，nickName通过this.setData()赋值给data。编译之后点击**点击获取用户信息**按钮，首先会**弹出授权弹窗**，当用户确认之后，就会显示用户的信息。



#### 获取用户高清头像

我们发现获取到的头像不是很清晰，这是因为默认的头像大小为`132*132`（[UserInfo用户头像说明](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Fuser-info%2FUserInfo.html)），如果把avatarUrl链接后面的132修改为0就能获取到640*640大小的头像了：

```js
getUserInfon: function (event) {
  let { avatarUrl, city, nickName}= event.detail.userInfo
  avatarUrl = avatarUrl.split("/")
  avatarUrl[avatarUrl.length - 1] = 0;
  avatarUrl = avatarUrl.join('/'); 
  this.setData({
    avatarUrl,city, nickName
  })
},
```







#### 页面加载时就显示用户信息

在获得了用户授权和用户信息的情况下，刷新页面或进行页面跳转，用户的个人信息还是不会显示，这是因为getUserInfo事件处理函数**点击组件时才触发**，我们需要在**页面加载时也能触发**获取用户信息才行。

我们可以在user.js的onLoad生命周期函数里输入以下代码，当用户授权之后来调用`wx.getUserInfo()` API：

```js
wx.getSetting({
  success: res => {
    if (res.authSetting['scope.userInfo']) {
      wx.getUserInfo({
        success: res => {
          let { avatarUrl, city, nickName } =res.userInfo
          this.setData({
            avatarUrl, city, nickName
          })
        }
      })
    }
  }
});
```

> 这里为了方便，只是写了一些实现功能的基础代码，在实际的项目开发中，我们可以把函数封装起来，既可以像前面的将函数写到页面文件的js里，使用`this.functionName()`来调用；还可以把函数写到独立的模块文件里，比如utils/util.js里，使用`module.exports`和`require`引入。是否封装以及封装到哪个程度，在开发之间就可以做一个大致的规划。



#### 将用户信息更新到云存储

我们可以在getUserInfo的函数里再调用uploadMsg函数将获取的用户信息更新保存到数据库里，这样小程序就不用再通过`wx.getUserInfo`来获取用户的信息，因为`wx.getUserInfo`这种方式会在一段时间和用户清空授权等情况下又需要用户授权同意才行，而将用户信息存到数据库里，该用户只需要同意授权一次就够了。

```js
//往getUserInfo里添加调用函数的代码：
getUserInfo: function (event) {
  //可以添加到this.setData()的后面
  this.uploadMsg(avatarUrl,city, nickName)
},

async uploadMsg(avatarUrl,city,nickName){
  const result = await db.collection('clouddisk').where({
    _openid:'{openid}' //这里输入自己的openid, 或者不写where语句
  }).update({
    data:{
      avatarUrl,city, nickName
    }
  })
  console.log("更新结果",result)
}
```

> 这里保存的是用户头像的链接，这个链接来自微信服务器，它不是永久有效的，会在用户更新头像的时候失效，你可以看功能的需要将用户的头像下载下来存储到云存储，数据库的avatarUrl字段为云存储的fileID或https链接就可以了。头像下载的方法可以参考【用云函数实现后端能力】的【HTTP处理】章节的内容。



### 获取相册文件夹数据

#### 页面的数据获取流程图

当我们打开小程序或小程序的首页（folder页面）时，会先请求数据库，获取用户在该数据库的所有数据（由于这个数据库结构比较简单，所谓这里的“所有数据”只是一条记录）并存储到app.js的globalData，这样无论用户打开哪个页面，页面都会使用`getApp().globalData`来获取数据；当然其他页面的数据也是可以从数据库里获取数据，但是相比从globalData获取数据来说，会增加数据库的请求次数。结合前面的介绍，相册小程序的数据获取流程大致可以如下安排：

![获取数据流程图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/357104dea48e4728914606fbcbd5bff3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)









#### 获取相册文件夹数据

在首页folder.js里，如果用户在数据库里有数据，我们可以把数据存储到全局对象globalData里，而用于渲染展示相册、文件夹信息的folder、album页面等更多页面，都可以从globalData里获取数据，比如我们可以在album.js里写如下代码：

```javascript
const app = getApp()
Page({
  data: {
    userData:{}
  },

  onLoad: function (options) {
    this.setData({
      userData:app.globalData.userData
    })
    console.log(this.data.userData)
  },

})
```

> 由于个人相册只是一个功能比较简单的小项目，我们在设计数据库时，将单个用户的相册（照片）、文件夹（文件）的数据都存储到了一个记录里面（也就是反范式化设计）。如果你希望用户存储的照片、文件数量在几万以上或存储更多内容比如文章、评论，这可能导致一个记录的大小有好几M（记录上限不能超过16M），数据库的性能会受到影响。在后面的博客小程序，我们会介绍如何范式化设计数据库。



# 相册文件夹管理

在小程序端创建一个相册/文件夹，需要考虑三个方面，

* 一是相册/文件夹在云存储里是怎么创建的；
* 二是相册/文件夹在数据库里的表现形式；
* 三是小程序端页面应该怎么交互才算是创建了一个相册/文件夹。

将小程序端要展示的交互界面（功能）转化为函数的逻辑（含API）与以不同形式存储的数据类型是应用开发的核心。

## 相册文件夹的表现形式

#### 相册/文件夹在数据库里的表现形式

尽管相册/文件夹在小程序端的页面交互看来非常复杂，但是它在数据库的形式看起来却非常简单，根据前面的数据库设计，创建一个相册/文件夹在数据库里只是把该相册/文件夹的名称更新到该用户在数据库的记录对应的字段（albumName、folderName）里：

```js
"albums": [  
  {
    "albumName": "风景", 
    "photos": [ ]
  },
  {
    "albumName": "家庭", 
    "photos": [ ]
  }
],
"folders": [  
  {
    "folderName": "工作周报",
    "files": [ ]
  },
  {
    "folderName": "电子书", 
    "files": [ ]
  }
]
```

将UI交互里的元素比如分类、标题、图标、图片、时间、标签、按钮等等，能够转化为数据库的集合、记录、字段以及字段数据类型的设计是开发项目非常关键的一步。



### 云存储的二级目录

在云存储里应该怎样创建一个二级目录呢？我们可以在调用`wx.cloud.uploadFile`接口时在cloudPath的前面加一个文件路径就可以了，比如：

```js
const cloudPath = `cloudbase/${Date.now()}-${Math.floor(Math.random(0,1)*1000)}` + filePath.match(/.[^.]+?$/)[0]
```

也就是说直接在cloudPath里添加二级目录即可，这段代码会自动在云存储里创建一个cloudbase的二级目录，不必手动创建。

不过相册小程序可能使用的用户会比较多，如果是使用用户创建的相册/文件夹名称来作为云存储的二级目录存在两个问题，一是不推荐使用中文名称（文件目录和文件名），二是可能用户创建的名称会重复。比较好的方式是使用用户的openID作为云存储的二级目录名来区分不同用户，而用户在小程序端创建的文件夹和相册名称可以不必体现在云存储的文件结构上（也可以体现，但非必要），也就是说一个用户所有的照片、文件可以都放在一个文件夹里。而且存储在云存储的相册名、文件名也建议修改为时间戳、随机数构成的名称。

用户在小程序端创建的相册/文件夹（文件结构、名称），无论是在数据库还是在云存储的文件夹结构上并没有直接的体现。哪个用户创建了哪些相册/文件夹以及每个相册/文件夹里都有一些什么文件，都是使用数据库来进行联系和管理的。





## 相册/文件夹的渲染

前面我们已经在folder.js通过数据库请求的方式获取了相册/文件夹的数据UserData（也就是该用户在集合里的整个记录），并把userData赋值给了app.js的全局对象globalData。在渲染数据到页面之前，我们可以使用云开发控制台数据库标签页里的高级操作往数据库里添加一些假数据。

要将数据渲染到页面，首先我们要善于通过打印的方式来了解到底有没有返回数据，返回了哪些数据，返回的数据是什么结构、什么类型的，尤其是文档型数据库，它返回的数据有多层嵌套，处理数据时要勤于打印，不能乱猜乱蒙。



比如这里的userData就是一个数组Array，通过符号的`[]`以及展开的数据结构就能了解，而在folder页面要渲染的是userData数组第一项里的folders数组里的值，folder.wxml页面的渲染代码如下：

```xml
<block wx:for="{{userData[0].folders}}" wx:for-item="folder" wx:key="item">
    <view>文件名：{{folder.folderName}}</view>
    <view>文件夹内文件数量：{{folder.files.length}}</view>
</block>
```

而相册album和文件夹folder在数据渲染的处理方式是一样的，只是在UI设计的外观（CSS）和交互（事件处理）上有所不同。这里的`folder.files.length`用到的是JavaScript的Aarray的属性。

由于数据库里是没有数据的，所以小程序端页面渲染是空白的，不过我们借助于JavaScript函数、数据库脚本或云开发控制台等方式就能往数据库里添加一些模拟的“假数据”，比如我们在云开发控制台的数据库标签页里的高级操作脚本执行如下代码：

```js
db.collection('clouddisk').where({
  //注意由于管理端（如云开发控制台）没有用户的登录态，所以不能使用'{openid}'，可以使用_id或填写自己的openid
  _openid:'"oPZis4n0e8D3JSPcSEoesFnAav-s" //换成自己的openid
})
.update({
  data:{
    "albums": [{
      "albumName": "风景", 
      "photos": [ ]
      }],
    "folders": [{
      "folderName": "工作周报",
      "files": []  //空文件夹，只有文件夹名
    },
    {
      "folderName": "电子书", 
      "files": [{   //有两个文件
        "name": "傲慢与偏见",  
        "fileID": "", 
        "comments": "中英双语版"
      },{
        "name": "史记",  
        "fileID": "",
        "comments": "史圣司马迁，二十四史之首"
      }]
    }]
  }
})
```





## UI交互与相册/文件夹的创建



### UI交互与WeUI组件

尽管从开发的角度讲，我们可以直接往数据库里添加数据并渲染到前端，不过对于用户而言，在小程序端除了需要使用CSS美化页面以外，还需要一定的交互。比如在创建文件夹时，我们希望通过点击一个button按钮，弹出一个新建文件夹窗口，我们在这个窗口里输入文件夹名称，点击“确定”就可以创建文件夹，创建文件夹之后，这个弹出的窗口自动关闭。

这些交互我们可以通过JavaScript来控制WeUI封装好的组件、小程序API等来完成，

```js
//在folder.wxml里输入以下代码
<button bindtap="showDialog">新建文件夹</button>
<mp-dialog title="新建文件夹" show="{{dialogShow}}" bindbuttontap="createFolder" buttons="{{buttons}}">
  <input name="name" placeholder='请输入文件夹名' auto-focus value='{{inputValue}}' bindinput='keyInput'></input>
</mp-dialog>

//在folder.json里引入WeUI封装的一些组件，你可以视情况将没有用到的部分组件给删掉
{
  "usingComponents": {
    "mp-cells": "/weui-miniprogram/cells/cells",
    "mp-cell": "/weui-miniprogram/cell/cell",
    "mp-slideview": "/weui-miniprogram/slideview/slideview",
    "mp-dialog": "/weui-miniprogram/dialog/dialog",
    "mp-form": "/weui-miniprogram/form/form",
    "mp-toptips": "/weui-miniprogram/toptips/toptips"
  },
  "navigationBarTitleText": "文件夹列表"
}

//在folder.js里输入以下代码
Page({
  data: {
    userData:[],
    dialogShow:false,
    showOneButtonDialog: false,
    buttons: [{text: '取消'}, {text: '确定'}],
    oneButton: [{text: '确定'}],
    inputValue:""
  },
  onLoad: function (options) {
  },
  showDialog(){
    this.setData({
      dialogShow:true
    })
  },
```

通过前面的分析可知，在小程序端创建相册/文件夹，只需要更新数据库的字段，而不需要操作云存储，我们来看具体的代码实现。



### 使用push更新操作符

在folde.js里输入以下代码，首先我们需要获取input里面输入的文件名，然后将文件名使用数组更新指令push到数据库的folders字段，这就相当于创建了一个文件夹了：

```js
  keyInput(e) {
    this.setData({ inputValue: e.detail.value })
  },

  async createFolder(e){
    const folderName = this.data.inputValue
    if(e.detail.index === 0){
      this.setData({
        dialogShow:false
      })
    }else{
      this.setData({
        dialogShow:false
      })
      const result = await db.collection("clouddisk").where({
        _openid:'{openid}'
      })
      .update({
        data:{
          folders:_.push([{"folderName":folderName,files:[]}])
        }
      })
      console.log("数据更新结果",result)
      wx.reLaunch({
        url: '/pages/folder/folder'
      })
    }
  },
})
```



> 每个用户都会在数据库里创建一个记录，而在对数据库进行增删改查时，我们都会使用`.where({_openid:'{openid}'})`让用户只能操作属于自己的那条记录，所以用户只能看到自己创建的相册/文件夹，也只能对创建的相册/文件夹有操作权限，用户与用户之间不会出现冲突。这种数据库的设计只适用于网盘这种对权限有要求的场景，如果你希望用户A上传的相册/文件夹能被其他用户看到（查询），或用户B能够操作（增加或删除）用户A上传的相册/文件夹，就需要调整一下权限了。



# 照片文件管理

当用户在小程序端随机选择一个相册/文件夹，在程序的处理上用户是怎样就能看到这与之相应的照片/文件列表页面？而当用户在这个列表的页面上传照片/文件时，又是怎么将照片/文件上传到指定的这个列表里的并保存文件名的？维系用户（含权限）、相册/文件夹、照片/文件三者之间关系的核心仍然是数据库，这些看似复杂功能的背后也同样只是JavaScript对不同数据类型的操作。

## 数组的index与交互

页面交互里的点击某个相册/文件夹链接，就能打开与之相应的照片/文件的列表页，首先需要让链接携带包含该相册/文件夹唯一id的参数，然后在列表页能够获取这个参数，再根据这个唯一id来查找相应的照片/文件的数据并渲染到页面上。

不过由于我们在设计数据库时，并没有给每个相册/文件夹设置id这个字段，但是我们可以借助于数组的index，userData的里的folders、albums就是数组，而每个相册/文件夹的index值都是按照顺序且唯一的。

我们再来回顾一下链接携带参数以及提取参数的知识，在folder.wxml页面的组件的链接里添加`/pages/file/file?index={{idx}}`，再在file.js的生命周期函数onLoad的options将参数提取出来：

```js
//在folder.wxml通过链接携带index的参数，注意这个index与列表渲染相关
<block wx:for="{{userData[0].folders}}" wx:for-index="idx" wx:for-item="folder" wx:key="item">
    <mp-cell link hover url="/pages/file/file?index={{idx}}" value="{{folder.folderName}}"
        footer="{{folder.files.length}}">
    </mp-cell>
</block>

//在file.js生命周期函数onLoad的options，我们可以提取链接携带的index
const app = getApp()
Page({
  data: {
    folderIndex: null,
    folerData:[]
  },

  onLoad: function (options) {
    this.setData({  //将获取到的index赋值给folderIndex
      folderIndex: parseInt(options.index),  //将字符串转为Number类型
    })

    const index = parseInt(options.index) 
    this.setData({  //根据获取到的index，将指定（该index）的folders数据赋值给folerData
      folderData: app.globalData.userData[0].folders[index]
    })
    console.log("赋值了一个啥", this.data.folderData)
  },

})

//从这里我们可以判断我们打开的到底是列表里的第几个相册/文件夹，因为数组是从0开始计数，所以+1
<text>你打开的是第{{folderIndex+1}}个文件夹</text>

//渲染数据指定id的文件夹内的文件列表到页面
<block wx:for="{{folderData.files}}" wx:for-index="idx" wx:for-item="file" wx:key="item">
  <mp-cell hover value="{{file.name}}"></mp-cell>
</block>
```



### 上传单个文件到文件夹

相信大家都应该在其他小程序体验过文件上传的功能，在交互上这个功能虽然看起来简单，但是在代码的逻辑上却包含着四个步骤：

1. 首先把文件上传到小程序的临时文件，并获取临时文件地址以及文件的名称；
2. 将临时文件上传到云存储指定云文件里，并取到文件的FileID；
3. 将文件在云存储的FileID和文件的名称更新到数据库；
4. 获取文件夹内所有文件的信息。



#### 上传文件到小程序的临时文件

使用开发者工具在file.wxml里输入以下代码：

```xml
<form bindsubmit="uploadFiles"> 
   <button type="primary" bindtap="chooseMessageFile">选择文件</button>
   <button type="primary" formType="submit">上传文件</button>
</form>
```



然后在file.js里输入以下代码：

```js
chooseMessageFile(){
  const files = this.data.files
  wx.chooseMessageFile({
    count: 5,
    success: res => {
      console.log('选择文件之后的res',res)
      let tempFilePaths = res.tempFiles
      for (const tempFilePath of tempFilePaths) {
        files.push({
          src: tempFilePath.path,
          name: tempFilePath.name
        })
      }
      this.setData({ files: files })
      console.log('选择文件之后的files', this.data.files)
    }
  })
}
```



#### 将临时文件上传到云存储

```js
uploadFiles(e) {
  const filePath = this.data.files[0].src
  const cloudPath = `cloudbase/${Date.now()}-${Math.floor(Math.random(0, 1) * 1000)}` + filePath.match(/.[^.]+?$/)
  wx.cloud.uploadFile({   
    cloudPath,filePath
  }).then(res => {
    this.setData({
      fileID:res.fileID
    })      
  }).catch(error => {
    console.log("文件上传失败",error)
  })
},
```



#### 将文件信息存储到数据库

```js
addFiles(fileID) {
  const name = this.data.files[0].name
  const _id= this.data.userData.data[0]._id
  db.collection('clouddisk').doc(_id).update({
    data: {
      'folders.0.files': _.push({
        "name":name,
        "fileID":fileID
      })
    }
  }).then(result => {
    console.log("写入成功", result)
    wx.navigateBack()
  }
  )
}
```



> 尽管我们已经往文件夹里上传了文件，但是这个文件却并没有及时的渲染出来，这是因为为了减少页面对数据库的请求，我们只在folder页面的onLoad生命周期函数里查询了一次数据库，其他页面都是通过app.globalData来获取数据，也就是如果不重新加载folder页面，数据就不会及时更新。要将用户上传的文件及时渲染出来，有两种方式，一是通过页面的生命周期函数触发数据库的get查询；二是将新上传的文件数据使用concat到app.globalData里或放到缓存里，不去请求数据库，在UI交互上，用户同样可以及时看到新文件被及时渲染，但是事实上这个数据并不来自数据库，也不是真正最终的查询结果。这种“假象”非常适用于一些对交互、性能有一定要求的场景。































































