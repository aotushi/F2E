# 生命周期



## 是什么

> 生命周期指的是小程序App和页面Page从被打开到被关闭、卸载的过程，这个过程包含多个有顺序的阶段，比如初始化、资源是否加载完成、页面是否被显示、用户是否将小程序或页面切换到了后台、用户是否卸载了页面等。



## 构造器

> 生命周期指的是小程序App和页面Page从被打开到被关闭、卸载的过程，这个过程包含多个有顺序的阶段，比如初始化、资源是否加载完成、页面是否被显示、用户是否将小程序或页面切换到了后台、用户是否卸载了页面等。



### 小程序构造器和页面构造器

App() 必须在 app.js 中调用，必须调用且只能调用一次，从技术文档我们可以了解小程序构造器有如下属性与方法

```js
App({
  onLaunch: function (options) { //监听小程序初始化
  },
  onShow:function(options){      //监听小程序启动或切前台
  },
  onHide:function(){      //监听小程序切后台
  },
  onError:function(msg){     //错误监听函数     
  },
  onPageNotFound:function(){ //页面不存在监听函数
  },
  onUnhandledRejection:function(){//未处理的 Promise 拒绝事件监听函数   
  },
  onThemeChange:function(){//监听系统主题变化
  }
})
```



Page()则需要写在每个小程序页面的js文件里面来注册小程序中的一个页面，页面构造器有如下属性和方法，而其中onLoad、onShow等就是页面的生命周期函数：

```js
Page({
  data: {//页面的初始数据
  },
  onLoad: function(options) {//监听页面加载
  },
  onShow: function() {//监听页面显示
  },
  onReady: function() {//监听页面初次渲染完成
  },
  onHide: function() {//监听页面隐藏
  },
  onUnload: function() {//监听页面卸载
  },
  onPullDownRefresh: function() {//监听用户下拉动作
  },
  onReachBottom: function() {//页面上拉触底事件的处理函数
  },
  onShareAppMessage: function () {//用户点击右上角转发
  },
  onPageScroll: function() {//页面滚动触发事件的处理函数
  },
  onResize: function() {//页面尺寸改变时触发
  },
  onTabItemTap:function(){//当前是 tab 页时，点击 tab 时触发
  }
})
```



### 页面全局变量

我们可以在`Page({})`对象前添加一些变量，比如我们声明了一个user变量：

user变量可以在Page({})对象的生命周期函数里访问，因为user变量定义在了Page之外，它是整个页面的全局变量

```js
const user = {name:"李东bbsky",address:"深圳"} 
console.log(user.address) //之前介绍过，这里可以访问user对象
Page({
  data: {
    title:"技术杂役"
  },
  onLoad: function(options) {
    console.log(this.data.title)
    console.log(user.name)  //在生命周期函数里访问user对象
  },
})
```



### 页面全局变量变种

全局变量也是相对的，比如我们把变量声明在Page外，这个变量就是Page的全局变量，而有些变量我们可以声明在生命周期函数或事件处理函数的里，如在页面的js里执行以下代码:

对于`this.setData`而言，movielist就是一个全局变量。

```js
Page({
  data: {
    title:""
  },

  onLoad: function (options) {
    const movielist=["肖申克的救赎","霸王别姬","这个杀手不太冷"]
    this.setData({
      title:movielist[1]
    })
    console.log(this.data.title)
  },
})
```



## 生命周期函数

### 小程序生命周期

```js
onLaunch(opts) {
  console.log('onLaunch监听小程序初始化。',opts)  //全局只会触发一次
},
onShow(opts) {
  console.log('onShow监听小程序启动或切前台',opts) //会触发多次
},
onHide() {
  console.log('onHide监听小程序切后台')
},
```



### 页面生命周期

```js
onLoad: function(options) {
  console.log("onLoad监听页面加载",options)
},
onReady: function() {
  console.log("onReady监听页面初次渲染完成")
},
onShow: function() {
  console.log("onShow监听页面显示")
},
onHide: function() {
  console.log("onHide监听页面隐藏")
},
onUnload: function() {
  console.log("onUnload监听页面卸载")
},
```



### 生命周期函数调用api

只需要用户打开小程序、打开某个页面，把小程序切后台等情况时就能触发里面的函数。

例如在app.js的onLaunch生命周期函数里调用`wx.showLoading`的接口，表示小程序正在加载中：

```js
App({
  onLaunch: function () {
    wx.showLoading({
      title: "正在加载中",
    })
  },
  globalData: {

  }
})
```

执行之后我们会发现”正在加载中“的loading动画一直都会在，因为我们需要在表示资源加载完成的生命周期函数里调用`wx.hideLoading`来隐藏这个loading动画，比如小程序 onShow 生命周期函数：

```js
App({
  onLaunch: function () {
    wx.showLoading({
      title: "正在加载中",
    })
  },
  onShow (options) {
    wx.hideLoading({
      success: (res) => {
        console.log("加载完成，所以隐藏掉了")
      },
    })
  },
  globalData: {

  }
})
```



### 小程序进入场景值

在App的onLaunch和onShow打印的对象里有一个scene为1001，这个是场景值。场景值用来描述用户进入小程序的路径方式。用户进入你的小程序的方式有很多，比如有的是扫描二维码、有的是长按图片识别二维码，有的是通过微信群进入的小程序，有的是朋友单聊进入的小程序，有的是通过公众号进入的小程序等等，这些就是场景值，而具体的场景值，可以看技术文档，场景值对产品、运营来说非常重要。

**技术文档：**[场景值列表](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Freference%2Fscene-list.html)

```js
App({
  onLaunch: function (options) {
    console.log('打印小程序启动时的参数',options)
  },
})
```

在options对象里就包含secne这个属性值

```js
path: "" //页面路径
query: {} //页面的参数
referrerInfo: {} //来源小程序、公众号或 App 的 appId
scene: 1047 //场景值
shareTicket: //带 shareTicket 的转发可以获取到更多的转发信息，例如群聊的名称以及群的标识 openGId
```





# 小程序函数与调用



## 给构造器添加函数或数据变量

### 小程序的全局变量

可以在app.js的App({})里添加一个数据变量globalData对象、tcbData对象来存放整个小程序都会使用到的数据：

```js
App({
  globalData: {
    userInfo:{
      username:"李东bbsky",
      title:"杂役"
    }
  },

  tcbData: {
    title:"云开发训练营",
    year:2019,
    company:"腾讯Tencent"
  },
})
```



### 小程序的全局变量调用

需要用到`getApp()`来获取小程序全局唯一的App实例，就可以在其他任意页面调用到app.js里声明的数据变量了。

```js
const app = getApp() 

//在Page外调用
console.log(app.globalData.userInfo.username)
console.log(app.tcbData.title)
console.log(app)
Page({
  //在data对象里调用
  data: {
    userInfo:app.globalData.userInfo
  },

  //在生命周期函数里面调用
  onLoad: function (options) {
    console.log(app.globalData.userInfo.username)
    console.log(app.tcbData.title)
    console.log(app)
    console.log(this.data.userInfo)
  }
})
```

如果我们想在app.js里调用globalData、tcbData对象里的数据，只需要使用this即可，不要使用`getApp()`。



### 函数的调用

有的时候要执行一个功能需要写很多个函数，或者有时候我们希望能够把一些特定的功能给封装成一个函数，如果把这些函数整个都写到生命周期函数或事件处理函数里面来调用就很不方便了。

比如一个博客小程序每篇文章发布成功之后，最好给用户一个发布成功的反馈以及会返回上一页，也就是一个功能里面需要执行多个函数，而且这个功能还比较常用，我们可以用如下方式：

```js
Page({
  onLoad: function (options) {
    this.publishSuc() //this调用的是我们封装好的函数publishSuc
  },

  publishSuc(){
    wx.showToast({
      title: '文章发布成功',
      icon: 'success',
      duration: 1000
    },
    setTimeout(function() {
			wx.navigateBack({
				delta: 1
			})
		},2000))
  }
})
```

上面的案例没有给函数传递参数，回顾前面形参和实参的知识，我们可以在调用函数的时候用如下的方法传递参数，message和title的名称虽然不一样，但是也没有关系：

```js
Page({
  onLoad: function (options) {
    const message = "发布失败"
    this.publishSuc(message)
  },

  publishSuc(title){
    wx.showToast({
      title: title,
      icon: 'success',
      duration: 1000
    })
  }
})
```

> 在小程序页面的js文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。



# 用户登录与信息获取

## 了解wx.login wx.getSetting

```js
App({
  onLaunch: function () {
    wx.login({
      success(res){
        console.log('wx.login得到的数据',res)
      }
    })
 
    wx.getSetting({
      success(res){
        console.log('wx.getSetting得到的数据',res)
      }
    })
  },
 
  globalData: {
    userInfo: null
  }
})
```



wx.login返回的res对象里会包含errMsg和code，这个code是用户的登录凭证。

wx.getSetting返回的res对象里包含errMsg和用户当前的[权限设置authSetting](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Fsetting%2FAuthSetting.html)，包含是否允许获取用户信息，是否允许获取用户位置，是否允许使用手机相册等权限。我们可以根据打印的结果结合技术文档来深入理解。

**技术文档：**[获取用户登录凭证wx.login](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Flogin%2Fwx.login.html)

**技术文档：**[获取用户登录凭证wx.login](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Flogin%2Fwx.login.html)

> 如果要让小程序和自己的服务器账号打通，仅仅获取用户登录凭证是不够的，需要将这个code以及你的小程序appid和appSecret传回到你的开发服务器，然后在自己的服务器上调用[auth.code2session](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi-backend%2Fopen-api%2Flogin%2Fauth.code2Session.html)接口，得到用户的openid和session_key。由于openid是当前用户的唯一标识，可以用来判断该用户是否已经在自己的服务器上注册过，如果注册过，则根据openid生成自定义登录态并返回给小程序，整个过程非常复杂。
>
> 而由于**云开发与微信登录鉴权无缝整合**，这些内容都不会涉及，所以这里不多介绍。



## 获取用户信息wx.getUserInfo

我们要获取用户信息，首先需要判断用户是否允许，可以从authSetting对象里看scope.userInfo属性是否为true，如果为true，那我们可以调用wx.getUserInfo()接口来获取用户信息。

使用开发者工具给上面的wx.getSetting()函数添加内容，最终代码如下：

```js
wx.getSetting({
  success(res) {
    console.log('wx.getSetting得到的数据', res)
    if (res.authSetting['scope.userInfo']) {
      wx.getUserInfo({
        success(res) {
          console.log('wx.getUserInfo得到的数据: ', res)
        }
      })
    }
  }
})
```



## globalData

用户信息的数据是所有页面都需要用到的，放在**app.js**里公用是应该的，但是我们要怎么才能调用到这个数据呢？

在上面的wx.getUserInfo的success回调函数里将获取到的userInfo对象赋值给globalData对象的userInfo属性。

```js
wx.getUserInfo({
    success(res){
    console.log("wx.getUserInfo得到的数据",res)
    this.globalData.userInfo = res.userInfo
  }
})
```

但是会提示 `Cannot read property 'globalData' of undefined;`报错



### 无法访问this的解决方案

#### 使用箭头函数

```js
wx.getSetting({
  success: (res) => {
      if (res.authSetting['scope.userInfo']) {
        wx.getUserInfo({
          success(res) {
            that.globalData.userInfo = res.userInfo
          }
        })
      }
  }
})
```





#### 使用变量that

```js
let that = this;    
wx.getSetting({
      success(res) {
        if (res.authSetting['scope.userInfo']) {
          wx.getUserInfo({
            success(res) {s
              that.globalData.userInfo = res.userInfo
            }
          })
        }
      } 
    })
```



## getApp()

如何在页面的js里调用globalData呢，这个时候就需要用到getApp()函数啦。

**技术文档：**[getApp()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Freference%2Fapi%2FgetApp.html)

例如我们在user页面中访问globalData中的数据.

在user.js的Page()函数前面添加如下代码：

```js
let app = getApp()
console.log('user页面打印的app', app)
console.log('user页面打印的globalData', app.globalData.userInfo)
console.log('user页面打印的tcbData',app.tcbData.eventInfo)
```

这样我们就能获取app.js里的globalData和自定义的属性了。

> 这里还会有一个问题，就是尽管我们已经获取到了globalData，我们也能在globalData.userInfo的打印日志里看到用户的信息，但是当我们想获取里面的值时，还是会报错，这是因为 wx.getUserInfo是异步获取的信息，这里涉及到的异步，我们之后会详细介绍。





## 通过button获取用户信息

 在我们使用wx.getUserInfo的方式来获取用户信息时，控制台会报错：获取 wx.getUserInfo 接口后续将不再出现授权弹窗，请注意升级。也就是小程序官方已经不建议开发者用wx.getUserInfo来获取用户信息，而是建议通过button的方式来获取，对用户的体验更好，也就是**只有用户点击了按钮，用户信息才会被获取**。

创建一个button组件，要获取到用户信息，有两个必备条件，一是 open-type="getUserInfo"，必须是这个值；二是绑定事件处理函数的属性名为bindgetuserinfo（类似于bindtap，但是属性名必须为bindgetuserinfo，至于事件处理函数的名称可以自定义）

```js
<button open-type="getUserInfo" bindgetuserinfo="getUserInfomation"> 点击获取用户信息 </button>
```

这里的getUserInfomation和之前点击事件的事件处理函数是一致的，点击组件触发getUserInfomation，仍然会收到事件对象，我们把它打印出来，在user.js里添加以下代码：

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
},
```

当我们点击“**点击获取用户信息**”的button按钮后，在控制台可以查看到getUserInfomation打印的事件对象，事件对象里有个detail属性，里面就有userInfo的数据.

页面中获取用户信息的固定套路:

1.首先在页面中data对象中初始化一个userInfo对象,用来接收数据

```js
data: {
  userInfo: {}
}
```

2.然后在事件处理函数getUserInfomation获取到的userInfo通过this.setData赋值给它，也就是getUserInfomation的函数为

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
  this.setData({ 
    userInfo: event.detail.userInfo, 
  })
},
```

3.获取到用户信息,可以在wxml文件中使用

```js
<view>{{userInfo.nickName}}</view>
<view>{{userInfo.country}}</view>
<image mode="widthFix" style="width:64px;height:64px" src="{{userInfo.avatarUrl}}"></image>
```



## 将用户信息写进app.js

上面这种方式只能在页面中才能获取到用户信息，限制非常大，那我们应该怎么做呢？

我们要把获取到的用户信息写到app.js成为页面的公共信息，以后可以跨页面只需在user页面点击一次按钮即可。

在getUserInfomation将获取到的用户信息传给globalData的userInfo属性：

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
  app.globalData.userInfo = event.detail.userInfo
  this.setData({ 
    userInfo: event.detail.userInfo, 
  })
},
```



> 获取用户信息还有一种方式，就是通过组件`<open-data>`来展示







# 云函数

> 云函数可以以函数的形式自动运行后端代码以响应API调用和HTTPS触发的事件，开发者只需关注业务代码本书，无需关心后端运维、计算资源等，平台会根据负载自动进行扩缩容。各个云函数相互独立，执行环境相互隔离。



## 云函数快速入门

云函数在操作上与以往的开发方式会有所不同，不过它依然还是JavaScript知识的应用。在这一章，我们会来讲解云函数如何新建、如何部署、如何调用，在操作上我们需要注意哪些细节等。



### 云函数的新建和调用

#### 新建一个云函数

使用开发者工具，鼠标右键云函数根目录如cloudfunctions，在弹出的窗口选择**新建Node.js云函数**，然后输入云函数的名称比如`sum`(可以先右键同步云函数列表，保证没有重名),按Enter确认后，微信开发者工具会在本地（你的电脑）创建出**sum云函数目录**，同时也会在线上环境中创建出对应的云函数（也就是自动部署好了，可以到云开发控制台云函数列表里看到）。

```md
cloudfunctions //云函数根目录       
├── sum // 云函数目录
│   └── index.js 
│   └── config.json
│   └── package.json  //云函数的Node包管理
miniprogram //小程序根目录  
├── ...    
```

打开sum云函数目录下的index.js并将里面的代码修改为如下，然后右键index.js文件，选择**云函数增量上传:（更新文件）**，这样一个用来求两个参数之和的云函数就更新好了：

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV }) // 使用当前云环境

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  const sum = event.a + event.b
  return {
    sum,
    event,
    openid: wxContext.OPENID,
    appid: wxContext.APPID,
    unionid: wxContext.UNIONID,

  }
}
```

这里的`event`对象指的是触发云函数的事件，在小程序端调用时，`event`是小程序端调用云函数时传入的参数对象，也就是说要计算`sum`，我们需要在小程序端调用云函数时传入两个参数`a`和`b`。



#### 云函数的调用

在小程序中调用这个云函数前，我们还需要先将该云函数部署到云端。在云函数目录上右键，在右键菜单中，我们可以将云函数整体打包上传并部署到线上环境中。

部署完成后，我们可以在小程序中调用该云函数.

要调用云函数有**很多种方式**，比如我们可以在调试器的console控制台调用接口、在生命周期函数里调用，还可以通过组件绑定一个事件处理函数来调用等等，这些方式都是大同小异，都是在调用`wx.cloud.callFunction()`接口。

两种调用方式:

```js
wx.cloud.callFunction({
  // 云函数名称
  name: 'add',
  // 传给云函数的参数
  data: {
    a: 1,
    b: 2,
  },
  success: function(res) {
    console.log(res.result) // 3
  },
  fail: console.error
})
```



```js
wx.cloud.callFunction({
  name: 'sum',    // 要调用的云函数名称，这里为sum
  data: {         // 传递给云函数的event参数，这里为a和b
    a: 15,
    b: 23,
  }
}).then(res => {
  console.log("云函数返回的结果",res.result)
}).catch(err => {
  console.log("云函数调用失败",err)
})
```

返回值res.result就是云函数返回的对象.



#### 云函数的返回值与渲染

使用开发者工具将sum云函数的代码修改为如下，我们让云函数返回更多类型的数据，修改完之后，右键index.js文件，选择**云函数增量上传:（更新文件）**：

```js
```

> 值得注意的是，云函数返回的时间和小程序端返回的时间(北京时间)是不一样的，这是因为云函数中的时区为 UTC+0，不是 UTC+8，格式化得到的时间和在国内的时间是有8个小时的时间差，但是时区不会影响时间戳，所以尽量不要在云函数端将时间字符串化。



### 云函数的初始化

#### 关于wx-server-sdk

wx-server-sdk是微信小程序服务器端的SDK，SDK包括用于微信免鉴权的私有协议、云数据库、云存储、云调用等基础能力，因此每一个云函数都会使用到wx-server-sdk这个Node包。由于每个云函数实例之间是相互隔离的（没有公用的内存或硬盘空间），所以每个云函数都要求**单独**安装wx-server-sdk，Node包在云函数实例之间不存在复用的关系。而要调用这个包都需要安装好Node.js环境才能在本地电脑的开发者工具进行本地调试。

给云函数安装依赖时，在开发者工具上右键云函数目录如sum，选择开发者工具自带的终端（更建议）或外部终端窗口，直接输入`npm install`即可。npm包管理器自动会安装好package.json的dependencies写好的包，可以将wx-server-sdk的版本号换成latest（生产环境以稳定兼容的版本为准）：

```json
"dependencies": {
  "wx-server-sdk": "latest"
}
```

sum安装好node依赖之后，就会在云函数目录里有一个node_modules的文件夹。当我们要将本地的云函数部署到云开发环境时，可以右键云函数目录选择**上传并部署所有文件**（更建议）或**上传并部署：云端安装依赖（不上传node_modules）**。

如果云函数本地没有安装依赖，就没法在开发者工具对云函数进行本地调试，部署上传云函数时，选择**上传并部署所有文件**就会报错，截图如下：

![4bfa24048d6f487b995a613ddbc5dc34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp (996×364) (byteimg.com)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bfa24048d6f487b995a613ddbc5dc34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

wx-server-sdk只是云函数必备的一个依赖，云函数还可以通过package.json安装更多功能丰富的Node包。当在package.json里新增了其他依赖时，都需要使用`npm install`进行依赖的下载。



#### 云函数的初始化

在云函数中调用其他API前，同小程序端一样，也需要执行一次初始化方法，首先使用require引入wx-server-sdk依赖，然后在初始化`cloud.init()`中指定云开发的环境，方法如下：

```js
const cloud = require('wx-server-sdk')
// 给定字符串环境 ID：接下来的 API 调用都将请求到环境 some-env-id
cloud.init({
  env: 'some-env-id'
})
```

或者

```js
const cloud = require('wx-server-sdk')
// 给定 DYNAMIC_CURRENT_ENV 常量：接下来的 API 调用都将请求到与该云函数当前所在环境相同的环境
// 请安装 wx-server-sdk v1.1.0 或以上以使用该常量
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
```



以上两种方法对应的的实际案例:

```js
//方法一，直接使用字符串envId指定环境
const cloud = require('wx-server-sdk')
cloud.init({
  env: 'xly-9gssrn8d637383e4' //换成你的云函数envId
})

//方法二，使用cloud.DYNAMIC_CURRENT_ENV常量，也就是使用云函数当前所在环境
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV //注意它不是字符串，不要加引号
})
```

- 尽管直接使用`cloud.init()`不指定环境在某些特定情况下仍然可以使用，比如你的云函数就部署在你创建的第一个云开发环境里，但是非常不推荐这种写法；
- `cloud.DYNAMIC_CURRENT_ENV`标志的是云函数当前所在的环境，也就是你将云函数部署到哪个环境，它就是指哪个环境；
- 我们可以在云开发环境A直接调用同一个账号下云开发环境B的资源，只需要在云环境初始化时指定B的envId即可，在开发时切换生产环境、测试环境非常方便；
- 我们还可以在云函数里分别调用不同云开发环境里的云存储、云数据库、云函数等的资源，比如`env:{"database":"xly-xrlur","storage":"xly-1o7da","functions":"xly-oau0j"}`；
- 如果调用云函数时，提示`找不到对应的FunctionName`，可能是你的小程序账号之下有多个云开发环境，而你在云函数初始化时没有指定envId。



### 开发者工具右键操作说明

#### 同步云函数列表

当我们右键云函数根目录cloudfunctions时，会有一个**同步云函数列表**的选项，它可以拉取当前云开发环境所有云函数的列表，右键指定的云函数选择**下载**就可以将云端的代码给下载到本地电脑。也就是说，上传到云开发环境的云函数以及代码都会存储在云端，你可以在其他设备上通过这种方式进行同步，除非你在云开发控制台将这个云函数给删掉了。

当我们在开发者工具本地或使用云开发控制台将云函数删掉之后，**建议先同步云函数列表**，不然在重新上传部署同名的云函数的时会出现一些报错。





#### 新建Node.js云函数

选择**新建Node.js云函数**可以直接在云端新建一个云函数，同时会自动在云端给新建的云函数安装好wx-server-sdk依赖，并将该云函数在云端部署的情况反馈到开发者工具，即开发者工具本地的云函数目录图标会变色（注意区分同步和没有同步的云函数目录图标的不同）。



#### 增量上传? 



## 本地调试与云端测试

### 云函数的开发流程

为了能够让大家更加清楚的了解：**完整操作一个云函数的流程**以及**本地调试与云端测试的重要性**，我们以长方形的边长（a、b）求周长、面积这个简单的数学公式为例。

#### 新建云函数

首先我们右键点击**云函数根目录**（也就是**cloudfunctions文件夹**），选择**新建Node.js云函数**，函数名为长方形的英文rectangle，然后打开index.js，将代码修改为如下：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  const {width,height} = event
  console.log("长方形的周长与面积",[(width+height)*2,width*height])
  return {
    circum:(width+height)*2,
    area:width*height
  }
}
```

建好云函数之后，我们右键点击云函数目录，也就是rectangle文件夹，选择**在终端中打开**，使用npm install来安装依赖。

```bash
npm install
```



#### 本地调试云函数是否正确

对于一个复杂的云函数，我们最好是先在本地测试一下云函数是否正确，然后再部署上传到云端。

那如何本地测试呢？右键点击云函数目录，也就是rectangle文件夹，选择**本地调试**（这种方式进入本地调试会默认开启rectangle的本地调试）。

我们可以根据情况来选择**手动触发**和**模拟器触发**，使用手动触发需要我们在本地调试输入参数之后，点击**调用**：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7dfff165c7c4ff1b55c1bd7f2375c77~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们给参数宽度width和高度height赋值（**注意传递的是JSON格式，最后一个参数结尾不能有逗号,**），比如赋值为3和7：

```json
{
  "width": 3,
  "height":7
}
```

然后点击**调用**，如果显示函数执行成功(注意仍然是在调试的console标签)，并得到周长circum和面积area的结果分别为20、21，那证明云函数没有写错。

> 当开启了本地调试，我们在开发者工具调试器的console控制台（非本地调试的console标签页）调用云函数时也会调用本地的云函数。在本地调试窗口无论是选择手动触发、模拟器触发亦或是通过其他云函数来调用云函数，取决于你的云函数的调用方式，比如如果云函数调用是在页面的生命周期函数里调用，我们本地调试时就可以使用模拟器触发。



#### 云端测试云函数是否正确

云测试之前需要上传和部署, 之后打开**云开发控制台**的**云函数**标签，找到rectangle云函数，点击**云端测试**，同样我们给参数赋值，将以下代码进行修改，比如给宽度width赋值为4，高度height赋值为7，即代码修改为：

```js
{
  "width": 4,
  "height": 7
}
```

然后点击运行测试，（会等一段时间），再来查看测试的结果，如果返回结果如下，则表示在云端的云函数可以正常调用.



云函数的调用采用**事件触发模型，小程序端的调用、本地调试和云端测试**都会触发云函数的调用事件，其中本地调试调用的不是云端的云函数，而是小程序本地的云函数；而在云端测试调用云函数的结果是可以在云开发控制台云函数的日志里查看到的。

#### 云函数的在线编辑

上传到云端的云函数，我们还可以通过云开发的网页控制台（登录方式）在线修改代码。通过在线编辑，我们不仅可以检查代码是否更新成功，还可以脱离微信开发者工具、Cloudbase CLI等来临时修改代码。

**云开发网页登录**

> 我们还可以使用[腾讯云云开发网页控制台](https://link.juejin.cn/?target=https%3A%2F%2Fconsole.cloud.tencent.com%2Ftcb)来管理云开发资源，需要注意两点，一个是登录方式需要选择**其他登录方式里的微信公众号**，点击然后使用手机微信扫码，在微信上选择你要登录的小程序；二是要进入腾讯云后台之后切换选择云开发Cloudbase。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682071f1c4a241948fd5247ecaf69218~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



### return与console

#### 云函数日志

当调用云函数时，在开发者工具调试器里并没有看到console.log打印的结果，但我们可以打开**云开发控制台**–**云函数**–**日志**，**按函数名筛选**，选择rectangle云函数，可以看到云函数被调用的日志记录了（日志也可以在云开发网页控制台查看）。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f057bddb5b2a4f39a16fa7fc35d8a49d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

在云函数日志里，我们除了可以在**返回结果**里看到return返回的对象，还可以在日志里查看到云函数执行的时间点（使用的是服务端时间，时区为UTC+0），以及云函数里使用console.log打印的日志。

云函数调试的时候，不能只依赖小程序端的`wx.cloud.callFunction`使用return返回的报错，因为它只是反馈云函数的调用结果以及调用是否出现错误error，更多的还是要在云函数里使用`console.log`打印云函数在执行过程中的一些日志情况。也就是说，return只会返回中断函数执行的一些报错，而比如函数是否获取到参数，参数是什么数据类型，以及是否包含你想要的预期值，这些都需要勤使用console.log来反馈。

#### return与报错

在小程序端调用云函数时，我们经常会使用到return，return语句可以终止函数的执行并返回一个值给小程序端，因此很多人会依赖return返回的这个值来了解云函数是否获取到了最终想要的结果。对于复杂的云函数，仅仅只是使用return并不能精确定位到云函数在执行过程中哪里出错。

而小程序端的报错，只能显示云函数为什么没有等到执行return就中断了，比如以下案例集合名本为cloudbase，但是在书写的过程中，却不小心写错了：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async (event, context) => {
  return await db.collection("cloubase").where({
    _id:_.exists(true)
  }).get()
}
```

这种错误由于会中断云函数的执行，因此会被返回到小程序端，报错也会显示集合或记录不存在，截图如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3052f36b8d4533a9a532dc8975e016~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

当然出现这个报错，首先要检查你调用的集合与云数据库的集合名是否一致（或确实不存在这个集合），如果都没有问题，则需要检查云函数的初始化是否正确的选择了集合所在的云开发环境。

大多数情况下，可能云函数里并没有出现中断函数执行的错误error，但是return却并没有返回到预期的结果，比如前面介绍的rectangle云函数，我们可以在开发者工具的调试器console里调用云函数：

```js
wx.cloud.callFunction({name:"rectangle"}).then(res=>{console.log(res)})
```

在调用时，我们忘记了传入参数，或者参数名写错了，或者由于异步的问题参数其实没有值等等原因，云函数可以正常执行，但是return的值却为`result: {circum: null, area: null}`，对于这样的错误如果不通过日志，就很难反馈出来。

注意 **错误(Error)** 与 **异常(Exception)** 是完全不一样的，错误会中断JavaScript函数的执行，而异常不会导致JavaScript进程被终止，通过return只能返回错误而不能获取到异常，要获取云函数执行的异常需要通过`try..catch`的方式。



### 云函数的错误处理



#### try...catch

在云函数中，return只能返回错误，而有些异常我们可以通过`try..catch`来返回，`try..catch`的语法如下。

```js
try {
  // 代码...
} catch (err) {
  // 错误捕获
}
```

也就是如果在try块中有任何一个语句或函数抛出异常，控制会立即转向catch子句。如果在try块中没有异常抛出，则会跳过catch子句。我们写的每一个云函数都建议采用`try..catch`的方式来进行错误处理。

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async (event, context) => {
  try{
    const data = await db.collection("cloubase").where({
      _id:_.exists(true)
    }).get()
    return data
  }catch(err){
    return err
  }
}
```

前面通过return获取不到的异常，通过`try...catch`的方式就能获取到了，异常返回如下：

```js
errCode: -502005
errMsg: "[ResourceNotFound] Db or Table not exist. Please check your request, but if the problem cannot be solved, contact us.; 
```

#### error对象不支持遍历

不过对于一些异常，Node.js存在error对象的字段不支持遍历，所以序列化成字符串时会忽略所有的字段，比如下面的代码不仅集合不存在，连upData这个变量也没有声明，直接返回error显示的会为空：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async (event, context) => {
  try {
    const result =await db.collection('users').where(upData).get()
    return result
  }catch (error) {
    //return error有时候返回不了一些异常，可以通过通过返回error的具体属性
    // return { name: error.name, message: error.message, stack: error.stack }
    return error
  }
}
```

我们可以通过返回error对象的name、message、stack的方式来获取异常，如catch子句里我们可以使用`return { name: error.name, message: error.message, stack: error.stack }`，这样就可以返回报错了。



#### 云函数的日志与高级日志

不过更加建议的方式是在做云函数错误处理时结合使用console.log或高级日志的方式来记录报错，因为即使采用了`try...catch`的方式，还是有一些错误、异常无法被反馈，而console.log强大的调试测试能力却可以做到。

比如下面的一个云函数，需要我们在调用云函数时给云函数传入两个参数`a`和`b`，云函数会将获取到的参数相加并返回：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  try {
    const {a,b} = event
    const sum = a + b
    console.log("获取到的a,b,sum的值",[a,b,sum])
    return sum
  }catch (e) {
    console.log(e)
    return { name: error.name, message: error.message, stack: error.stack }
  }
}
```

如果我们在调用云函数时忘记传入参数，比如在控制台输入以下代码，即使在用了`try...catch`的情况下也是无法准确定位到错误的：

```javascript
wx.cloud.callFunction({name:"rectangle"}).then(res=>{console.log(res)})
```

我们可以在try语句打印云函数参数获取的情况`console.log("获取到的a,b,sum的值",[a,b,sum])`，在云函数的调用日志里面查看就能发现问题：

```javascript
获取到的a,b,sum的值 [ undefined, undefined, NaN ]
```

当小程序发布之后，通过筛选“调用失败”只能获取到中断云函数执行的错误，而对于一些bug或异常，则需要通过云函数日志。但是云函数调用次数非常多，而console.log日志却没办法筛选，这个时候我们可以使用云开发提供的高级日志服务。高级日志服务实现日志采集和检索分析等功能，方便开发者通过日志快速的发现和定位问题。每条日志可最长存储30天，超过 30 天的日志将被自动清理。



### 云函数的监控



#### 云函数的状态监控与消耗

在云函数日志里，我们可以看到云函数的执行时间、内存和内存消耗，比如`Duration:5ms Memory:256MB MemUsage:35.218750M`，意思是整个云函数执行时间为5ms，当前云函数的内存为256MB，内存消耗为35.218750M。

云函数的执行时间和内存是一个非常关键的指标，比如云函数执行时间可以反映该云函数的性能，如果执行时间过长，比如超过500ms，云函数就应该尽可能优化一下；而同时云函数的计费也与执行时间和内存（也就是256M，非内存消耗）相关，云函数资源使用量 = 函数配置内存（256M） X 运行计费时长（5ms）。



#### network面板

调用云函数时，我们还可以在开发者工具调试面板的NetWork标签查看调用云函数的情况。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57c6ce80da534bc684a79f37bf92c83f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)





## 云函数的调用与返回

调用云函数的方式有很多，如小程序端、管理端调用、定时触发器、HTTP访问服务、云函数等，不同的方式存在哪些差异？我们知道调用云开发资源可以通过小程序端SDK和云函数端的SDK，这两种方式有什么不同？在调用云函数的过程中，我们需要注意哪些问题？

### 云函数的传参与返回

在小程序端我们可以使用`wx.cloud.callFunction`接口调用云函数并向云函数传递参数。参数的来源和参数的数据类型有很多.

比如在小程序function页面的function.js里输入以下代码，我们知道页面js的data对象常用于事件处理的过渡，通过数据渲染可以控制小程序的页面；这里我们将data对象里面的数据以参数的形式传递给云函数：

```js
Page({
  data:{
    rectangle:{
      width:22,
      height:33,
    }
  },

  onLoad(){
    this.getData()
  },
  getData(){
    wx.cloud.callFunction({
      name:"invoke",
      data:{
        rectangle:this.data.rectangle
      }
    }).then(res=>{
      console.log("res对象",res)
    })
  }
});
```

在这里调用的云函数是invoke，那invoke云函数应该如何接收小程序端传递的参数呢？

在不熟悉或开发时建议可以先通过打印了解参数传递的状态或参数的数据类型。使用开发者工具新建一个云函数，名称如invoke，然后输入以下代码并部署上传到云端：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
exports.main = async (event, context) => {
  console.log("event对象",event)
}
```

通过invoke云函数的日志可以了解到event对象里参数的情况，然后再使用解构赋值将参数取出，如:

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
exports.main = async (event, context) => {
  console.log("event对象",event)
  const {rectangle:{width,height}} = event
  return {
    circum:(width+height)*2,
    area:width*height
  }
}
```

而在小程序端如果需要对云函数return返回的数据进一步处理，既可以使用**callback回调函数**的方式，也可以使用**Promise**的方式，还可以将获取的数据**赋值给变量**，而要对返回的数据有更清晰的了解，也通过需要在开发时多打印或调试，而不能靠蒙或猜：

```js
async getData(){
  const result = await wx.cloud.callFunction({
    name:"invoke",
    data:{
      rectangle:this.data.rectangle
    }
  })

  console.log("result对象",result) 
  const {result:{circum,area}} = result  //注意这里有两个result，有着不同的含义，注意区分，使用时也可以采用不同的变量名
  console.log({circum,area})
  this.setData({
    circum,area
  })
}
```



### 不同调用方式下的event与context

云函数的调用方式很多，不同的调用方式传入给云函数的参数对象也会有所不同。每个云函数的传入参数有两个对象：event对象和context对象。其中event对象指的是SDK触发云函数时传入的事件；而context对象则包含此调用的调用信息和函数的运行状态。采用不同的调用方式以及调用链条，返回的event对象和event对象的值是不一样的。

#### 通过打印了解event与context对象

将invoke云函数的index.js代码修改为如下，并将文件更新上传到云端，接下来我们会通过多种方式来调用这个云函数，只要云函数被触发，我们就可以在日志里查看到打印的event和context对象到底有何不同：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
exports.main = async (event, context) => {
  console.log("event对象",event)
  console.log("context对象",context)
}
```



在开发者工具调试器的console控制台调用云函数可以直接在控制台输入以下命令：

```js
//但实际上在开发者工具调试器控制台console中是获取不到云函数打印的内容的 原作者没有明确
wx.cloud.callFunction({name:"invoke"}).then(res=>{console.log(res)})

```

我们也可以把上面的代码写在其它地方:

* 小程序首页如function.js的onLoad生命周期函数里，通过开发者工具的调试以及真机调试来调用云函数；
* 而要在管理端调用云函数，可以打开云开发控制台，对该云函数进行云端测试。

打印的event对象和context对象大致如下：

```js

event对象 {
  "userInfo": {
    "appId": "wx597d2f8ac9b22e20",
    "openId": "oPZis4n0e8D3JSPcSEoesFnAav-s"
  }
}
context对象 {
  "callbackWaitsForEmptyEventLoop": true,
  "memory_limit_in_mb": 256,
  "time_limit_in_ms": 3000,
  "request_id": "f062593b-d290-4ab4-bc78-1148515a0a83",
  "environment": "{\"SCF_NAMESPACE\":\"xly-9gssrn8d637383e4\",\"TCB_CONTEXT_CNFG\":\"{\\\"TCB_SDK_GRAY_0\\\":true,\\\"URL\\\":\\\"http://169.254.0.131:80/admin\\\"}\",\"TCB_CONTEXT_KEYS\":\"TCB_ENV,TCB_SEQID,TRIGGER_SRC,TCB_ISANONYMOUS_USER,TCB_SOURCE,TCB_ROUTE_KEY,TCB_CONTEXT_CNFG\",\"TCB_ENV\":\"xly-9gssrn8d637383e4\",\"TCB_ISANONYMOUS_USER\":\"false\",\"TCB_ROUTE_KEY\":\"32\",\"TCB_SEQID\":\"1682492710193_0.6397125710806393_33614847\",\"TCB_SOURCE\":\"wx_devtools\",\"TENCENTCLOUD_SECRETID\":\"AKIDkO7dbBq-nVcv6L8bVHNNQm_Z-ftfQ_hFo9OPKb6Ze6prklOPAe46HyZwvXDgI_Uz\",\"TENCENTCLOUD_SECRETKEY\":\"aA3AHTV94u/BPYJcB1ip77fNK2pLzr77sAMW6ZuHb/o=\",\"TENCENTCLOUD_SESSIONTOKEN\":\"Y9BRSpG1HsbYj7EkTocbugZtzNHElFka92c35a08851ba738ed33911f6b9d966diKGwyuOIu9_FLk0tw2utwUSyBCbozxarzQfsS6VJeuPTJX-8rUxbagy1qy4EnQ1881RHiouAYYLGm0-AO_NBXZDEpa5NIrYzgIhqNvfAlrVD2mqECt3zFvsab-rzNLlEN7XrB4kCVTPiTXjkkirseIZXxANmh55UvcPnLMX4h-8X1JNJuIv0-g_ZjNLtxmayyDBWJY-UL1C1ornMTrpUpQU8nsOV7PNFYtXqr-ptmuJyctVZtM5nO2qVctfQ3fkOCujBAf4Uk2ME5tZntLhEUY8DgAc4DElY_Bnuc5ke-LaSyI66hcF4xvrf7qWLHXZ88lrgFQ2H3aKHQcoOKeISX8gsNkjtI2iFtFX4KW6DSDkO_M5N4eQtE3SwPZ_PJC8z\",\"TRIGGER_SRC\":\"tcb\",\"WX_API_TOKEN\":\"eyJFbmNyeXB0QWxnbyI6IkVOQ1JZUFRfQUxHT19BRVNfQ0dNIiwiVmVyc2lvbiI6MSwiS2V5VmVyc2lvbiI6MjU1LCJFbmNyeXB0S2V5IjoielZkZzRhWk9IMFdwZUFBQXcyZmNlZ0hWeFlpYytCRlpoQnNQK3RDWEorQT0iLCJ0aWNrZXQiOiJDUE1CRW9BRWd0cU1vOGZ2Y3M2ZHFWTXBoQmJBeXRTaUJEL0lGSXRPYmRkT2orME9KcTdlajQ2NE9mbkZYOVBLang1Y09JYmZObHN6L2k4MFZYb205Z3RkamFhRWFzQTVMTVNTMEVBaHIvbnJKeUZxUEFzbkNKbDA5NUxxRm5PbXB4Z3NnVE9DR2RYQ3pRRFJIMm9LNklLczFLNkFjVkdjTUw5Uzg3V1UvNU8yMkRwK1RIalhnbkg1TnVvdk1pRkwxOTNCNWxveXM1VmdpcDQ0UERSSk1PVFcyVXdLVG1nREx6N1NIbFZNWHJlSnc3cEtoNyt5R1pDUE1RL25BdGJDdDBPbkVTaHpWYW81dFoyZGJGTXRseUhJekkxdVN0NmR1dTZEWWo5WTAzNGNMb2JCbTlKV1RVRVJ0Q3d1ZGczK0FFZW8zWjNDeFFMbU9vK0p0QTFFVkJyeFJBaExTUU5ua1lXZ2t4d29GdWpqLyt5cDZNUTRsb2NVZUQxVkR0eUVxZis5VlMrY1AxUkhsZVUwVHl6Q0Z4ckgzWjRiTFRiN3RhTmNubFdubmR5T24zWmMweDRHVHlURjROdGxYOGZoamVKWWZHT2ErN1BuU2QwZ3FndkR2WHM3Q0EzZ3QrS21ONThCaGp4bzNYSnk5bDdRUExNZUZ3bzcwK01yT0M4d0VMTlo2R1hHRVAybVN3Umg0OW1iblRWVzcxNm03RG54bFlZTnV3L1ZHMU0rU2tTU3RQUjFOUTViUzF1b2ZyaEpPdnQ2eFBZcVFwOXdpclpMbGt1eFJwbTY1eGlhdE9qQmp0NDI5WWQ4Y0JCdFlLNXRjVGFJa3d4UWY0bnNtNTF1VlFJRUxOdUZ0dGlobmI2MjNXc1djVS9zZlhzZFVNNTVJYjB6VlgyWkNYRWsyUExIL0hVWUFDQUEiLCJldmVudElkIjoiSE92dGs1MHM5blQ2ZzRLRlhBVFRGMlA3NFNXQ0FJWk43eTI2MlZfWDNRdUJNRVIzcjBjMmJCenNUQWtPM2NrWC1nYVFPLTRDMEREUXEyMzZWeGoyRnJnTmFSNFdPS2plbDZHeDdjckNUQmpnIn0=\",\"WX_APPID\":\"wx597d2f8ac9b22e20\",\"WX_CLIENTIP\":\"111.194.48.127\",\"WX_CLIENTIPV6\":\"::ffff:111.194.48.127\",\"WX_CONTEXT_KEYS\":\"WX_UNIONID,WX_CLIENTIP,WX_CLIENTIPV6,WX_FROM_APPID,WX_FROM_OPENID,WX_FROM_UNIONID,WX_OPEN_DATA_INFO,WX_APPID,WX_OPENID,WX_API_TOKEN\",\"WX_FROM_APPID\":\"\",\"WX_FROM_OPENID\":\"\",\"WX_FROM_UNIONID\":\"\",\"WX_OPENID\":\"oPZis4n0e8D3JSPcSEoesFnAav-s\",\"WX_OPEN_DATA_INFO\":\"\",\"WX_UNIONID\":\"\"}",
  "environ": "WX_FROM_OPENID=;WX_OPENID=oPZis4n0e8D3JSPcSEoesFnAav-s;WX_CONTEXT_KEYS=WX_UNIONID,WX_CLIENTIP,WX_CLIENTIPV6,WX_FROM_APPID,WX_FROM_OPENID,WX_FROM_UNIONID,WX_OPEN_DATA_INFO,WX_APPID,WX_OPENID,WX_API_TOKEN;TCB_ISANONYMOUS_USER=false;TENCENTCLOUD_SECRETID=AKIDkO7dbBq-nVcv6L8bVHNNQm_Z-ftfQ_hFo9OPKb6Ze6prklOPAe46HyZwvXDgI_Uz;TENCENTCLOUD_SECRETKEY=aA3AHTV94u/BPYJcB1ip77fNK2pLzr77sAMW6ZuHb/o=;SCF_NAMESPACE=xly-9gssrn8d637383e4;WX_OPEN_DATA_INFO=;WX_API_TOKEN=eyJFbmNyeXB0QWxnbyI6IkVOQ1JZUFRfQUxHT19BRVNfQ0dNIiwiVmVyc2lvbiI6MSwiS2V5VmVyc2lvbiI6MjU1LCJFbmNyeXB0S2V5IjoielZkZzRhWk9IMFdwZUFBQXcyZmNlZ0hWeFlpYytCRlpoQnNQK3RDWEorQT0iLCJ0aWNrZXQiOiJDUE1CRW9BRWd0cU1vOGZ2Y3M2ZHFWTXBoQmJBeXRTaUJEL0lGSXRPYmRkT2orME9KcTdlajQ2NE9mbkZYOVBLang1Y09JYmZObHN6L2k4MFZYb205Z3RkamFhRWFzQTVMTVNTMEVBaHIvbnJKeUZxUEFzbkNKbDA5NUxxRm5PbXB4Z3NnVE9DR2RYQ3pRRFJIMm9LNklLczFLNkFjVkdjTUw5Uzg3V1UvNU8yMkRwK1RIalhnbkg1TnVvdk1pRkwxOTNCNWxveXM1VmdpcDQ0UERSSk1PVFcyVXdLVG1nREx6N1NIbFZNWHJlSnc3cEtoNyt5R1pDUE1RL25BdGJDdDBPbkVTaHpWYW81dFoyZGJGTXRseUhJekkxdVN0NmR1dTZEWWo5WTAzNGNMb2JCbTlKV1RVRVJ0Q3d1ZGczK0FFZW8zWjNDeFFMbU9vK0p0QTFFVkJyeFJBaExTUU5ua1lXZ2t4d29GdWpqLyt5cDZNUTRsb2NVZUQxVkR0eUVxZis5VlMrY1AxUkhsZVUwVHl6Q0Z4ckgzWjRiTFRiN3RhTmNubFdubmR5T24zWmMweDRHVHlURjROdGxYOGZoamVKWWZHT2ErN1BuU2QwZ3FndkR2WHM3Q0EzZ3QrS21ONThCaGp4bzNYSnk5bDdRUExNZUZ3bzcwK01yT0M4d0VMTlo2R1hHRVAybVN3Umg0OW1iblRWVzcxNm03RG54bFlZTnV3L1ZHMU0rU2tTU3RQUjFOUTViUzF1b2ZyaEpPdnQ2eFBZcVFwOXdpclpMbGt1eFJwbTY1eGlhdE9qQmp0NDI5WWQ4Y0JCdFlLNXRjVGFJa3d4UWY0bnNtNTF1VlFJRUxOdUZ0dGlobmI2MjNXc1djVS9zZlhzZFVNNTVJYjB6VlgyWkNYRWsyUExIL0hVWUFDQUEiLCJldmVudElkIjoiSE92dGs1MHM5blQ2ZzRLRlhBVFRGMlA3NFNXQ0FJWk43eTI2MlZfWDNRdUJNRVIzcjBjMmJCenNUQWtPM2NrWC1nYVFPLTRDMEREUXEyMzZWeGoyRnJnTmFSNFdPS2plbDZHeDdjckNUQmpnIn0=;TCB_SEQID=1682492710193_0.6397125710806393_33614847;TCB_CONTEXT_CNFG={\"TCB_SDK_GRAY_0\":true,\"URL\":\"http://169.254.0.131:80/admin\"};WX_CLIENTIPV6=::ffff:111.194.48.127;WX_FROM_UNIONID=;TCB_CONTEXT_KEYS=TCB_ENV,TCB_SEQID,TRIGGER_SRC,TCB_ISANONYMOUS_USER,TCB_SOURCE,TCB_ROUTE_KEY,TCB_CONTEXT_CNFG;TCB_ROUTE_KEY=32;WX_UNIONID=;WX_CLIENTIP=111.194.48.127;WX_FROM_APPID=;WX_APPID=wx597d2f8ac9b22e20;TCB_ENV=xly-9gssrn8d637383e4;TRIGGER_SRC=tcb;TCB_SOURCE=wx_devtools;TENCENTCLOUD_SESSIONTOKEN=Y9BRSpG1HsbYj7EkTocbugZtzNHElFka92c35a08851ba738ed33911f6b9d966diKGwyuOIu9_FLk0tw2utwUSyBCbozxarzQfsS6VJeuPTJX-8rUxbagy1qy4EnQ1881RHiouAYYLGm0-AO_NBXZDEpa5NIrYzgIhqNvfAlrVD2mqECt3zFvsab-rzNLlEN7XrB4kCVTPiTXjkkirseIZXxANmh55UvcPnLMX4h-8X1JNJuIv0-g_ZjNLtxmayyDBWJY-UL1C1ornMTrpUpQU8nsOV7PNFYtXqr-ptmuJyctVZtM5nO2qVctfQ3fkOCujBAf4Uk2ME5tZntLhEUY8DgAc4DElY_Bnuc5ke-LaSyI66hcF4xvrf7qWLHXZ88lrgFQ2H3aKHQcoOKeISX8gsNkjtI2iFtFX4KW6DSDkO_M5N4eQtE3SwPZ_PJC8z;SCF_NAMESPACE=xly-9gssrn8d637383e4",
  "function_version": "$LATEST",
  "function_name": "invoke",
  "namespace": "xly-9gssrn8d637383e4",
  "tencentcloud_region": "ap-shanghai",
  "tencentcloud_appid": "1317954245",
  "tencentcloud_uin": "100031013316"
}
```



通过管理端调用云函数，无论是event对象还是context对象都是获取不到用户的openId、appId、unionid等信息的，也就是说通过管理端调用云函数是获取不到用户的登录态信息的。

???? 打印信息中不是有openId



#### getWXContext()

context对象里的environment、environ过于复杂，云开发有专门的接口`cloud.getWXContext()`可以获取到其中比较关键的信息，比如会返回小程序用户的openid、小程序appid、小程序用户的unionid等。

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  console.log("wxContext对象",wxContext)
}
```

和context对象一样，通过不同的调用方式，`cloud.getWXContext()`返回的值也会有所不同，

```js
{ UNIONID: '',//用户的unionid，只有绑定了开放平台，且在用户授权（允许获取用户信息、关注、支付）的情况下才有
  CLIENTIP: '10.22.213.71',//小程序客户端的网络IPv4地址
  CLIENTIPV6: '::ffff:10.22.213.71',//小程序客户端的网络IPv6地址
  APPID: 'wxda99....b57046',//小程序AppID
  OPENID: 'oUL-m5FuRmuVmxvbYOGuXbuEDsn8',//小程序用户的openid
  ENV: 'xly-xrlur',
  SOURCE: 'wx_devtools' //云函数调用来源，wx_devtools开发者工具调用，wx_client小程序调用，wx_http	HTTP API 调用，wx_unknown	微信未知来源调用等
}
```







#### 登录态与openid的获取

由于context是调用云函数时传入的上下文对象，而getWXContext与context对象有关，因此调用`cloud.getWXContext()`接口时，不能在exports.main外。同时，openId、AppId、unionid等用户信息只有在小程序端调用时才能获取到。

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  const {OPENID} = wxContext
  return OPENID
}
```

不过值得一提的是，尽管我们在小程序端非常需要用户的openid这个值，但是更多的时候，我们没有必要浪费云函数资源来获取openid的值。比如，不少人在使用云开发时，都会先调用云函数返回用户的openid，然后在用户CRUD云数据库时云开发资源时传入获取到的openid。我们可以在用户读写云开发使用`.where({_openid:'{openid}'})`以及借助安全规则的方式，这样就不需要先获取用户的openid的具体值。



### main函数与return

云函数主要执行的是index.js中的main方法，因此要确保云函数中含有main函数，而return除了会返回数据给云函数的调用方，同时也会终结云函数的执行。

在main函数的其他函数里要注意一些写法，比如云函数是支持async/await的，不过在await再用then链式写法，而没有返回值，那data对象就会是undefined，而云函数调用的结果为空

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async(event, context) => {
  const data = await db.collection("china")
  .where({
    _id:_.exists(true)
  })
  .get()
  .then(res=>{
    console.log("then打印的结果",res)//会返回数据库查询的结果
  })
  console.log("data对象",data)//data为undefined
  return data //返回的data为空
}
```

面对这个问题，有两个解决方法，一是不要使用then链式，二是在then方法里return一个返回值，更加土建采用第一种方式。

```js
//方法一，不使用then链式
const data = await db.collection("china")
.where({
  _id:_.exists(true)
})
.get()

//方法二，使用return返回一个data
const data = await db.collection("china")
.where({
  _id:_.exists(true)
})
.get()
.then(res=>{
  console.log("then打印的结果",res)
  return res
})
console.log("data对象",data)
```

注意方法二里尽管我们在then方法里使用了return，但是return只是终结数据库请求，以及返回数据给data，并不会中断云函数的执行，也不会把res的数据返回给main。因此，下面的方法调用云函数时也的返回值也会是null：

```js
await db.collection("china") //const data = await db.collection("china") 同样也不会给main返回任何数据
.where({
  _id:_.exists(true)
})
.get()
.then(res=>{
  console.log("then打印的结果",res)
  return res
})
```



## 云函数的配置与进阶

云函数在云端Node.js的运行机制与本地Node.js会有一些差异，主要表现在云函数实例是由事件触发不是始终运行的（执行完随时会销毁），各个实例之间在横向上是相互隔离的（没有公用的内存或硬盘空间），在纵向上是无状态的（云函数的执行不能调用上一次云函数的执行信息）。云函数平台通过弹性伸缩实例来支持高并发，实例也存在冷启动、热启动（实例复用）的情况。除了机制不同，云函数是无服务器Serverless架构，配置上与传统的Node.js服务器也有所不同。

### 云函数的环境变量

#### 云开发环境的process.env

在配置云函数的环境变量之前，我们需要先来了解云函数的process.env属性，它会返回包含用户环境的对象。process对象是Node.js的全局对象，无需使用require()就可以使用。

比如在invoke云函数里输入以下代码，上传部署到云端之后，在开发者工具的console调用，然后查看云函数的日志就可以看到env环境变量对象：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async(event, context) => {
  console.log("env环境变量",process.env)
}
```

env环境变量里包含一些内置的环境变量key，比如以`SCF_`、`QCLOUD_`、 `TECENTCLOUD_ `开头的key是无法配置的。env对象的一些属性，我们可以在云函数中直接获取到它的具体值并在代码中会用。

比如SCF_RUNTIME函数运行时的Node.js版本，SCF_FUNCTIONVERSION是云函数的版本，TENCENTCLOUD_APPID是云开发对应的腾讯云账号APPID，使用方法如下：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async(event, context) => {
  const {SCF_RUNTIME,SCF_FUNCTIONVERSION,TENCENTCLOUD_APPID} = process.env
  return {SCF_RUNTIME,SCF_FUNCTIONVERSION,TENCENTCLOUD_APPID}
}
```



### 环境变量的配置与应用

打开云开发控制台云函数标签页，我们可以选择一个云函数比如invoke，然后点击**版本管理**，云函数更新迭代比较频繁且版本变更比较频繁时，就需要对新版本的云函数发布一个灰度版本以来了解新版云函数的执行情况，这时候就可以使用云函数的灰度/版本管理（这里就不深入介绍了）。 ![云函数灰度/版本管理](https://i.hackweek.org/img/4/WX20200924-152135@2x.png) 而我们要配置云函数的环境变量，可以点击**配置**，进入云函数的配置页，在环境变量处，我们可以给云函数以key和value的方式配置环境变量。

在配图中，我们写了一些环境变量的大致示例，这些变量的值可以通过`process.env.key`来获取，环境变量常用于如下应用场景：

- 可变值提取：我们可以把业务中有可能会变动的值提取至环境变量中，这样就能避免需要根据业务变更而修改云函数的代码了；
- 加密信息外置：我们可以把认证、加密等敏感信息的key，从代码中提取至环境变量，就能避免key硬编码而引起的安全风险了；
- 环境区分：针对不同开发阶段所要进行的配置和数据库信息，也可提取到环境变量中，这样仅需要修改环境变量的值，分别执行开发环境数据库和发布环境数据库即可；
- 云开发环境的时区：云开发环境的默认时区为UTC+0，比北京时间UTC+8晚了8小时，配置函数的环境变量，设置`TZ`为`Asia/Shanghai` 即可。



### 内存与超时时间

#### 云函数的内存配置

在云函数的调用日志里，我们可以看到云函数被调用的执行时间和执行内存。默认情况下，云函数的配置内存为256MB，而一般情况下云函数的执行内存都会在100MB以内。

如果根据项目需要，你希望使用云函数来执行图片、音视频、爬虫等任务的处理，云函数的执行内存可能会超过256M，这个时候你可以将云函数的内存升级到512M、1024M等；而如果你只是使用云函数处理一些简单的任务，你可以将云函数的内存将配到128M。

在前面我们已经说过，云函数有个计费指标资源使用量GBs，它的值为云函数的配置内存 X 运行计费时长，也就是说根据业务情况合理配置云函数的内存，可以降低云函数的成本.



#### 云函数的执行时间与超时时间

云函数默认的超时时间是3秒钟，通常情况下，这个时长已经足够了；一般来说，如果日志里云函数的执行时长超过300毫秒，就应该检查云函数是否需要优化了。不仅如此，对于一些密集型的任务，也建议使用定时触发器来解决，比如当需要使用云函数发送几十万条短信时，可以借助于定时触发器分批发送，如每5秒，而不是使用云函数一次性发送完（关于定时触发器，教程后面有介绍）。

不过如果根据业务需求，云函数会下载一些文件，或处理的链路比较长，或处理的量相对比较大（比如几千条短信之类的），3s的执行时间可能会不够，这时候就需要将云函数的超时时间的值设置更大一些。云函数的超时时间最大可以设置为60s，不过建议一般不要超过20s。



### 云函数模块与实例复用



#### 云函数模块的创建与引入

使用开发者工具在invoke云函数目录下新建一个common文件用于存放一些模块文件，然后再在common文件夹下新建common.js文件：

```md
invoke // 云函数目录
├── common //common文件夹
│   └── common.js //common.js文件
└── index.js
└── config.json 
└── package.json 
```

在common.js输入以下代码，在common文件里就包含一些通用的数据对象、函数等：

```js
const key = {
	AppID: 'wxda99ae45313257046',  
	AppKey: 'josgjwoijgowjgjsogjo', 
}

const getName = (msg) => {
  return msg+'李东bbsky';
};

//判断是否为数字
const validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;
//元素在数组的index位置
const indexOfAll = (arr, val) => arr.reduce((acc, el, i) => (el === val ? [...acc, i] : acc), []);
exports.key = key
exports.getName = getName
exports.validateNumber = validateNumber
exports.indexOfAll = indexOfAll
```

在index.js里输入以下代码，注意模块文件的引入以及模块里的数据对象、函数等接口的调用方法：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const common = require('./common/common.js');
const {key,getName,validateNumber,indexOfAll} = common

exports.main = async(event, context) => {
  const msg = "你好啊"
  console.log(getName(msg)) 
  console.log(key.AppID)
  console.log(validateNumber(msg))
  console.log(indexOfAll([1, 2, 3, 1, 2, 3], 1))
}
```



#### 关于实例复用

建议在云函数的exports.main函数之外只定义常量或者公共方法，不要定义变量。main函数之外声明的变量可能会被缓存，而不是每次都执行：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
let i = 0; //比如这里在main函数之外定义了一个变量i
exports.main = async(event, context) => {
  i++;
  console.log(i);
  return i;
};
```

在第一次调用该云函数的时候函数返回的结果为1，这是符合预期的。但如果连续调用这个云函数，返回值有可能是2或从2开始递增，也有可能又变成1，这便是实例复用的结果。

当云函数热启动时，执行函数的Node.js进程会被复用，进程的上下文也得到了保留，所以变量i自增。当云函数冷启动时，Node.js进程是全新的, 代码会从头完整的执行一遍，此时就会返回1。所以，开发者在编写云函数时，应注意保证云函数是无状态的、幂等的，即当次云函数的执行不依赖上一次云函数执行过程中在运行环境中残留的信息。



#### 云函数调用进阶

使用云函数也可以使用`cloud.callFunction`接口来调用其他云函数（可以是同一云开发环境的云函数，也可以是同一账号下或跨账号其他云开发环境里的云函数）。比如云支付的支付成功回调函数就是用云函数调用云函数。对于日常的业务，通常不太建议这种调用链路过长的方式，会比较影响性能。

我们还可以使用`switch...case`将多个云函数集成到一个云函数里，其中switch语句会评估一个表达式，将表达式的值与case子句匹配，并执行与该情况相关联的语句：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async(event, context) => {
  console.log(event.action)
  switch (event.action) { //根据调用云函数时传入的action的值来调用不同的函数
    case 'addPost': {
      return addPost(event)
    }
    case 'deletePost': {
      return deletePost(event)
    }
    case 'updatePost': {
      return updatePost(event)
    }
    case 'getPost': {
      return getPost(event)
    }
    default: {
      return 
    }
  }
};

async function addPost(event) {
  return '创建一篇文章' //这里只是返回一个字符串，可以换成其他的函数，比如在数据库里创建一篇文章
}
async function deletePost(event) {
  return '删除一篇文章'
}
async function updatePost(event) {
  return '更新一篇文章'
}
async function getPost(event) {
  return '获取一篇文章'
}
```

调用云函数时，

```js
wx.cloud.callFunction({
  name:"post",
  data:{
    action:"addPost" //
  }
}).then(res=>{
  console.log(res)
})
```

> 将多个云函数集成到一个云函数里除了可以通过`switch...case`的方法外，还可以使用tcb-router和severless-http，这些在教程的第三部分、第四部分都有详细的讲解。





# 云数据库







































