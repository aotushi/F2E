# 生命周期



## 是什么

> 生命周期指的是小程序App和页面Page从被打开到被关闭、卸载的过程，这个过程包含多个有顺序的阶段，比如初始化、资源是否加载完成、页面是否被显示、用户是否将小程序或页面切换到了后台、用户是否卸载了页面等。



## 构造器

> 生命周期指的是小程序App和页面Page从被打开到被关闭、卸载的过程，这个过程包含多个有顺序的阶段，比如初始化、资源是否加载完成、页面是否被显示、用户是否将小程序或页面切换到了后台、用户是否卸载了页面等。



### 小程序构造器和页面构造器

App() 必须在 app.js 中调用，必须调用且只能调用一次，从技术文档我们可以了解小程序构造器有如下属性与方法

```js
App({
  onLaunch: function (options) { //监听小程序初始化
  },
  onShow:function(options){      //监听小程序启动或切前台
  },
  onHide:function(){      //监听小程序切后台
  },
  onError:function(msg){     //错误监听函数     
  },
  onPageNotFound:function(){ //页面不存在监听函数
  },
  onUnhandledRejection:function(){//未处理的 Promise 拒绝事件监听函数   
  },
  onThemeChange:function(){//监听系统主题变化
  }
})
```



Page()则需要写在每个小程序页面的js文件里面来注册小程序中的一个页面，页面构造器有如下属性和方法，而其中onLoad、onShow等就是页面的生命周期函数：

```js
Page({
  data: {//页面的初始数据
  },
  onLoad: function(options) {//监听页面加载
  },
  onShow: function() {//监听页面显示
  },
  onReady: function() {//监听页面初次渲染完成
  },
  onHide: function() {//监听页面隐藏
  },
  onUnload: function() {//监听页面卸载
  },
  onPullDownRefresh: function() {//监听用户下拉动作
  },
  onReachBottom: function() {//页面上拉触底事件的处理函数
  },
  onShareAppMessage: function () {//用户点击右上角转发
  },
  onPageScroll: function() {//页面滚动触发事件的处理函数
  },
  onResize: function() {//页面尺寸改变时触发
  },
  onTabItemTap:function(){//当前是 tab 页时，点击 tab 时触发
  }
})
```



### 页面全局变量

我们可以在`Page({})`对象前添加一些变量，比如我们声明了一个user变量：

user变量可以在Page({})对象的生命周期函数里访问，因为user变量定义在了Page之外，它是整个页面的全局变量

```js
const user = {name:"李东bbsky",address:"深圳"} 
console.log(user.address) //之前介绍过，这里可以访问user对象
Page({
  data: {
    title:"技术杂役"
  },
  onLoad: function(options) {
    console.log(this.data.title)
    console.log(user.name)  //在生命周期函数里访问user对象
  },
})
```



### 页面全局变量变种

全局变量也是相对的，比如我们把变量声明在Page外，这个变量就是Page的全局变量，而有些变量我们可以声明在生命周期函数或事件处理函数的里，如在页面的js里执行以下代码:

对于`this.setData`而言，movielist就是一个全局变量。

```js
Page({
  data: {
    title:""
  },

  onLoad: function (options) {
    const movielist=["肖申克的救赎","霸王别姬","这个杀手不太冷"]
    this.setData({
      title:movielist[1]
    })
    console.log(this.data.title)
  },
})
```



## 生命周期函数

### 小程序生命周期

```js
onLaunch(opts) {
  console.log('onLaunch监听小程序初始化。',opts)  //全局只会触发一次
},
onShow(opts) {
  console.log('onShow监听小程序启动或切前台',opts) //会触发多次
},
onHide() {
  console.log('onHide监听小程序切后台')
},
```



### 页面生命周期

```js
onLoad: function(options) {
  console.log("onLoad监听页面加载",options)
},
onReady: function() {
  console.log("onReady监听页面初次渲染完成")
},
onShow: function() {
  console.log("onShow监听页面显示")
},
onHide: function() {
  console.log("onHide监听页面隐藏")
},
onUnload: function() {
  console.log("onUnload监听页面卸载")
},
```



### 生命周期函数调用api

只需要用户打开小程序、打开某个页面，把小程序切后台等情况时就能触发里面的函数。

例如在app.js的onLaunch生命周期函数里调用`wx.showLoading`的接口，表示小程序正在加载中：

```js
App({
  onLaunch: function () {
    wx.showLoading({
      title: "正在加载中",
    })
  },
  globalData: {

  }
})
```

执行之后我们会发现”正在加载中“的loading动画一直都会在，因为我们需要在表示资源加载完成的生命周期函数里调用`wx.hideLoading`来隐藏这个loading动画，比如小程序 onShow 生命周期函数：

```js
App({
  onLaunch: function () {
    wx.showLoading({
      title: "正在加载中",
    })
  },
  onShow (options) {
    wx.hideLoading({
      success: (res) => {
        console.log("加载完成，所以隐藏掉了")
      },
    })
  },
  globalData: {

  }
})
```



### 小程序进入场景值

在App的onLaunch和onShow打印的对象里有一个scene为1001，这个是场景值。场景值用来描述用户进入小程序的路径方式。用户进入你的小程序的方式有很多，比如有的是扫描二维码、有的是长按图片识别二维码，有的是通过微信群进入的小程序，有的是朋友单聊进入的小程序，有的是通过公众号进入的小程序等等，这些就是场景值，而具体的场景值，可以看技术文档，场景值对产品、运营来说非常重要。

**技术文档：**[场景值列表](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Freference%2Fscene-list.html)

```js
App({
  onLaunch: function (options) {
    console.log('打印小程序启动时的参数',options)
  },
})
```

在options对象里就包含secne这个属性值

```js
path: "" //页面路径
query: {} //页面的参数
referrerInfo: {} //来源小程序、公众号或 App 的 appId
scene: 1047 //场景值
shareTicket: //带 shareTicket 的转发可以获取到更多的转发信息，例如群聊的名称以及群的标识 openGId
```





# 小程序函数与调用



## 给构造器添加函数或数据变量

### 小程序的全局变量

可以在app.js的App({})里添加一个数据变量globalData对象、tcbData对象来存放整个小程序都会使用到的数据：

```js
App({
  globalData: {
    userInfo:{
      username:"李东bbsky",
      title:"杂役"
    }
  },

  tcbData: {
    title:"云开发训练营",
    year:2019,
    company:"腾讯Tencent"
  },
})
```



### 小程序的全局变量调用

需要用到`getApp()`来获取小程序全局唯一的App实例，就可以在其他任意页面调用到app.js里声明的数据变量了。

```js
const app = getApp() 

//在Page外调用
console.log(app.globalData.userInfo.username)
console.log(app.tcbData.title)
console.log(app)
Page({
  //在data对象里调用
  data: {
    userInfo:app.globalData.userInfo
  },

  //在生命周期函数里面调用
  onLoad: function (options) {
    console.log(app.globalData.userInfo.username)
    console.log(app.tcbData.title)
    console.log(app)
    console.log(this.data.userInfo)
  }
})
```

如果我们想在app.js里调用globalData、tcbData对象里的数据，只需要使用this即可，不要使用`getApp()`。



### 函数的调用

有的时候要执行一个功能需要写很多个函数，或者有时候我们希望能够把一些特定的功能给封装成一个函数，如果把这些函数整个都写到生命周期函数或事件处理函数里面来调用就很不方便了。

比如一个博客小程序每篇文章发布成功之后，最好给用户一个发布成功的反馈以及会返回上一页，也就是一个功能里面需要执行多个函数，而且这个功能还比较常用，我们可以用如下方式：

```js
Page({
  onLoad: function (options) {
    this.publishSuc() //this调用的是我们封装好的函数publishSuc
  },

  publishSuc(){
    wx.showToast({
      title: '文章发布成功',
      icon: 'success',
      duration: 1000
    },
    setTimeout(function() {
			wx.navigateBack({
				delta: 1
			})
		},2000))
  }
})
```

上面的案例没有给函数传递参数，回顾前面形参和实参的知识，我们可以在调用函数的时候用如下的方法传递参数，message和title的名称虽然不一样，但是也没有关系：

```js
Page({
  onLoad: function (options) {
    const message = "发布失败"
    this.publishSuc(message)
  },

  publishSuc(title){
    wx.showToast({
      title: title,
      icon: 'success',
      duration: 1000
    })
  }
})
```

> 在小程序页面的js文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。



# 用户登录与信息获取

## 了解wx.login wx.getSetting

```js
App({
  onLaunch: function () {
    wx.login({
      success(res){
        console.log('wx.login得到的数据',res)
      }
    })
 
    wx.getSetting({
      success(res){
        console.log('wx.getSetting得到的数据',res)
      }
    })
  },
 
  globalData: {
    userInfo: null
  }
})
```



wx.login返回的res对象里会包含errMsg和code，这个code是用户的登录凭证。

wx.getSetting返回的res对象里包含errMsg和用户当前的[权限设置authSetting](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Fsetting%2FAuthSetting.html)，包含是否允许获取用户信息，是否允许获取用户位置，是否允许使用手机相册等权限。我们可以根据打印的结果结合技术文档来深入理解。

**技术文档：**[获取用户登录凭证wx.login](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Flogin%2Fwx.login.html)

**技术文档：**[获取用户登录凭证wx.login](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fopen-api%2Flogin%2Fwx.login.html)

> 如果要让小程序和自己的服务器账号打通，仅仅获取用户登录凭证是不够的，需要将这个code以及你的小程序appid和appSecret传回到你的开发服务器，然后在自己的服务器上调用[auth.code2session](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi-backend%2Fopen-api%2Flogin%2Fauth.code2Session.html)接口，得到用户的openid和session_key。由于openid是当前用户的唯一标识，可以用来判断该用户是否已经在自己的服务器上注册过，如果注册过，则根据openid生成自定义登录态并返回给小程序，整个过程非常复杂。
>
> 而由于**云开发与微信登录鉴权无缝整合**，这些内容都不会涉及，所以这里不多介绍。



## 获取用户信息wx.getUserInfo

我们要获取用户信息，首先需要判断用户是否允许，可以从authSetting对象里看scope.userInfo属性是否为true，如果为true，那我们可以调用wx.getUserInfo()接口来获取用户信息。

使用开发者工具给上面的wx.getSetting()函数添加内容，最终代码如下：

```js
wx.getSetting({
  success(res) {
    console.log('wx.getSetting得到的数据', res)
    if (res.authSetting['scope.userInfo']) {
      wx.getUserInfo({
        success(res) {
          console.log('wx.getUserInfo得到的数据: ', res)
        }
      })
    }
  }
})
```



## globalData

用户信息的数据是所有页面都需要用到的，放在**app.js**里公用是应该的，但是我们要怎么才能调用到这个数据呢？

在上面的wx.getUserInfo的success回调函数里将获取到的userInfo对象赋值给globalData对象的userInfo属性。

```js
wx.getUserInfo({
    success(res){
    console.log("wx.getUserInfo得到的数据",res)
    this.globalData.userInfo = res.userInfo
  }
})
```

但是会提示 `Cannot read property 'globalData' of undefined;`报错



### 无法访问this的解决方案

#### 使用箭头函数

```js
wx.getSetting({
  success: (res) => {
      if (res.authSetting['scope.userInfo']) {
        wx.getUserInfo({
          success(res) {
            that.globalData.userInfo = res.userInfo
          }
        })
      }
  }
})
```





#### 使用变量that

```js
let that = this;    
wx.getSetting({
      success(res) {
        if (res.authSetting['scope.userInfo']) {
          wx.getUserInfo({
            success(res) {s
              that.globalData.userInfo = res.userInfo
            }
          })
        }
      } 
    })
```



## getApp()

如何在页面的js里调用globalData呢，这个时候就需要用到getApp()函数啦。

**技术文档：**[getApp()](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Freference%2Fapi%2FgetApp.html)

例如我们在user页面中访问globalData中的数据.

在user.js的Page()函数前面添加如下代码：

```js
let app = getApp()
console.log('user页面打印的app', app)
console.log('user页面打印的globalData', app.globalData.userInfo)
console.log('user页面打印的tcbData',app.tcbData.eventInfo)
```

这样我们就能获取app.js里的globalData和自定义的属性了。

> 这里还会有一个问题，就是尽管我们已经获取到了globalData，我们也能在globalData.userInfo的打印日志里看到用户的信息，但是当我们想获取里面的值时，还是会报错，这是因为 wx.getUserInfo是异步获取的信息，这里涉及到的异步，我们之后会详细介绍。





## 通过button获取用户信息

 在我们使用wx.getUserInfo的方式来获取用户信息时，控制台会报错：获取 wx.getUserInfo 接口后续将不再出现授权弹窗，请注意升级。也就是小程序官方已经不建议开发者用wx.getUserInfo来获取用户信息，而是建议通过button的方式来获取，对用户的体验更好，也就是**只有用户点击了按钮，用户信息才会被获取**。

创建一个button组件，要获取到用户信息，有两个必备条件，一是 open-type="getUserInfo"，必须是这个值；二是绑定事件处理函数的属性名为bindgetuserinfo（类似于bindtap，但是属性名必须为bindgetuserinfo，至于事件处理函数的名称可以自定义）

```js
<button open-type="getUserInfo" bindgetuserinfo="getUserInfomation"> 点击获取用户信息 </button>
```

这里的getUserInfomation和之前点击事件的事件处理函数是一致的，点击组件触发getUserInfomation，仍然会收到事件对象，我们把它打印出来，在user.js里添加以下代码：

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
},
```

当我们点击“**点击获取用户信息**”的button按钮后，在控制台可以查看到getUserInfomation打印的事件对象，事件对象里有个detail属性，里面就有userInfo的数据.

页面中获取用户信息的固定套路:

1.首先在页面中data对象中初始化一个userInfo对象,用来接收数据

```js
data: {
  userInfo: {}
}
```

2.然后在事件处理函数getUserInfomation获取到的userInfo通过this.setData赋值给它，也就是getUserInfomation的函数为

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
  this.setData({ 
    userInfo: event.detail.userInfo, 
  })
},
```

3.获取到用户信息,可以在wxml文件中使用

```js
<view>{{userInfo.nickName}}</view>
<view>{{userInfo.country}}</view>
<image mode="widthFix" style="width:64px;height:64px" src="{{userInfo.avatarUrl}}"></image>
```



## 将用户信息写进app.js

上面这种方式只能在页面中才能获取到用户信息，限制非常大，那我们应该怎么做呢？

我们要把获取到的用户信息写到app.js成为页面的公共信息，以后可以跨页面只需在user页面点击一次按钮即可。

在getUserInfomation将获取到的用户信息传给globalData的userInfo属性：

```js
getUserInfomation: function (event) {
  console.log('getUserInfomation打印的事件对象',event)
  app.globalData.userInfo = event.detail.userInfo
  this.setData({ 
    userInfo: event.detail.userInfo, 
  })
},
```



> 获取用户信息还有一种方式，就是通过组件`<open-data>`来展示







# 云函数

> 云函数可以以函数的形式自动运行后端代码以响应API调用和HTTPS触发的事件，开发者只需关注业务代码本书，无需关心后端运维、计算资源等，平台会根据负载自动进行扩缩容。各个云函数相互独立，执行环境相互隔离。



## 云函数快速入门

云函数在操作上与以往的开发方式会有所不同，不过它依然还是JavaScript知识的应用。在这一章，我们会来讲解云函数如何新建、如何部署、如何调用，在操作上我们需要注意哪些细节等。



### 云函数的新建和调用

#### 新建一个云函数

使用开发者工具，鼠标右键云函数根目录如cloudfunctions，在弹出的窗口选择**新建Node.js云函数**，然后输入云函数的名称比如`sum`(可以先右键同步云函数列表，保证没有重名),按Enter确认后，微信开发者工具会在本地（你的电脑）创建出**sum云函数目录**，同时也会在线上环境中创建出对应的云函数（也就是自动部署好了，可以到云开发控制台云函数列表里看到）。

```md
cloudfunctions //云函数根目录       
├── sum // 云函数目录
│   └── index.js 
│   └── config.json
│   └── package.json  //云函数的Node包管理
miniprogram //小程序根目录  
├── ...    
```

打开sum云函数目录下的index.js并将里面的代码修改为如下，然后右键index.js文件，选择**云函数增量上传:（更新文件）**，这样一个用来求两个参数之和的云函数就更新好了：

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV }) // 使用当前云环境

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  const sum = event.a + event.b
  return {
    sum,
    event,
    openid: wxContext.OPENID,
    appid: wxContext.APPID,
    unionid: wxContext.UNIONID,

  }
}
```

这里的`event`对象指的是触发云函数的事件，在小程序端调用时，`event`是小程序端调用云函数时传入的参数对象，也就是说要计算`sum`，我们需要在小程序端调用云函数时传入两个参数`a`和`b`。



#### 云函数的调用

在小程序中调用这个云函数前，我们还需要先将该云函数部署到云端。在云函数目录上右键，在右键菜单中，我们可以将云函数整体打包上传并部署到线上环境中。

部署完成后，我们可以在小程序中调用该云函数.

要调用云函数有**很多种方式**，比如我们可以在调试器的console控制台调用接口、在生命周期函数里调用，还可以通过组件绑定一个事件处理函数来调用等等，这些方式都是大同小异，都是在调用`wx.cloud.callFunction()`接口。

两种调用方式:

```js
wx.cloud.callFunction({
  // 云函数名称
  name: 'add',
  // 传给云函数的参数
  data: {
    a: 1,
    b: 2,
  },
  success: function(res) {
    console.log(res.result) // 3
  },
  fail: console.error
})
```



```js
wx.cloud.callFunction({
  name: 'sum',    // 要调用的云函数名称，这里为sum
  data: {         // 传递给云函数的event参数，这里为a和b
    a: 15,
    b: 23,
  }
}).then(res => {
  console.log("云函数返回的结果",res.result)
}).catch(err => {
  console.log("云函数调用失败",err)
})
```

返回值res.result就是云函数返回的对象.



#### 云函数的返回值与渲染

使用开发者工具将sum云函数的代码修改为如下，我们让云函数返回更多类型的数据，修改完之后，右键index.js文件，选择**云函数增量上传:（更新文件）**：

```js
```

> 值得注意的是，云函数返回的时间和小程序端返回的时间(北京时间)是不一样的，这是因为云函数中的时区为 UTC+0，不是 UTC+8，格式化得到的时间和在国内的时间是有8个小时的时间差，但是时区不会影响时间戳，所以尽量不要在云函数端将时间字符串化。



### 云函数的初始化

#### 关于wx-server-sdk

wx-server-sdk是微信小程序服务器端的SDK，SDK包括用于微信免鉴权的私有协议、云数据库、云存储、云调用等基础能力，因此每一个云函数都会使用到wx-server-sdk这个Node包。由于每个云函数实例之间是相互隔离的（没有公用的内存或硬盘空间），所以每个云函数都要求**单独**安装wx-server-sdk，Node包在云函数实例之间不存在复用的关系。而要调用这个包都需要安装好Node.js环境才能在本地电脑的开发者工具进行本地调试。

给云函数安装依赖时，在开发者工具上右键云函数目录如sum，选择开发者工具自带的终端（更建议）或外部终端窗口，直接输入`npm install`即可。npm包管理器自动会安装好package.json的dependencies写好的包，可以将wx-server-sdk的版本号换成latest（生产环境以稳定兼容的版本为准）：

```json
"dependencies": {
  "wx-server-sdk": "latest"
}
```

sum安装好node依赖之后，就会在云函数目录里有一个node_modules的文件夹。当我们要将本地的云函数部署到云开发环境时，可以右键云函数目录选择**上传并部署所有文件**（更建议）或**上传并部署：云端安装依赖（不上传node_modules）**。

如果云函数本地没有安装依赖，就没法在开发者工具对云函数进行本地调试，部署上传云函数时，选择**上传并部署所有文件**就会报错，截图如下：

![4bfa24048d6f487b995a613ddbc5dc34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp (996×364) (byteimg.com)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bfa24048d6f487b995a613ddbc5dc34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

wx-server-sdk只是云函数必备的一个依赖，云函数还可以通过package.json安装更多功能丰富的Node包。当在package.json里新增了其他依赖时，都需要使用`npm install`进行依赖的下载。



#### 云函数的初始化

在云函数中调用其他API前，同小程序端一样，也需要执行一次初始化方法，首先使用require引入wx-server-sdk依赖，然后在初始化`cloud.init()`中指定云开发的环境，方法如下：

```js
const cloud = require('wx-server-sdk')
// 给定字符串环境 ID：接下来的 API 调用都将请求到环境 some-env-id
cloud.init({
  env: 'some-env-id'
})
```

或者

```js
const cloud = require('wx-server-sdk')
// 给定 DYNAMIC_CURRENT_ENV 常量：接下来的 API 调用都将请求到与该云函数当前所在环境相同的环境
// 请安装 wx-server-sdk v1.1.0 或以上以使用该常量
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
```



以上两种方法对应的的实际案例:

```js
//方法一，直接使用字符串envId指定环境
const cloud = require('wx-server-sdk')
cloud.init({
  env: 'xly-9gssrn8d637383e4' //换成你的云函数envId
})

//方法二，使用cloud.DYNAMIC_CURRENT_ENV常量，也就是使用云函数当前所在环境
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV //注意它不是字符串，不要加引号
})
```

- 尽管直接使用`cloud.init()`不指定环境在某些特定情况下仍然可以使用，比如你的云函数就部署在你创建的第一个云开发环境里，但是非常不推荐这种写法；
- `cloud.DYNAMIC_CURRENT_ENV`标志的是云函数当前所在的环境，也就是你将云函数部署到哪个环境，它就是指哪个环境；
- 我们可以在云开发环境A直接调用同一个账号下云开发环境B的资源，只需要在云环境初始化时指定B的envId即可，在开发时切换生产环境、测试环境非常方便；
- 我们还可以在云函数里分别调用不同云开发环境里的云存储、云数据库、云函数等的资源，比如`env:{"database":"xly-xrlur","storage":"xly-1o7da","functions":"xly-oau0j"}`；
- 如果调用云函数时，提示`找不到对应的FunctionName`，可能是你的小程序账号之下有多个云开发环境，而你在云函数初始化时没有指定envId。



### 开发者工具右键操作说明

#### 同步云函数列表

当我们右键云函数根目录cloudfunctions时，会有一个**同步云函数列表**的选项，它可以拉取当前云开发环境所有云函数的列表，右键指定的云函数选择**下载**就可以将云端的代码给下载到本地电脑。也就是说，上传到云开发环境的云函数以及代码都会存储在云端，你可以在其他设备上通过这种方式进行同步，除非你在云开发控制台将这个云函数给删掉了。

当我们在开发者工具本地或使用云开发控制台将云函数删掉之后，**建议先同步云函数列表**，不然在重新上传部署同名的云函数的时会出现一些报错。





#### 新建Node.js云函数

选择**新建Node.js云函数**可以直接在云端新建一个云函数，同时会自动在云端给新建的云函数安装好wx-server-sdk依赖，并将该云函数在云端部署的情况反馈到开发者工具，即开发者工具本地的云函数目录图标会变色（注意区分同步和没有同步的云函数目录图标的不同）。



#### 增量上传? 



## 本地调试与云端测试

### 云函数的开发流程

为了能够让大家更加清楚的了解：**完整操作一个云函数的流程**以及**本地调试与云端测试的重要性**，我们以长方形的边长（a、b）求周长、面积这个简单的数学公式为例。

#### 新建云函数

首先我们右键点击**云函数根目录**（也就是**cloudfunctions文件夹**），选择**新建Node.js云函数**，函数名为长方形的英文rectangle，然后打开index.js，将代码修改为如下：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
exports.main = async (event, context) => {
  const {width,height} = event
  console.log("长方形的周长与面积",[(width+height)*2,width*height])
  return {
    circum:(width+height)*2,
    area:width*height
  }
}
```

建好云函数之后，我们右键点击云函数目录，也就是rectangle文件夹，选择**在终端中打开**，使用npm install来安装依赖。

```bash
npm install
```



#### 本地调试云函数是否正确

对于一个复杂的云函数，我们最好是先在本地测试一下云函数是否正确，然后再部署上传到云端。

那如何本地测试呢？右键点击云函数目录，也就是rectangle文件夹，选择**本地调试**（这种方式进入本地调试会默认开启rectangle的本地调试）。

我们可以根据情况来选择**手动触发**和**模拟器触发**，使用手动触发需要我们在本地调试输入参数之后，点击**调用**：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7dfff165c7c4ff1b55c1bd7f2375c77~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们给参数宽度width和高度height赋值（**注意传递的是JSON格式，最后一个参数结尾不能有逗号,**），比如赋值为3和7：

```json
{
  "width": 3,
  "height":7
}
```

然后点击**调用**，如果显示函数执行成功(注意仍然是在调试的console标签)，并得到周长circum和面积area的结果分别为20、21，那证明云函数没有写错。

> 当开启了本地调试，我们在开发者工具调试器的console控制台（非本地调试的console标签页）调用云函数时也会调用本地的云函数。在本地调试窗口无论是选择手动触发、模拟器触发亦或是通过其他云函数来调用云函数，取决于你的云函数的调用方式，比如如果云函数调用是在页面的生命周期函数里调用，我们本地调试时就可以使用模拟器触发。



#### 云端测试云函数是否正确

云测试之前需要上传和部署, 之后打开**云开发控制台**的**云函数**标签，找到rectangle云函数，点击**云端测试**，同样我们给参数赋值，将以下代码进行修改，比如给宽度width赋值为4，高度height赋值为7，即代码修改为：

```js
{
  "width": 4,
  "height": 7
}
```

然后点击运行测试，（会等一段时间），再来查看测试的结果，如果返回结果如下，则表示在云端的云函数可以正常调用.



云函数的调用采用**事件触发模型，小程序端的调用、本地调试和云端测试**都会触发云函数的调用事件，其中本地调试调用的不是云端的云函数，而是小程序本地的云函数；而在云端测试调用云函数的结果是可以在云开发控制台云函数的日志里查看到的。

#### 云函数的在线编辑

上传到云端的云函数，我们还可以通过云开发的网页控制台（登录方式）在线修改代码。通过在线编辑，我们不仅可以检查代码是否更新成功，还可以脱离微信开发者工具、Cloudbase CLI等来临时修改代码。

**云开发网页登录**

> 我们还可以使用[腾讯云云开发网页控制台](https://link.juejin.cn/?target=https%3A%2F%2Fconsole.cloud.tencent.com%2Ftcb)来管理云开发资源，需要注意两点，一个是登录方式需要选择**其他登录方式里的微信公众号**，点击然后使用手机微信扫码，在微信上选择你要登录的小程序；二是要进入腾讯云后台之后切换选择云开发Cloudbase。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682071f1c4a241948fd5247ecaf69218~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



### return与console

#### 云函数日志

当调用云函数时，在开发者工具调试器里并没有看到console.log打印的结果，但我们可以打开**云开发控制台**–**云函数**–**日志**，**按函数名筛选**，选择rectangle云函数，可以看到云函数被调用的日志记录了（日志也可以在云开发网页控制台查看）。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f057bddb5b2a4f39a16fa7fc35d8a49d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

在云函数日志里，我们除了可以在**返回结果**里看到return返回的对象，还可以在日志里查看到云函数执行的时间点（使用的是服务端时间，时区为UTC+0），以及云函数里使用console.log打印的日志。

云函数调试的时候，不能只依赖小程序端的`wx.cloud.callFunction`使用return返回的报错，因为它只是反馈云函数的调用结果以及调用是否出现错误error，更多的还是要在云函数里使用`console.log`打印云函数在执行过程中的一些日志情况。也就是说，return只会返回中断函数执行的一些报错，而比如函数是否获取到参数，参数是什么数据类型，以及是否包含你想要的预期值，这些都需要勤使用console.log来反馈。

#### return与报错

在小程序端调用云函数时，我们经常会使用到return，return语句可以终止函数的执行并返回一个值给小程序端，因此很多人会依赖return返回的这个值来了解云函数是否获取到了最终想要的结果。对于复杂的云函数，仅仅只是使用return并不能精确定位到云函数在执行过程中哪里出错。

而小程序端的报错，只能显示云函数为什么没有等到执行return就中断了，比如以下案例集合名本为cloudbase，但是在书写的过程中，却不小心写错了：

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env:cloud.DYNAMIC_CURRENT_ENV 
})
const db = cloud.database()
const _ = db.command
exports.main = async (event, context) => {
  return await db.collection("cloubase").where({
    _id:_.exists(true)
  }).get()
}
```

这种错误由于会中断云函数的执行，因此会被返回到小程序端，报错也会显示集合或记录不存在，截图如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3052f36b8d4533a9a532dc8975e016~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

当然出现这个报错，首先要检查你调用的集合与云数据库的集合名是否一致（或确实不存在这个集合），如果都没有问题，则需要检查云函数的初始化是否正确的选择了集合所在的云开发环境。

大多数情况下，可能云函数里并没有出现中断函数执行的错误error，但是return却并没有返回到预期的结果，比如前面介绍的rectangle云函数，我们可以在开发者工具的调试器console里调用云函数：

```js
wx.cloud.callFunction({name:"rectangle"}).then(res=>{console.log(res)})
```

在调用时，我们忘记了传入参数，或者参数名写错了，或者由于异步的问题参数其实没有值等等原因，云函数可以正常执行，但是return的值却为`result: {circum: null, area: null}`，对于这样的错误如果不通过日志，就很难反馈出来。

注意 **错误(Error)** 与 **异常(Exception)** 是完全不一样的，错误会中断JavaScript函数的执行，而异常不会导致JavaScript进程被终止，通过return只能返回错误而不能获取到异常，要获取云函数执行的异常需要通过`try..catch`的方式。



### 云函数的错误处理



#### try...catch

在云函数中，return只能返回错误，而有些异常我们可以通过`try..catch`来返回，`try..catch`的语法如下。

```js
try {
  // 代码...
} catch (err) {
  // 错误捕获
}
```





#### error对象不支持遍历





#### 云函数的日志与高级日志





### 云函数的监控



#### 云函数的状态监控与消耗





#### network面板



## 云函数的调用与返回



























































