---
alias:数组方法
---


### 数组4方法

> ECMAScript 给数组提供几个方法，让它看起来像是另外一种数据结构
>
> 数组对象可以像栈一样,也就是一种限制插入和删除项的数据结构.
>
> 栈是一种后进先出的结构(LIFO, Last-In-First-Out), 也就是最近添加的项会被先删除. 数据项的插入(push,称为推入)和删除(称为弹出,pop)只在栈的一个地方发生,栈顶. 
>
> ECMAScript 数组提供了push()和pop()方法，以实现类似栈的行为。



#### push()

**定义**

`**push()**` 方法将<u>一个或多个元素</u>添加到数组的末尾，并返回该数组的**新长度**

**返回值**

新的`length`属性

**描述**

`push` 方法具有通用性。该方法和 [`call()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 或 [`apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 一起使用时，可应用在类似数组的对象上。`push` 方法根据 `length` 属性来决定从哪里开始插入给定的值。如果 `length` 不能被转成一个数值，则插入的元素索引为 0，包括 `length` 不存在时。当 `length` 不存在时，将会创建它。

唯一的原生类数组（array-like）对象是 [`Strings`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)，尽管如此，它们并不适用该方法，因为字符串是不可改变的。

**实例**

向数组中添加元素

```javascript
let sports = ['soccer', 'baseball']
let total = sports.push('football', 'swimming')

console.log(sports)  // ['soccer', 'baseball', 'football', 'swimming']
console.log(total)   // 4
```

合并两个数组

```javascript
let vegetables = ['parsnip', 'potato']
let moreVegs = ['celery', 'beetroot']

// Merge the second array into the first one
vegetables.push(...moreVegs);

//另一种写法
Array.prototype.push.apply(vegetables, moreVegs);
[].push.apply(vegetables, moreVegs)
console.log(vegetables)  // ['parsnip', 'potato', 'celery', 'beetroot']

//也可以使用concat()方法
let vegetables = ['parsnip', 'potato']
let moreVegs = ['celery', 'beetroot']
let result = vegetables.concat(moreVegs);
console.log(result); // ['parsnip', 'potato', 'celery', 'beetroot']
```

用类数组方式使用对象([Using an object in an array-like fashion](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push#using_an_object_in_an_array-like_fashion))

`push`是通用的,`Array.prototype.push`也能在对象上使用.

我们无需创建一个数组来存储对象集合,反而,我们可以用对象集合存储它自己,在`Array.prototype.push`上使用`call`来调用, ,让方法认为在处理数组. 

```javascript
let obj = {
  length: 0,
  addElem: function addElem(elem) {
    // obj.length is automatically incremented
    // every time an element is added.
    [].push.call(this, elem);
  }
};

obj.addElem({});
obj.addElem({});

console.log(obj.length); //2
```



**实现**

```javascript
//https://juejin.cn/post/6844903986479251464#heading-39

Array.prototype.push = function(...items) {
  let O = Object(this)
  let len = O.length >>> 0
  let argCount = items.length >>> 0
  // 2** 53-1 为JS能表示的最大的数
  if (len+argCount > 2**53-1) {
    throw new TypeError('The number of array is over the max value restricted!')
  }
  
  for (let i=0; i<argCount; i++) {
    O[len+i] = items[i]
  }
  
  let newLength = len + argCount
  O.length = newLength
  
  return newLength
}
```



#### [[202304100929|Array.prototype.pop]]

**定义**

`**pop()**`方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。

**返回值**

从数组中删除的元素(当数组为空时返回[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined))。

**描述**

`pop` 方法有意具有通用性。该方法和 [`call()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 或 [`apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 一起使用时，可应用在类似数组的对象上。`pop`方法根据 `length`属性来确定最后一个元素的位置。如果不包含`length`属性或`length`属性不能被转成一个数值，会将`length`置为0，并返回`undefined`。

如果你在一个空数组上调用 pop()，它返回  [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。





#### unshift()

> 队列解构  先进先出   待补充

**定义**

**`unshift()`** 方法将一个或多个元素添加到数组的**开头**，并返回该数组的**新长度**(该方法修改原有数组**)**。

**Syntax**

```javascript
unshift(element0)
unshift(element0, element1, ...,elementN)
```

**Return value**

this new length property of the object upon which the method was called.



**描述**

`unshift` 方法会在调用它的<u>类数组对象</u>的开始位置插入给定的参数。 (数组, arguments对象)

`unshift` 特意被设计成具有通用性；这个方法能够通过 [`call`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 或 [`apply`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 方法作用于类数组对象上。不过对于没有 length 属性的对象，调用该方法可能没有任何意义。

注意, 如果传入多个参数，它们会被以块的形式插入到对象的开始位置，它们的顺序和被作为参数传入时的顺序一致。 于是，传入多个参数调用一次 `unshift` ，和传入一个参数调用多次 `unshift` (例如，循环调用)，它们将得到不同的结果.

**实例**

```javascript
let arr = [4,5,6];
arr.unshift(1,2,3);
console.log(arr); // [1, 2, 3, 4, 5, 6]

arr = [4,5,6]; // 重置数组
arr.unshift(1);
arr.unshift(2);
arr.unshift(3);
console.log(arr); // [3, 2, 1, 4, 5, 6]
```



**实现**

```javascript
// https://juejin.cn/post/6844903986479251464#heading-39

//自己的
Array.prototype.pop = function() {
  let O = Object(this)
  let len = O.length >>> 0
   
  let deleteItem = O[len - 1]
  
  O.length = len - 1;
  
  return deleteItem;
}

//完善的
Array.prototype.pop = function() {
  let O = Object(this)
  let len = O.length >>> 0
  
  if (len === 0) {
		O.length = 0 //???
    return undefind
  }
  
  len--
  let value = O[len]
  delete O[len]
  O.length = len
  return value
}
```



#### shift()

**定义**

`shift()` 方法从数组中删除**第一个**元素，并返回该元素的值。此方法更改数组的长度。

**返回值**

从数组中删除的元素; 如果数组为空则返回[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined) 。

**描述**

`shift` 方法移除索引为 0 的元素(即第一个元素)，并返回被移除的元素，其他元素的索引值随之减 1。如果 [`length`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length) 属性的值为 0 (长度为 0)，则返回 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。

`shift` 方法并不局限于数组：这个方法能够通过 [`call`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 或 [`apply`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 方法作用于类似数组的对象上。

**实例**

```javascript
//shift() 方法经常用于while loop的环境中.。下例中每个循环将要从一个数组中移除下一项元素，直至它成为空数组。

var names = ["Andrew", "Edward", "Paul", "Chris" ,"John"];

while( (i = names.shift()) !== undefined ) {
    console.log(i);
}
// Andrew, Edward, Paul, Chris, John
```





### 数组方法分类



#### 迭代器方法

用于迭代数组元素,会按照顺序把数组每个元素传给我们提供的函数,可便于对数组进行迭代,映射,过滤,测试和归并.

##### 特点

* 所有这些方法都接收一个<span style="color:blue">函数</span>作为<span style="color:blue">第一个参数</span>,并对数组每个元素(或某些元素)都调用一次这个函数.
  * 如果数组是稀疏的,则不会对不存在的数组元素调用传入的这个函数
  * 函数接收3个参数:数组元素的值,数组元素的索引,数组本身.
* 多数迭代器方法接收可选<span style="color:blue">第二个参数</span>.其作用是更新第一个参数函数内部的<span style="color:blue">this值</span>
* 函数返回值通常不重要,,但不同方法会以不同方式处理这个值.

##### forEach

* 迭代数组每个元素,并对每个元素都调用一次指定的函数

* forEach并未提供一种终止迭代的方式.没有与常规for循环中的break语句对等的机制

##### map

* 返回函数的返回值组成的数组,不修改调用它的数组.
* 如果数组是稀疏的,则缺失元素不会调用函数,但返回的数组也会与原始数组一样稀疏:长度相同,缺失的元素也相同



##### filter

* 返回一个数组,该数组为调用它的数组的子数组
* 传给方法的函数是断言函数,即返回true或false的函数
* 会<span style="color:blue">跳过</span>稀疏数组中缺失的元素,它返回的数组总是密集的,可以清理掉稀疏数组中的空隙

```javascript
//清除稀疏数组中缺失的元素

arr.filter(item => item)
arr.filter(() => true)

// 既清理空隙又删除值为undefined/null 的元素
arr.filter(item => item!==undefined && item !== null)
```



##### find/fineIndex

* 与filter函数相似,表现在它们都是遍历数组,寻找断言函数返回真值的元素
* 不同的是,这俩方法会在找到第一个元素时停止迭代
* 如果没有找到匹配的元素,find返回undefined, findIndex返回-1



##### every/some

* 数组断言方法
* 什么时候停止迭代数组
  * some()方法在断言函数第一次返回true或全部断言函数返回false时
  * every()方法在断言函数第一次返回false或全部断言函数返回true时
* 空数组上调用,按照数学的传统(??)
  * some, 返回false
  * every, 返回true

##### reduce/reduceRight

* reduce/reduceRight使用我们制定的函数**归并(注入/折叠)**数组元素
* 如果不传初始值,在空数组上调用reduce()会导致TypeError
* 如果数组只有一个值,或者是空数组但有初始值,则会返回这个值,不会调用归并函数
* 不接收用于指定归并函数this值得可选参数
* 使用范围: 只要能够把两个值(比如两个对象)组合成同一个类型值的函数,都可以用作归并函数
* 使用数组归并表达的算法容易复杂化,建议使用常规循环逻辑处理数组更容易阅读,编写和分析.



#### 栈和队列方法

* 通过`push(), pop(), unshift(), shift()`实现栈和队列的方法
* push()和pop()可以把数组当做栈(先进后出)来操作
  * push方法向数组末尾添加一个或多个元素,返回数组新的长度
  * pop方法删除数组最后的元素,返回删除的值
  * 这两个方法都会立刻修改数组
* unshift()和shift()方法可以把数组当做栈来处理
  * unshift在数组开头添加一个或多个元素,已有元素索引相应向更高处索引页移动,返回数组最新长度
    * unshift一次插入和多次插入的顺序不相同.
  * shift删除并返回数组的第一个元素,所有后续元素都向下移动一个位置,以占据数组开头空出的位置.
  * unshift和shift可以实现栈,但效率不如push 和 pop.因为每次在数组开头删除或添加元素都要向上或向下移动元素.
* 最佳实践: 使用push在数组末尾添加,使用shift在数组开头删除来实现队列





#### 子数组方法

使用slice,splice,fill,copyWithin方法,是数组处理连续区域的方法.

##### slice

* slice方法返回数组的切片(slice)或者子数组
* 接收两个参数
* 不会修改原数组



##### splice

* 对数组进行插入和删除,也可以同时执行这两种操作,会修改原数组
* splice参数: 第一个参数是删除或插入的起点位置(不是索引),第二个参数是删除的数量.两个参数之后任意多个参数,表示要在第一个参数指定的位置插入数组的元素
* splice返回被删除的元素的数组,如果没有删除元素则返回<u>空数组</u>



##### fill

* fill方法将数组的元素或切片设置为指定的值.
* 会修改调用它的数组
* 返回修改后的数组
* 第一个参数是要把数组元素设置成的值,可选的第二个参数指定起始索引,省略则从0开始填充.可选第三个参数指定终止索引,不包含这个索引.



##### copyWithin

* 把数组切片复制到数组中的新位置
* 会修改数组并返回修改后的数组,但不会改变数组的长度.
* 第一个参数指定要把第一个元素复制到的目的索引
* 第二个参数指定要复制的第一个元素的索引.如果省略第二个参数,则默认值为0.
* 第三个参数指定要复制的元素切片的终止索引.如果省略,使用数组的长度



#### 其他方法(打平,添加, 数组转字符串)

##### flat

* flat方法用于创建并返回一个新数组,这个新数组包含与它调用flat的数组相同的元素,如果元素是数组会被打平
* 不传参调用,只会打平一级嵌套.如果想要打平更多层级,需要传一个数值参数



##### flatMap

* 与map方法相似,返回的数组自动被打平.



##### concat



##### 数组转字符串

Array定义了3个数组转字符串的方法: join toString toLocalString



##### 作为数组的字符串

* JS字符串的行为类似utf-16字符的只读数组,除了使用charAt访问个别数组,还可以使用方括号语法
* 字符串与数组行为类似也意味着,可以对字符串使用数组的方法
* 字符串是不可修改值,尝试用数组的方法修改字符串并不会导致错误,静默失败



#### 索引和排序方法

数组实现与字符串的同名方法类似的indexOf,lastIndexOf,includes方法.

##### indexOf/lastIndexOf

* 从数组中搜索指定的值并返回第一个找到的元素的索引,如果没有找到则返回`-1`. 如果字符串这俩方法第二个参数为负值,会被当成0.
* indexOf从前到后;lastIndexOf从后到前
* 使用`===`全等运算符来比较参数和数组元素.
  * 如果比较的对象,则比较的是对象的地址
  * 如果想查找对象的内容,可以使用find方法并传入自定义的断言函数
* 都接收第二个参数,起始搜索位置.如果不传,indexOf从开头,lastIndexOf从末尾开始. 参数可以是负值,相对于数组末尾的偏移.



```javascript
//使用indexOf方法获取数组中与参数相同元素的所有索引值


function filterIndex(arr, x) {
  let len = arr.length
  let idx = 0
  let res = []
  
  while (idx < len) {
    idx = arr.indexOf(x, idx)
    
    if (idx === -1) {
      break
    }
    
    res.push(idx)
    idx++
  }
}



//其他方法
arr.filter((item,idx) => item===x && res.push(idx))
arr.reduce((acc, pre, idx) => {
  if (pre===x) acc.push(idx)
}, [])
```



##### includes

* 测试元素是否属性某个数组,返回布尔值
* 与indexOf方法的区别
  * indexOf使用`===`操作符同样的算法测试相等性,该相等性算法将非数值看成与其他值都不一样,包括与自身也不一样.
  * includes使用稍微不同的相等测试,认为NaN与自身相等.



##### sort

* sort方法对数组进行就地排序并返回排序后的数组
* 在不传参调用时,按字母顺序对数组元素进行排序(如有必要,临时将它们转换为字符串再比较
* 如果数组包括未定义的元素,它们会被排到数组的末尾
* 要对数组元素进行非字母顺序的排序,必须传入一个比较函数作为参数.
  * 这个函数决定它的两个参数哪一个在排序后的数组中应该出现在前面
  * 如果要第一个参数在前, 第二个参数在后, 比较函数应该返回一个小于0的数值
  * 如果要第一个参数要出现在第二个参数后面, 比较函数应该返回一个大于0的数值
  * 如果两个值相等,则比较函数应该返回0.
* 如果对字符串数组做不区分大小写的字母序排序,传入的比较函数应该使用toLowerCase()方法,将其两个参数都转换为小写,再比较.



##### reverse

* 翻转数组元素的顺序,并返回反序后的数组







### 数组方法







#### 破坏性方法和非破坏性方法

| 非破坏性方法名称           | 返回值                                                       |
| -------------------------- | ------------------------------------------------------------ |
| Array.prototype.toString() | 字符串                                                       |
| Array.prototype.slice()    | 对数组进行截取,返回截取的数组                                |
| Array.prototype.concat()   | 连接2个或多个数组,并返回结果                                 |
| Array.prototype.indexOf()  | 查询元素第一次出现在数组的位置并返回,没有返回-1              |
| Array.prototype.join()     | 将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN_docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串 |
| Array.prototype.some()     | 检测数组中是否有元素符合指定条件                             |
| Array.prototype.every()    | 检测数组元素是否都符合条件                                   |
| Array.prototype.filter()   | 返回符合检测条件的元素并返回符合条件的所有元素组成的数组     |
| Array.prototype.map()      | 通过指定函数处理每个元素,并解放者处理后的数组                |
| Array.prototype.valueOf()  | 返回数组对象的原始值                                         |



| 破坏性方法                | 返回值                                       |
| ------------------------- | -------------------------------------------- |
| Array.prototype.splice()  | 用于插入,删除或替换数组的元素                |
| Array.prototype.push()    | 向数组末尾添加1个或多个元素,返回数组新的长度 |
| Array.prototype.pop()     | 删除并返回数组最后一个元素                   |
| Array.prototype.unshift() | 向数组开头添加1个或多个元素,返回数组新的长度 |
| Array.prototype.shift()   | 删除并返回数组的第一个元素                   |
| Array.prototype.reverse() | 反转数组的元素顺序                           |
| Array.prototype.sort()    | 对数组元素进行排序                           |



#### Array.prototype.toString

`**toString()**` 返回一个字符串，表示指定的数组及其元素

```js
Array.prototype.toString()

//描述
-Array对象覆盖了Object的 toString 方法。对于数组对象，toString 方法连接数组并返回一个字符串，其中包含用逗号分隔的每个数组元素。
-当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法
```



#### Array.prototype.forEach

**syntax**

```javascript
forEach(callback, thisArg)
```



**方法重写**

```javascript
Array.prototype.myForEach = function(callback) {
  let _arr = this,
      thisArg = arguments[1] || globalThis;
  
  //判断this是否合法
  if (this === null || this === undefined) {
    return new TypeError("cannot read property of 'myForEach' of null");
  }
  
  //判断callback是否合法
  if (Object.prototype.toString.call(callback).slice(8, -1) !== 'Function') {
    return new TypeError(callback + 'is not a function');
  }
  
  
  for (let i=0; i<_arr.length; i++) {
    callback.call(thisArg, _arr[i], i, _arr);
  }
}
```



#### Array.prototype.slice-截取

**定义**

`**slice()**` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`，不包括`end`）。原始数组不会被改变。

**Syntax**

```javascript
slice()
slice(start)
slice(start, end)
```



**参数**

`begin` 可选

* 提取起始处的索引（从 `0` 开始），从该索引开始提取原数组元素。

* 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取

* 如果省略 `begin`，则 `slice` 从索引 `0` 开始。

* 如果 `begin` 超出原数组的索引范围，则会返回空数组。

`end`  可选

* 提取终止处的索引（从 `0` 开始），在该索引处结束提取原数组元素
* 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取
* 如果 `end` 被省略，则 `slice` 会一直提取到原数组末尾。包括最后一个
* 如果 `end` 大于数组的长度，`slice` 也会一直提取到原数组末尾.

**返回值**

一个含有被提取元素的新数组

**描述**

`slice` 不会修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：

* 如果该元素是个对象引用 （不是实际的对象），`slice` 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。
* 对于字符串、数字及布尔值来说（不是 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)、[`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 或者 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) 对象），`slice` 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。

<u>如果向两个数组任一中添加了新元素，则另一个不会受到影响。</u>

```javascript
let obj = {a: 'a', b: 'b'},
    arr = [1, obj, {c: 'c'}];

let result = arr.slice();

obj['a'] = 'aa';
console.log(result);  //[1, {a: 'aa', b: 'b'}, {c: 'c'}]
```



**实例**

1.复制数组

```JavaScript
//复制整个数组的方法
	arr.slice()
	arr.slice('')  //非数字类型参数下相当于没传递参数
	arr.slice(0)
```

类数组转换为真数组

```javascript
//es5
let arrLike = {0:0, 1:1, 2:2, length: 3};
let arr = Array.prototype.slice.call(arrLike);
let result = [].slice.call(arrLike);

//es6
Array.of(arguments)
```



**代码实现**

```js
Array.prototype.mySlice = function(start, end) {
  let arr = this;
  let newArr = [];
  
  start = start || 0;
  end = end || arr.length;
  start = start < 0 ? 0 : start;
  end = end + arr.length < 0 ? 0 : end + length;
  if (end > arr.length) end = arr.length;
  
  if (start > arr.length || end === 0) {
    return newArr;
  }
  
  for (let i=start; i<end; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
}
```





#### Array.prototype.splice-删除 替换 新增

**定义**

**`splice()`** 方法通过**删除或替换**现有元素或者**原地添加**新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

**参数**

```javascript
array.splice(start[, deleteCount[, item1[, items[, ...]]]])
```

`start`
* 如果为空. 则返回一个空数组
* 指定修改的开始位置（从0计数）。可以将其视为新的长度.
* 如果超出了数组的长度，则从数组末尾开始添加内容；
* 如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于`array.length-n`）；
* 如果负数的绝对值大于数组的长度，则表示开始位置为第0位。

`deleteCount` 可选
* 整数，表示要移除的数组元素的个数。
* 如果 `deleteCount` 大于 `start` 之后的元素的总数，则从 `start` 后面的元素都将被删除（含第 `start` 位）。
* 如果 `deleteCount` 被省略了，或者它的值大于等于`array.length - start`(也就是说，如果它大于或者等于`start`之后的所有元素的数量)，那么`start`之后数组的所有元素都会被删除。
* 如果 `deleteCount` 是 0 或者负数，则不移除元素。返回空数组.

`item1, item2,...`

* 要添加进数组的元素,从`start` 位置开始。如果不指定，则 `splice()` 将只删除数组元素

**返回值**

由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

**实例**

```javascript
1.从第2位开始删除1个元素,插入'drum'
let myFish = ['angel',"clown", "mandarin", "sturgeon"]
myFish.splice(2,1,'drum')

2.从倒数第2位开始删除1个元素
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(-2, 1);
// 运算后的 myFish: ["angel", "clown", "sturgeon"]
// 被删除的元素: ["mandarin"]

```



**代码实现** ????

```js
// https://juejin.cn/post/6844903986479251464#heading-39


```



#### Array.prototype.concat()

**定义**

**`concat()`** 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组

**参数**

```javascript
var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])
```

`valueN` 可选

数组和/或值，将被合并到一个新的数组中。如果省略了所有 `valueN` 参数，则 `concat` 会返回调用此方法的现存数组的一个<u>浅拷贝</u>。

**返回值**

新的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 实例

**描述**

* `concat`方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。
* `concat`方法不会改变`this`或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中:
  * 对象引用（而不是实际对象）：`concat`将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。
  * 数据类型如字符串，数字和布尔（不是[`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)，[`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 和 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) 对象）：`concat`将字符串和数字的值复制到新数组中
  * 对于新数组的任何操作（仅当元素不是对象引用时）都不会对原始数组产生影响，反之亦然。

**实例**

连接3个数组

```javascript
var num1 = [1, 2, 3],
    num2 = [4, 5, 6],
    num3 = [7, 8, 9];

var nums = num1.concat(num2, num3);

console.log(nums);
// results in [1, 2, 3, 4, 5, 6, 7, 8, 9]


let arr = [1,2,3];
let res = arr.concat(4,5,[6,7],8,{a: 9});
console.log(res); //[1,2,3,4,5,6,7,8,{a:9}]
```

连接对象

```javascript
//合并对象
let obj ={a:2}
let arr=[1,2,3]
let result = arr.concat(obj);
console.log(result);//[1,2,3,{a:2}]
```

浅拷贝验证

```javascript
let arr=[1,2,3,{a:4}];
let result=arr.concat();
arr[3].a=5;
console.log(arr, result);
//[1, 2, 3,{a:5}] [1, 2, 3,{a:5}]
```



**代码实现**

```js
//代码实现

Array.prototype.concat=function(){
  let length = arguments.length;
  let result = this;
  if(length===0){
    return result;
  }else{
    for(let i=0;i<length;i++){
      if(Array.isArray(arguments[i])){
        result.push(...arguments[i])
      }else{
        result.push(arguments[i])
      }
    }
    return result;
  }
}
```





  



#### Array.prototype.indexOf()

**定义**

`indexOf()`方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1

**参数**

```javascript
arr.indexOf(searchElement[, fromIndex])
```

`searchElement`

* 要查找的元素

`fromIndex` 可选

* 开始查找的位置。包括查找的位置
* 如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1
* 如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消或者通过(length+负值)得出
* 如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组

**返回值**

首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1.

**描述**

* `indexOf` 使用[strict equality (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#using_the_equality_operators) (无论是 ===, 还是 triple-equals操作符都基于同样的方法)进行判断 `searchElement与`数组中包含的元素之间的关系
* <span style="color:blue">和`includes`类似, `+0`和`-0`是被认为是相等的, 但是`NaN`与`NaN`相反, `indexOf`认为不相等, `includes`认为相等</span>



**重写**

```javascript
Array.prototype.myIndexOf = function(searchItem, fromIndex) {
  if (this.length === 0 || fromIndex >= this.length) {
    return -1;
  }
  if (!searchItem) {
    return new Error('need offer an initial value')
  }
  
  if (fromIndex < 0) {
    fromIndex = fromIndex+this.length < 0 ? 0 : fromIndex+this.length;
  }
  
  for (let i=0; i<this.length; i++) {
    if (searchItem === this[i]) {
      return i;
    }
  }
  return -1;
}
```



**实例**

数组去重

```javascript
let arr = [1,2,3,1,1,4,3,2,5,6,7];
let newArr = [];
arr.forEach(item => {
  if (newArr.indexOf(item) === -1) {
    newArr.push(item);
  }
});
```

找出元素出现的所有位置

```javascript
let arr = [1,2,3,1,1,4,3,2,5,6,7];
let indexArr = [];

function searchIndex(ele, arr) {
  for (let i=0; i<arr.length;) {
    let index = arr.indexOf(ele, i);
    if (index === -1) return;
    indexArr.push(index);
    i = index + 1;
  }
  return indexArr;
}

searchIndex(1, arr)

//另一种方法
let indices = [],
    array = ['a', 'b', 'c', 'd', 'a', 'd'],
    ele = 'a';

let idx = array.indexOf(ele);
while(idx !== -1) {
	indices.push(idx);
  idx = array.indexOf(element, idx + 1);
}
```



**代码实现**

```js
Array.prototype.indexOf=function(item,index){
  let start;
  let flag=false;
  let length = this.length;
  if(!start){
    start=0;
  }else if(start>length){
    start=length;
  }else if(start<0){
    start=length+start;
  }
  
  for(let i=start;i<length;i++){
    if(arr[i]===item){
      flag = true;
      return i;
    }
  }
  if(!flag){
    return -1;
  }
}
```



#### Array.prototype.lastIndexOf()

**定义**

`lastIndexOf()` 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 `fromIndex` 处开始。

**参数**

```javascript
arr.lastIndexOf(searchElement[, fromIndex])
```

`searchElement`

* 被查找的元素

`fromIndex` 可选

* 从此位置开始逆向查找。
* 默认为数组的长度减 1(`arr.length - 1`)，即整个数组都被查找。
* 如果该值大于或等于数组的长度，则整个数组会被查找。
* 如果为负值，将其视为从数组末尾向前的偏移。
* 即使该值为负，数组仍然会被从后向前查找。
* 如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。

**重写**

```javascript
Array.prototype.lastIndexOf = function(searchItem, fromIndex = this.length -1) {
  if (this.length === 0) {
    return new Error("the array's length must greater than 0")
  }
  if (fromIndex < 0 && Math.abs(fromIndex) > this.length) {
    return -1;
  }
  if (fromIndex < 0 && Math.abs(fromIndex) <= this.length) {
    fromIndex = this.length + fromIndex;
  }
  if (fromIndex >= this.length) {
    fromIndex = this.length;
  }
  for (let i=fromIndex; i>=0; i--) {
    if (searchItem === this[i]) {
      return i;
    }
  }
  return -1;
}
```



**返回值**

数组中该元素最后一次出现的索引，如未找到返回-1。

**描述**

`lastIndexOf` 使用[严格相等](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Using_the_Equality_Operators)（strict equality，即 ===）比较 `searchElement` 和数组中的元素

**实例**

用 `lastIndexOf` 查找到一个元素在数组中所有的索引（下标），并使用 [`push`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push) 将所有添加到另一个数组中。

```javascript
let arr = [1,2,3,4,5,1,2,1,3,1,5,2,4,4,1],
    indexArr = [];

function searchIndex(arr, ele) {
  let idx = arr.lastIndexOf(ele);
  while(idx !== -1) {
    indexArr.push(idx);
    if (idx === 0) return;
    idx = arr.lastIndexOf(ele, idx - 1);
  }
}


//另外的方法
let idx = arr.lastIndexOf(ele);
while(idx !== -1) {
  indexArr.push(idx);
  idx = (idx > 0 ? arr.lastIndexOf(ele, idx - 1) : -1);
}

```

数组中有且只有一个且只取第一个此类元素

```javascript
function getNoRepeatParament(s) {
  let arr = s.toLowerCase().split('');
  for (let value of arr) {
    if (arr.indexOf(value) === arr.lastIndexOf(value)) return s[arr.indexOf(value)]
  }
}
```

获取数组中的只出现一次的元素

```javascript

let arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 1, 2, 3, 4];

let filterArr = arr.filter((item, index) => arr.indexOf(item) === arr.lastIndexOf(value));


```



#### Array.prototype.join()

**定义**

`**join()**` 方法将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN_docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该元素字符串而不使用分隔符。

toString()与join()实现同样的效果

**参数**

```javascript
arr.join([separator])
```

`separator` 可选

* 指定一个字符来分隔数组的每个元素。
* 如果需要，将分隔符转换为字符串。
* 如果缺省该值，数组元素用逗号（`,`）分隔。
* 如果`separator`是空字符串(`""`)，则所有元素之间都没有任何字符。

**返回值**

一个所有数组元素连接的字符串。如果 `arr.length` 为0，则返回空字符串

**描述**

* 所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。
* 如果一个元素为 `undefined` 或 `null`，它会被转换为空字符串。

**实例**

连接类数组对象

```javascript
Array.prototype.join.call(arguments)
[].join.call(arguments)
```

**代码实现**

```js
//手写代码
当数组调用toString(),String()方法的时候,底层代码也调用了join(),所以使用转换字符换方法重写函数会出现死循环.

Array.prototype.join=function(sep){
  if(!sep){
    sep=','
  }
  let arr = this;
  let newStr = '';
  for(let i=0;i<arr.length;i++){
    newStr += arr[i]+ (arr[i]===arr[length-1]?'':sep)
  }
  return newStr
}
let arr = [1,2,3]
let result = arr.join()
```



  

#### Array.prototype.reverse()

**定义**

`reverse()` 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。

**参数**

```javascript
arr.reverse()
```

**返回值**

颠倒后的数组。

**描述**

* `reverse` 方法颠倒数组中元素的位置，改变了数组，并返回该数组的引用
* reverse方法是特意类化的；此方法可被 [called](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 或 [applied](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)于类似数组对象。
* 对象如果不包含反映一系列连续的、基于零的数值属性中的最后一个长度的属性，则该对象可能不会以任何有意义的方式运行。

**重写**

```javascript
Array.prototype.myReverse = function() {
  let temp;
  
  //偶数
  if (this.length % 2 === 0) {
    for (let i=0; i<this.length/2; i++) {
      temp = this[i];
      this[i] = this[this.length-1-i];
      this[this.length-1-i] = temp;
      temp = null;
    }
  }
  
  
  //奇数
  if (this.length % 2 !== 0) {
    for (let i=0; i<=Math.ceil(this.length / 2); i++) {
    	if (Math.ceil(this.length/2) === i) {
        this[i] = this[i]
      }
      
      temp = this[i];
      this[i] = this[this.length-1-i];
      this[this.length-1-i] = temp;
      temp = null;
    }
  }
  
  return this;
}
```



**实例**

颠倒类数组中的元素

```javascript
const a = {0: 1, 1: 2, 2: 3, length: 3};

console.log(a); // {0: 1, 1: 2, 2: 3, length: 3}

Array.prototype.reverse.call(a); //same syntax for using apply()
[].reverse.call(a)

console.log(a); // {0: 3, 1: 2, 2: 1, length: 3}
```


### [[202302272171|Array.prototype.sort]]



#### Array.prototype.map()

**定义**

map()方法返回一个由原数组中每个元素调用一个指定方法后的返回值组成的新数组, 可以改变原数组



**参数**

```javascript
let new_array = arr.map(function callback(currentValue[,index[, array]])) {
  //
}[, thisArg]
```

`callback` 

* 生成新数组元素的函数，使用三个参数：
  * `currentValue` `callback` 数组中正在处理的当前元素。
  * `index`**可选**  `callback` 数组中正在处理的当前元素的索引
  * `array` **可选** `map` 方法调用的数组。
* `thisArg` 可选
  * 执行 `callback` 函数时值被用作`this`

**返回值**

一个由原数组每个元素执行回调函数的结果组成的新数组。

**描述**

* `map` 方法会给原数组中的每个元素都按顺序调用一次  `callback` 函数。
* `callback` 每次执行后的返回值（包括 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)）组合起来形成一个新数组。
*  `callback` 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 `delete` 删除的索引则不会被调用。
* 如果 `thisArg` 参数提供给`map`，则会被用作回调函数的`this`值。否则[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)会被用作回调函数的`this`值。
* `map `不修改调用它的原数组本身（当然可以在 `callback` 执行时改变原数组）!!!!
* `map` 方法处理数组元素的范围是在 `callback` 方法第一次调用之前就已经确定了。调用`map`方法之后追加的数组元素不会被`callback`访问。
* 如果存在的数组元素改变了，那么传给`callback`的值是`map`访问该元素时的值。在`map`函数调用后但在访问该元素前，该元素被删除的话，则无法被访问到。
* 根据规范中定义的算法，如果被map调用的数组是离散的，新数组将也是离散的保持相同的索引为空。

**实现**

依照 [ecma262 草案](https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-array.prototype.map)，实现的map的规范如下:

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/3/16e311d99e860405~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



```javascript
//根据草案实现
//https://juejin.cn/post/6844903938890661896#comment
//https://juejin.cn/post/6844903986479251464#heading-39
Array.prototype.map = function(callback, thisArg) {
  
  // 处理数组类型异常
  
  // 处理回调类型异常
  
  //先转换为对象
  let O = Object(this)
  let T = thisArg || undefined
  
  let len = O.length >>> 0
  let A = new Array(len)
  for (let k=0; k<len; k++) {
    //如果使用hasOwnProperty 它只查找私有属性
    if (k in O) {
      let kValue = O[k]
      let mappedValue = callback.call(T,kValue,k,O)
      A[k] = mappedValue
    }
  }
  return A
}


//注意  
//length >>> 0 字面意思右移零位,这里的作用是保证len为数字且为整数.

//为什么使用in查找而不使用hasOwnProperty查找:    in使用原型链查找, 能有效处理稀疏数组的情况  这个地方我是存疑的,如果k不存在于数组O身上,那么在原型上也找不到. 例如 0 in [] 返回的是false
```



```javascript
//V8源码实现  

function ArrayMap(f, receiver) {
  CHECK_OBJECT_COERCIBLE(this, 'Array.prototype.map')
  
  // Pull out the length so that modification to the length in the loop will not affect the looping and side effects are visible
  
  var array = TO_OBJECT(this)
  let length = TO_LENGTH(array.length)
  if (!IS_CALLABLE(f)) throw $make_type_error(kCalledNonCallable, f);
  
  for (var i=0; i<length; i++) {
    if (i in array) {
      var element = array[i]
      %CreateDataProperty(result, i, %_Call(f, receiver, element, i, array))
    }
  }
  
  return result
}
```



```javascript
//简略版

Array.prototype.myMap = function(callback) {
  let arr = this,
      thisArg = arguments[1],
      resArr = [];
  
  // verify this
  if (Object.prototype.toString.call(this).slice(8, -1) !== 'Array') {
    throw new TypeError('the Object type must be an Array');
  }
  // verify callback
  if (arguments.length === 0) {
    throw new TypeError('undefined is not a function');
  }
  
  for (let i=0; i<arr.length; i++) {
    resArr.push(callback.call(thisArg, arr[i], i, arr));
  }
  return resArr;
}
```



**实例**

[使用 map 重新格式化数组中的对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#使用_map_重新格式化数组中的对象)

```javascript
var kvArray = [{key: 1, value: 10},
               {key: 2, value: 20},
               {key: 3, value: 30}];

var reformattedArray = kvArray.map(function(obj) {
   var rObj = {};
   rObj[obj.key] = obj.value;
   return rObj;
});

// reformattedArray 数组为： [{1: 10}, {2: 20}, {3: 30}],
```

使用技巧

```javascript
["1", "2", "3"].map(parseInt); //[1, NaN, NaN]

["1", "2", "3"].map(parseInt('1', 0));  //十进制 1
["1", "2", "3"].map(parseInt('2', 1));  //基数超范围 NaN
["1", "2", "3"].map(parseInt('3', 2));  //NaN


//解决方案
function returnInt(element) {
  return parseInt(element, 10);
}

['1', '2', '3'].map(returnInt); // [1, 2, 3]
// Actual result is an array of numbers (as expected)

// Same as above, but using the concise arrow function syntax
['1', '2', '3'].map( str => parseInt(str) );

// A simpler way to achieve the above, while avoiding the "gotcha":
['1', '2', '3'].map(Number); // [1, 2, 3]

// But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:
['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300]
// For comparison, if we use parseInt() on the array above:
['1.1', '2.2e2', '3e300'].map( str => parseInt(str) ); // [1, 2, 3]
```

[Mapping 含 undefined的数组](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#mapping_含_undefined的数组)

```javascript
let numbers = [1,2,3,4];
let filterNumbers = numbers.map((num, index) => {
  if (index < 3) return num;
});

console.log(filterNumbers); //[1,2,3,undefined]
```



#### Array.prototype.filter()

**定义**

`filter()` 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素.不会改变原数组，它返回过滤后的新数组.

**参数**

```javascript
let newArray = arr.filter(callback(element[, index[, array]])[, thisArg])
```

`callback` 

* 用来测试数组的每个元素的函数。返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它接受以下三个参数：
  * `element`  数组中当前正在处理的元素。
  * `index`  **可选** 正在处理的元素在数组中的索引
  * `array` **可选** 调用了 `filter` 的数组本身

`thisArg` 

* 执行 `callback` 时，用于 `this` 的值。

**返回值**

一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。

**描述**

* `filter` 为数组中的每个元素调用一次 `callback` 函数，并利用所有使得 `callback` 返回 true 或[等价于 true 的值](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)的元素创建一个新数组。
* `callback` 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 `callback` 测试的元素会被跳过，不会被包含在新数组中。
* 如果为 `filter` 提供一个 `thisArg` 参数，则它会被作为 `callback` 被调用时的 `this` 值。否则，`callback` 的 `this` 值在非严格模式下将是全局对象，严格模式下为 `undefined`。
* `filter` 遍历的元素范围在第一次调用 `callback` 之前就已经确定了。在调用 `filter` 之后被添加到数组中的元素不会被 `filter` 遍历到。
* 如果已经存在的元素被改变了，则他们传入 `callback` 的值是 `filter` 遍历到它们那一刻的值。被删除或<u>从来未被赋值的元素</u>不会被遍历到。(null, undefined会被当做元素输出, 空位不会)



**重写**

```javascript
Array.prototype.myFilter = function(callback) {
  let _arr = this,
      thisArg = arguments[1] || window,
      result = [];
  
  for (let i=0; i<_arr.length; i++) {
    if (callback.call(thisArg, _arr[i], i, _arr)) {
      result.push(_arr[i])
    }
  }
  return result;
}
```



**实例**

[过滤 JSON 中的无效条目](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#过滤_json_中的无效条目)

```javascript
//使用 filter() 创建具有非零 id 的元素的 json

var arr = [
  { id: 15 },
  { id: -1 },
  { id: 0 },
  { id: 3 },
  { id: 12.2 },
  { },
  { id: null },
  { id: NaN },
  { id: 'undefined' }
];

var invalidEntries = 0;

function isNumber(obj) {
  return obj !== undefined && typeof(obj) === 'number' && !isNaN(obj);
}

function filterById(item) {
  if (isNumber(item.id) && item.id !== 0) {
    return true;
  }
  invalidEntries++;
  return false;
}

var arrByID = arr.filter(filterByID);

console.log('Filtered Array\n', arrByID);
// Filtered Array
// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]

console.log('Number of Invalid Entries = ', invalidEntries);
// Number of Invalid Entries = 5
```



#### Array.prototype.reduce()

**定义**

`reduce()` 方法对数组中的每个元素执行一个由您提供的**reducer**函数(升序执行)，将其结果汇总为单个返回值。

**参数**

```javascript
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])

Accumulator(acc) 累计器
Current Value(cur)当前值
Current Index(idx)当前索引
Source Array(src)源数组
```

reducer函数的返回值分配给累计器,该返回值在数组的每个迭代中被记住,并最后成为最终的单个结果值.

`callback` 

执行数组中每个值 (如果没有提供 `initialValue则第一个值除外`)的函数，包含四个参数：

* `accumulator` 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或`initialValue`（见于下方）。
* `currentValue` 数组中正在处理的元素
* `index` **可选** 数组中正在处理的当前元素的索引。 如果提供了`initialValue`，则起始索引号为0，否则从索引1起始。
* `array` **可选** 调用`reduce()`的数组

`initialValue`  **可选**

* 作为第一次调用 `callback`函数时的第一个参数的值。 
* 如果没有提供初始值，则将使用数组中的第一个元素。 
* 在空数组上调用 没有初始值的reduce 将报错。

```javascript
[].reduce(() => {})
//Uncaught TyperError: Reduce of empty array with no initial value 

[].reduce(() => {}, 0) //0
```



**返回值**

函数累计处理的结果

**描述**

* `reduce`为数组中的每一个元素依次执行`callback`函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：
* 回调函数第一次执行时，`accumulator` 和`currentValue`的取值有两种情况：
  * 如果提供了`initialValue`，`accumulator`取值为`initialValue`，`currentValue`取数组中的第一个值；`currentIndex`为`currentValue`的索引值.
  * 如果没有提供 `initialValue`，那么`accumulator`取数组中的第一个值，`currentValue`取数组中的第二个值。
  * 如果没有提供`initialValue`，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供`initialValue`，从索引0开始。
* 如果数组为空且没有提供`initialValue`，会抛出[`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 。
* 如果数组仅有一个元素（无论位置如何）并且没有提供`initialValue`， 或者有提供`initialValue`但是数组为空，那么此唯一值将被返回并且`callback`不会被执行。

提供初始值通常更安全，正如下面的例子，如果没有提供`initialValue`，则可能有四种输出： !!!!

```javascript
var maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );
var maxCallback2 = ( max, cur ) => Math.max( max, cur );

// reduce() 没有初始值
[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN
[ { x: 2 }, { x: 22 }            ].reduce( maxCallback ); // 22
[ { x: 2 }                       ].reduce( maxCallback ); // { x: 2 }
[                                ].reduce( maxCallback ); // TypeError

// map/reduce; 这是更好的方案，即使传入空数组或更大数组也可正常执行
[ { x: 22 }, { x: 42 } ].map( el => el.x )
                        .reduce( maxCallback2, -Infinity );
```

**方法重写**

`reduce` 可以理解为「归一」，意为海纳百川，万剑归一



ECMA-262 规范文档实现如下:

> https://tc39.es/ecma262/#sec-array.prototype.reduce

<img src="https://cdn.jsdelivr.net/gh/aotushi/image-hosting@master/documentation/image.7aj30gv837c0.webp" alt="image" style="zoom: 150%;" />

```javascript
//https://juejin.cn/post/6844903938890661896#heading-3

Array.prototype.reduce = function(callback, initialValue) {
  // 异常处理
  
  let O = Object(this)
  let len = O.length >>> 0
  let k = 0, accumulator
  
  // 新增
  if (initialValue) {
    accumulator = initialValue
  } else {
    // step 4.
    if (len === 0) {
      throw new TypeError('reduce of empty array with no intial value')
    }
    
    // step 8.
    let kPresent = false  //没有找到关于Pk的解释
    while(!kPresent && (k < len)) {
      kPresent = k in O
      if (kPresent) {
        accumulator = O[k]
      }
      k++
    }
  }
  
  while(k < len) {
    if (k in O) {
      let kValue = O[k]
      accumulator = callback.call(undefined, accumulator, kValue, k, O)
    }
    k++
  }
  
  return accumulator
}
```



```javascript
Array.prototype.myReduce = function (callback) {
  let _arr = this,
      accumulator = argument[1],
      i = 0;
  //判断是否存在参数
  if (arguments.length === 0) {
    throw new TypeError('undefined is not a function');
  }
  //判断是否传入初始值
  if (accumulator === undefined) {
    accumulator = _arr[i];
    i++;
  }
  
  for (;i<_arr.length; i++) {
    accumulator = callback(accumulator, _arr[i], i, _arr);
  }
  
  return accumulator;
}
```





**实例**

1.计算数组中元素出现的次数

```js
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice','Bruce', 'Alice'];
let nameNum = names.reduce((prev,current,index)=>{
  if(current in prev){
    prev[current]++;  //pre[current] = pre[current] + 1;
  }else{
    prev[current]=1;
  }
  return prev;
},{})
console.log(nameNum); //{ Alice: 3, Bob: 1, Tiff: 1, Bruce: 2 }


// 其他方法 20220928  麻烦

[1,2,3,4,2,3,4].reduce((acc, crt) => 
	crt in acc
  ? Object.assign(acc, {[crt]: acc[crt]++})
  : Object.assing(acc, {[crt]: 1})                    
	, {})
```



2.数组去重

```js
let arr = [1,2,3,4,4,1]
let newArr = arr.reduce((prev,current)=>{
    if(!prev.includes(current)){
        return prev.concat(current)  //push也可以
    }else{ //else没有必要
        return prev;
    }
},[])

//简化
arr.reduce((prev, crt) => !prev.includes(crt) ? prev.concat(crt) : prev [])
```



3. 二维数组转换成一维数组

```js
let arr = [[0, 1], [2, 3], [4, 5]]
let newArr = arr.reduce((prev,current)=>{
    return prev.concat(current)
},[]);

console.log(newArr)
```



4. 多维数组转换成一维数组

```js
// 递归 recursion
// flat
let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
let newArr = function(arr){
    return arr.reduce((prev,current)=>{
        return prev.concat(Array.isArray(current)?newArr(current):current);
    },[])
}


arr.reduce((acc, crt) =>
	Array.isArray(crt)
    	? acc.concat(crt.flat(Infinity))
        : acc.concat(crt)
,[])
```



5.对象里的属性求和

```js
var result = [
    {
        subject: 'math',
        score: 10
    },
    {
        subject: 'chinese',
        score: 20
    },
    {
        subject: 'english',
        score: 30
    }
];

let sum = result.reduce((prev, current) => {
    return prev+current.score
},0)

console.log(sum)
```



6.数组转换成对象

```js
//数组1
let arr = ['1', '2', '3', '4', '1', '2', '4'];
let obj = arr.reduce((prev,current,index)=>{
  return Object.assign(prev,{[index]:current});
},{});

console.log(obj);
{
  '0': '1',
  '1': '2',
  '2': '3',
  '3': '4',
  '4': '1',
  '5': '2',
  '6': '4'
}

//数组2
将它转化为一个根据id值作为key，将数组每项作为value的对象
const userList = [
  {
    id: 1,
    username: 'john',
    sex: 1,
    email: 'john@163.com'
  },
  {
    id: 2,
    username: 'jerry',
    sex: 1,
    email: 'jerry@163.com'
  },
  {
    id: 3,
    username: 'nancy',
    sex: 0,
    email: ''
  }
];

let obj = userList.reduce((prev,current)=>{
  return {...prev,[current.id]:current}
},{})
console.log(obj)
```

7.按属性对object分类

```js
var people = [
    { name: 'Alice', age: 21 },
    { name: 'Max', age: 20 },
    { name: 'Jane', age: 20 }
];
  
function groupBy(objArray, property) {
    return objArray.reduce((acc, current) => {
        let key = current[property];
        if (!acc[key]) {
            acc[key]=[]
        }
        acc[key].push(current);
        return acc;
    },{})
}

let a = groupBy(people, 'age')
console.log(a)

//这个地方如果使用三元表达式的话,要比函数体的形式麻烦很多
function groupBy(arr, key) {
  return arr.reduce((acc, crt) => acc[crt[key]]?
                    {...acc, crt[key]:acc[crt[key]].concat(crt)}:
                    {...acc, crt[key]:[crt]}
                    ,{})
}
//上面对象键要求是字符串,JS中的已使用的字符会造成解释器混乱报错


{
  '20': [ { name: 'Max', age: 20 }, { name: 'Jane', age: 20 } ],
  '21': [ { name: 'Alice', age: 21 } ]
}

//20211203
function classifyObj(arr, property) {
  return arr.reduce((acc, cur) => {
    if (cur[property] in acc) {
      acc[property] = acc[property].concat(cur);
    } else {
      acc[property] = [].concat(cur[property]);
    }
    
    returrn acc;
  }, {})
}
```

8.[使用扩展运算符和initialValue绑定包含在对象数组中的数组](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#使用扩展运算符和initialvalue绑定包含在对象数组中的数组)

```javascript
var friends = [
  {
    name: 'Anna',
    books: ['Bible', 'Harry Potter'],
    age: 21
  }, 
  {
    name: 'Bob',
    books: ['War and peace', 'Romeo and Juliet'],
    age: 26
  }, 
  {
    name: 'Alice',
    books: ['The Lord of the Rings', 'The Shining'],
    age: 18
  }
];

//输出结果
// allbooks = [
//   'Alphabet', 'Bible', 'Harry Potter', 'War and peace',
//   'Romeo and Juliet', 'The Lord of the Rings',
//   'The Shining'
// ]

let result1 = frineds.reduce((acc, cur) => {
  return acc.concat(cur.books)
}, ['Alphabet'])

let result2 = friends.reduce((acc, cur) => {
  //acc.push(...cur.books)
  //return acc
  return [...acc, ...cur.books]
}, ['Alphabet'])
```

9.数组去重

```javascript
let myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd'];
let myOrderedArray = myArray.reduce((acc, cur) => {
  if (!acc.includes(cur)) {  //(acc.indexOf(cur) === -1)
    acc.push(cur)
  }
  return acc;
}, []);

//其他方法
let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];
let result = arr.sort().reduce((init, current) => {
    if(init.length === 0 || init[init.length-1] !== current) {
        init.push(current);
    }
    return init;
}, []);
console.log(result); //[1,2,3,4,5]


```

9.按顺序运行Promise !!!!????

```javascript
function runPromiseInSequence(arr, input) {
  return arr.reduce(
    (promiseChain, currentFunction) => promiseChain.then(currentFunction),
    Promise.resolve(input)
  );
}

// promise function 1
function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5);
  });
}

// promise function 2
function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2);
  });
}

// function 3  - will be wrapped in a resolved promise by .then()
function f3(a) {
 return a * 3;
}

// promise function 4
function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4);
  });
}

const promiseArr = [p1, p2, f3, p4];
runPromiseInSequence(promiseArr, 10)
  .then(console.log);   // 1200
```

10.使用reduce实现map ????!!!!

```javascript
if (!Array.prototype.mapUsingReduce) {
  Array.prototype.mapUsingReduce = function(callback, thisArg) {
    return this.reduce((mapperdArray, currentValue, index, array) => {
      mappedArray[index] = callback.call(thisArg, currentValue, index, array)
      return mapeedArray;
    }, [])
  }
}


[1,2,,3].mapUsingReduce((cur, idx, arr) => cur + index + array.length)
//[5,7,,10]
```



#### Array.prototype.some

**定义**

`**some()**` 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。

如果用一个空数组进行测试，在任何情况下它返回的都是`false`。

```javascript
[].some(()=>{})  //false
```

**参数**

```javascript
arr.some(callback(element[, index[, array]])[, thisArg])
```

`callback` 

* 用来测试每个元素的函数，接受三个参数：
  * `element` 数组中正在处理的元素
  * `idx` **可选** 数组中正在处理的元素的索引值
  * `array` **可选** 调用`some()`的当前数组

`thisArg` **可选**

* 执行 `callback` 时使用的 `this` 值

我们来看下this的几种情况:

```javascript
//thisArg存在, callback参数中即使没有传递也可以访问 当然是没有call
[1].some(function () {console.log(this), [1,2,3]) //[1,2,3]

//
```



**返回值**

* 数组中有至少一个元素通过回调函数的测试就会返回**`true`**；所有元素都没有通过回调函数的测试返回值才会为false。
* 如果是空数组,返回false

**描述**

* `some()` 为数组中的每一个元素执行一次 `callback` 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，`some()` 将会立即返回 `true`。否则，`some()` 返回 `false`。
* `callback` 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。
* 如果一个`thisArg`参数提供给some()，它将被用作调用的 `callback`的 `this` 值。否则， 它的 `this` value将是 `undefined`。
* `some()` 被调用时不会改变数组
* `some()` 遍历的元素的范围在第一次调用 `callback`. 前就已经确定了。
* 在调用 `some()` 后被添加到数组中的值不会被 `callback` 访问到。
* 如果数组中存在且还未被访问到的元素被 `callback` 改变了，则其传递给 `callback` 的值是 `some()` 访问到它那一刻的值。已经被删除的元素不会被访问到

**重写**

```javascript
Array.prototype.mySome = function(callback) {
  let _arr = this,
      thisArg = arguments[1] || window,
      flag = false;
  
  for (let i=0; i<_arr.length; i++) {
    if (callback.call(thisArg, _arr[i], i, _arr)) {
      return true
    }
  }
  return flag;
}
```



**实例**

1.判断数组中是否存在某个值

```javascript
var fruits = ['apple', 'banana', 'mango', 'guava'];

function checkAvaliability(arr, val) {
  return arr.some((item) => item === val)
}
```

2.将任意值转换为布尔类型

```javascript
let TRUTHY_VALUES = [true, 'true', 1];

function getBoolean(value) {
 	'use strict'
  if (typeof value === 'string') {
    value = value.toLowerCase().trim();
  }
  return TRUTHY_VALUES.some(item => t === value)
}
getBoolean(false);   // false
getBoolean('false'); // false
getBoolean(1);       // true
getBoolean('true');  // true
```





#### every

**定义**

`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

若收到一个空数组，此方法在一切情况下都会返回 `true`

```javascript
[].every(()=>{})  //true
```

**参数**

```javascript
arr.every(callback(element[, index[, array]])[, thisArg])
```

`callback` 用来测试每个元素的函数，它可以接收三个参数

* `element` 用于测试的当前值
* `index` **可选** 用于测试的当前值的索引
* `array` **可选** 调用 `every` 的当前数组

`thisArg` **可选**

* 执行 `callback` 时使用的 `this` 值

我们来看一下传递的这个this值

```javascript
//箭头函数形式+非严格模式下 这个值是window
[].every(() => console.log(this), 1); //在Chrome中打印的是window对象

[].every(function() {console.log(this)}, 1); // Number {1} 包装类
```





**返回值**

* 如果回调函数的每一次返回都为 [truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 值，返回 `**true**` ，否则返回 `**false**`
* 如果是<span style="color:blue;">**空数组**</span>调用, 函数即使有内容也返回`true`



**描述**

* `every` 方法为数组中的每个元素执行一次 `callback` 函数，直到它找到一个会使 `callback` 返回 [falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy) 的元素。如果发现了一个这样的元素，`every` 方法将会立即返回 `false`。否则，`callback` 为每一个元素返回 `true`，`every` 就会返回 `true`。`callback` 只会为那些已经被赋值的索引调用。不会为那些被删除或从未被赋值的索引调用。
* 如果为 `every` 提供一个 `thisArg` 参数，则该参数为调用 `callback` 时的 `this` 值。如果省略该参数，则 `callback` 被调用时的 `this` 值，在非严格模式下为全局对象，在严格模式下传入 `undefined`。
* `every` 遍历的元素范围在第一次调用 `callback` 之前就已确定了。在调用 `every` 之后添加到数组中的元素不会被 `callback` 访问到。如果数组中存在的元素被更改，则他们传入 `callback` 的值是 `every` 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。
* `every` 和数学中的"所有"类似，当所有的元素都符合条件才会返回`true`。正因如此，若传入一个空数组，无论如何都会返回 `true`。（这种情况属于[无条件正确](http://en.wikipedia.org/wiki/Vacuous_truth)：正因为一个[空集合](https://en.wikipedia.org/wiki/Empty_set#Properties)没有元素，所以它其中的所有元素都符合给定的条件。)!!!!????

**重写**

```javascript
Array.prototype.myEvery = function(callback) {
  let _arr = this,
      thisArg = arguments[1] || window,
      flag = true;
  
  for (let i=0; i<_arr.length; i++) {
    if (!callback(thisArg, _arr[i], i, _arr)) {
      return false;
    }
  }
  
  return flag;
}
```



**实例**

**Polyfill**

```javascript
//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every

```



#### ES6-find()/findIndex()

##### 概况

在ECMAScript 5以前的版本中，由于没有内建的数组搜索方法，因此想在数组中查找元素会比较麻烦，于是ECMAScript 5正式添加了indexOf()和lastIndexOf()两个方法，可以用它们在数组中查找特定的值。

这两种方法仍有局限之处，即每次只能查找一个值，如果想在一系列数字中查找第一个偶数，则必须自己编写代码来实现。于是ECMAScript 6引入了find()方法和findIndex()方法来解决这个问题。

##### 参数

find()方法和findIndex()方法都接受<u>两个参数：一个是回调函数；另一个是可选参数，用于指定回调函数中this的值。</u>

执行回调函数时，传入的参数分别为：数组中的某个元素和该元素在数组中的索引及数组本身，与传入map()和forEach()方法的参数相同。

##### 返回值

如果给定的值满足定义的标准，回调函数应返回true，一旦回调函数返回true，find()方法和findIndex()方法都会立即停止搜索数组剩余的部分。



find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined

```js
const array1 = [1,2,3,4,5];
const found = array1.find(item=>item>3);
console.log(found); //4

```



findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。

```js
const array1 = [5, 12, 8, 130, 44];

const isLargeNumber = (element) => element > 13;

console.log(array1.findIndex(isLargeNumber));
// expected output: 3
```

**重写**

```javascript
Array.prototype.myFind = function(callback) {
  let _arr = this,
      thisArg = arguments[1] || globalThis;
  
  for (let i=0; i<_arr.length; i++){
    if (callback.call(thisArg, _arr[i], i, _arr)) {
      return _arr[i]
    }
  }
  return undefined;
}
```







#### ES6-fill()

**定义**

`**fill()**` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

**参数**

```javascript
arr.fill(value[, start[, end]])
```

`value` 用来填充数组元素的值

`start` **可选**  起始索引，默认值为0。

`end`   **可选**      终止索引，默认值为 `this.length`

**返回值**

修改后的数组

**描述**

* **`fill`** 方法接受三个参数 `value`, `start` 以及 `end`. `start` 和 `end` 参数是可选的, 其默认值分别为 `0` 和 `this` 对象的 `length `属性值。
* 如果 `start` 是个负数, 则开始索引会被自动计算成为 `length+start`, 其中 `length` 是 `this` 对象的 `length `属性值。如果 `end` 是个负数, 则结束索引会被自动计算成为 `length+end`。
* **`fill`** 方法故意被设计成通用方法, 该方法不要求 `this` 是数组对象
* **`fill`** 方法是个可变方法, 它会改变调用它的 `this` 对象本身, 然后返回它, 而并不是返回一个副本
* 当一个对象被传递给 **`fill`**方法的时候, 填充数组的是这个对象的引用



**实例**

```javascript
[1, 2, 3].fill(4);               // [4, 4, 4]
[1, 2, 3].fill(4, 1);            // [1, 4, 4]
[1, 2, 3].fill(4, 1, 2);         // [1, 4, 3]
[1, 2, 3].fill(4, 1, 1);         // [1, 2, 3]
[1, 2, 3].fill(4, 3, 3);         // [1, 2, 3]
[1, 2, 3].fill(4, -3, -2);       // [4, 2, 3]
[1, 2, 3].fill(4, NaN, NaN);     // [1, 2, 3]
[1, 2, 3].fill(4, 3, 5);         // [1, 2, 3]
Array(3).fill(4);                // [4, 4, 4]
[].fill.call({ length: 3 }, 4);  // {0: 4, 1: 4, 2: 4, length: 3}

// Objects by reference.  !!!!
var arr = Array(3).fill({}) // [{}, {}, {}];
// 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型
// 如 arr[0] === arr[1] 为true
arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
```

**Polyfill**

```javascript
//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
```



#### ES6-copyWithin()
> https://www.zhangxinxu.com/wordpress/2022/12/js-array-copywithin/

##### 是什么
copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。

##### 语法
```js
copyWithin(target)
copyWithin(target, start)
copyWithin(target, start, end)
```

表示复制start-end的内容，并从target开始替换。

**参数**
`target`
0为基底的索引,复制序列(sequence)到该位置, 会转换成一个整数:
* 负索引从数组末尾往回计数, 如果`target < 0`, 使用`traget + array.length`
* 如果`target < -array.length`, 使用0
* 如果`target >= array.length`, 不复制任何数据
* 如果`target`在`start`之后, 复制的序列将被修改以符合`arr.length`

`start` 可选
开始复制元素的以0位基底的索引, 转换成数字:
* 负索引会从数组末尾往回计数, 如果`start < 0`, 使用`start + array.length`
* 如果`start < -array.length` 或 `start`被忽略, 则使用0
* 如果 `start >= array.length`, 不复制任何数据

`end` 可选
0为基底的索引, 在该索引处结束复制元素, 转换成数字.copyWithin（）复制到但不包括结尾。
* 负索引会数组末尾往回计数, 如果`end < 0`, 则`end + array.length`
* 如果 `end < -array.length`, 则使用0
* 如果 `end >= array.length` 或 `end` 被忽略, 使用`array.length`, 会使直到末尾的所有元素被复制.
* 如果`end` 在规范化(?)之后的start之前或它的位置, 则不复制任何内容


**返回值**
更改后的数组

##### 描述









copyWithin()方法与fill()方法相似，其也可以同时改变数组中的多个元素。fill()方法是将数组元素赋值为一个指定的值，而copyWithin()方法则是从数组中复制元素的值。调用copyWithin()方法时需要传入两个参数：一个是该方法开始填充值的索引位置，另一个是开始复制值的索引位置。

```javascript
//复制数组前两个元素到后两个元素
let numbers = [1,2,3,4];
//从数组e索引2开始黏贴值 从数组的索引0开始复制值

number.copyWith(2, 0);

console.log(numbers.toString()); //1,2,1,2
```

这段代码从numbers的索引2开始粘贴值，所以索引2和3将被重写。给copyWithin()传入第二个参数0表示，从索引0开始复制值并持续到没有更多可复制的值。

默认情况下，copyWithin()会一直复制直到数组末尾的值，但是你可以提供可选的第三个参数来限制被重写元素的数量。第三个参数是不包含结束索引，用于指定停止复制值的位置。在代码中它是这样的：

```javascript
let numbers = [1,2,3,4];

//从数组的索引2开始粘贴值
//从数组的索引0开始复制值
//当位于索引1时停止复制值

numbers.copyWith(2,0,1);

console.log(numbers.toString()); //1,2,1,4
```

**copywith() 对比 slice()**
JavaScript中数组的copyWithin()和slice()方法作用都是复制数组，且都是浅复制。
区别一:
copyWithin()是将数组中的一部分复制并替换另外一部分，总长度是不变的，而slice()方法只复制，不替换，返回的数组长度是由复制的数组项目个数决定的.
```js
arr = [1, 'A', '甲', 'I'];
console.log(arr.copyWithin(2, 3));
// 结果是： [1, 'A', 'I', 'I']


arr = [1, 'A', '甲', 'I'];
console.log(arr.slice(2, 3));
// 结果是： ['甲']

```

区别二:
copyWithin()方法会改变原始的数组，而slice()方法并不会

区别三:
slice()复制对于字符串也是有效的，但是copyWithin()方法却不支持
```js
// 返回值是'angx'
('zhangxinxu').slice(2, 6)

// 会无情报错
('zhangxinxu').copyWithin(2, 6)
```

**实际应用**





#### ES6-includes()

**定义**

`**includes()**` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。

**参数**

```javascript
arr.includes(valuefToFind[, fromIndex])
```

`valueToFind` 需要查找的元素值

* 使用 `includes()`比较字符串和字符时是区分大小写的

`fromIndex` **可选**

* 从`fromIndex` 索引处开始查找 `valueToFind`。
* 如果为负值，则按升序从 `array.length + fromIndex` 的索引开始搜 （即使从末尾开始往前跳 `fromIndex` 的绝对值个索引，然后往后搜寻）。默认为 0。

**返回值**

* 返回一个布尔值 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) 。
* 如果在数组中（或 `fromIndex` 指定的范围中）找到了 `valueToFind`，则返回 `true`，否则返回 `false`。
* 0 的值将全部视为相等，与符号无关（即 -0 与 0 和 +0 相等），但 `false` 不被认为与 0 相等; `NaN`与自身返回的是true.
* 技术上来讲，`includes()` 使用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#%E9%9B%B6%E5%80%BC%E7%9B%B8%E7%AD%89'>`零值相等`</a> 算法来确定是否找到给定的元素

> 零值相等: 和同值相等类似,不过会人为`+0`和`-0`相等
>
> 同值相等: 由`Object.is`方法提供



**实例**

```javascript
NaN == NaN; //false
Object.is(NaN, NaN); //true

0 == -0 //true
Object.is(0, -0); //false

0 == undefined //false
0 == null //false


[NaN].includes(NaN); //true
[NaN].indexOf(NaN); //-1

[-0].includes(0); //true
[-0].indexOf(0); //0
```



#### ES6-flat()

**定义**

`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

**参数**

```javascript
var newArray = arr.flat([depth])
```

`depth` **可选**

* 指定要提取嵌套数组的结构深度，默认值为 1
* 使用 Infinity，可展开任意深度的嵌套数组

**返回值**

* 一个包含将数组与子数组中所有元素的新数组

* `flat()` 方法会移除数组中的空项

**实例**

[扁平化嵌套数组](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#扁平化嵌套数组)

```javascript
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

[扁平化与数组空项](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#扁平化与数组空项)

```javascript
var arr4 = [1, 2, , 4, 5];
arr4.flat();
// [1, 2, 4, 5]
```

替代方案

[使用 `reduce` 与 `concat`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#使用_reduce_与_concat)

```javascript
var arr = [1, 2, [3, 4]]

// 展开一层数组
arr.flat();
// 等效于
arr.reduce((acc, val) => acc.concat(val), []);
// [1, 2, 3, 4]

// 使用扩展运算符 ...
const flattened = arr => [].concat(...arr)
```

[reduce + concat + isArray + recursivity](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#reduce_concat_isarray_recursivity)

```javascript
// 使用 reduce、concat 和递归展开无限多层嵌套的数组
var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];

function flatDepth(arr) {
  return arr.reduce((acc, cur) => {
    if (Array.is(cur)) {
      return acc.concat(flatDepth(cur))
    } else {
      return acc.concat(...cur)
    }
  }, [])
}


//MDN

```

##### **方法实现**

> https://juejin.cn/post/6844904025993773063#heading-14
>
> 写的非常好,读起来很流畅,思路清晰. 抄一遍

Array.prototype.flat()特点:

* 用于将数组'拉平',变为一维数组.该方法返回一个新数组,对原数据没有影响
* 不传参时,默认'拉平'一层; 可以传入一个整数,标识想要'拉平'的层数.
* 传入`<=0`的整数数组将返回原数组,不'拉平'
* `Infinity`关键字作为参数时,无论多少层嵌套,都会转为一维数组.
* 如果原数组有空位, 此方法会跳过空位

1.实现思路（简洁顺畅，要的就是这个感觉）

在数组中找到是数组类型的元素,然后将它们展开.

* 第一个要解决的就是遍历数组元素
* 第二个要解决的是判断元素是否为数组
* 第三个要解决的将数组的元素展开一层

2.遍历数组的方案

包括不限于下面几种:

* for循环
* for...of 
* for...in
* forEach()
* entries()
* values()
* keys()
* reduce()
* map()

3.判断元素是否为数组的方案 <span style="color:red;">**7**</span> 种

* [] instanceof Array
* [].\_\_proto\_\_ === Array.prototype
* [].constructor === Array
* Array.prototype.isPrototypeOf([])
* Object.getPrototypeOf([]) === Array.prototype
* Object.prototype.toString.call([]).slice(8, -1)
* Array.isArray([])

说明:

* `instanceof` 操作符是假定只有一种全局环境,如果网页中包含多个框架,多个全局环境,如果你从一个框架向另一个框架传入一个数组,那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数.(所以在这种情况下不准确)
* typeof 操作符对数组类型返回object

4.将数组元素展开一层的方法

* 扩展运算符 + concat
* concat+apply
* toString + split

扩展运算符+concat

concat()方法用来合并两个或多个数组,在拼接过程中加上扩展运算符会展开一层数组.

concat+apply

主要是利用apply在绑定作用域时,传入的第二个参数是一个数组或类数组对象,其中的数组元素将作为单独的参数传给函数. 也就是在调用apply函数的过程中,会将传入的数组一个个传入到要执行的函数中,相当对数组进行了一层展开.

toString+split

如果数组中的元素都是数字的话,是可行的.但是不推荐,因为操作字符串是危险的.

```javascript
const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }];

//1 其实这里加不加扩展运算符都是可以 都会展开最外一层
[].concat(...arr)

//2
[].concat.apply([], arr)

//3
arr.toString().split(',')
arr.toString().split(',').map(v => parseInt(v));
```

准备工作都已经完成,第一版flat方法实现:

```javascript
//concat + 递归

const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }];

function flat(arr) {
  let res = [];
  arr.forEach(item => {
    if (Array.isArray(item)) {
      res = res.concat(arguments.callee(item)); //递归
      //或使用扩展运算符
      //res.push(...arguments.callee(item))
    } else {
      res.push(item);
    }
  });
  return res;
}
```



```javascript
//用reduce实现flat函数

const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }]

const flat = arr => {
  return arr.reduce((acc, crt) => {
    return acc.concat(Array.isArray(crt) ? flat(crt) : crt)
  }, [])
};

// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];
```



```javascript
//用栈的思想实现flat函数

function flat(arr) {
  let res = [];
  let stack = [].concat(arr); //将数组元素拷贝至栈,直接赋值会改变原数组
  //如果栈不为空,则循环遍历
  while (stack.length !== 0) {
    const val = stack.pop();
    if (Array.isArray(val)) {
      stack.push(...val); //如果是数组再次入栈,并且展开了一层
    } else {
      res.unshift(val); //如果不是数组就将其取出来放入结果数组
    }
  }
  return res;
}
```



```javascript
//通过传入整数参数控制拉平层数 !!!!
function flat(arr, num=1) {
 return num > 0
  ? arr.reduce((pre, cur) => {
   pre.concat(Array.isArray(cur) ? flat(cur, num-1) : cur)
 }, [])
  : arr.slice();
}
```



```javascript
//使用Generator 实现 flat

function* flat(arr,num) {
  if (num === undefined) num = 1;
  for (const item of arr) {
    if (Array.isArray(item) && num > 0) {
      yield* flat(item, num-1);
    } else {
      yield item;
    }
  }
}

// 调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。
// 也就是遍历器对象（Iterator Object）。所以我们要用一次扩展运算符得到结果
[...flat(arr, Infinity)]    
// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];

作者：弹铁蛋同学
链接：https://juejin.cn/post/6844904025993773063
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```javascript
//在原型链上重写 flat 函数
Array.prototype.flat = function(num=1) {
  if (!Number(num) || Number(num) < 0) {
    return this;
  }
  let arr = this.concat(); 
  while(num > 0) {
    if (arr.some(x => Array.isArray(x))) {
      arr = [].concat.apply([], arr);
    } else {
      break; //数组中没有数组元素并且不管num是否依旧大于0, 停止循环
    }
    num--;
  }
  return arr;
}
```



```javascript
//考虑数组空位的情况
// flat 函数执行是会跳过空位的。ES5 大多数数组方法对空位的处理都会选择跳过空位包括：forEach(), filter(), reduce(), every() 和 some() 都会跳过空位。

//reduce+递归
function flat(num=1) {
  if (!Number(num) || Num(num)<0) {
    return this;
  }
  let arr = [].concat(this);
  return num > 0
  	? arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? cur.flat(--num): cur),[])
  	: arr.slice();
}
const arr = [1,[3,4],,,];
arr.flat(); //[1,3,4]


//forEach+递归
function flat(num=1) {
  if (!Number(num) || Number(num) < 0) {
    return this;
  }
  let arr = [];
  this.forEach(item => {
    if (Array.isArray(item)) {
      arr = arr.concat(item.flat(--num));
    } else {
      arr.push(item);
    }
  });
  return arr;
};


```

扩展阅读: **由于空位的处理规则非常不统一，所以建议避免出现空位。** 见数组中的相关知识点.

```javascript
//concat + 递归

const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }];

function myFlat(arr) {
  if (!Array.isArray(arr)) {
    return alert('参数需要是一个数组');
  }
  
  let newArr = [];
  arr.forEach(v => {
    if (Array.isArray(v)) {
      newArr = newArr.concat(myFlat(v));
    } else {
      newArr.push(v);
    }
  })
  
  return newArr;
}
```







#### ES6-keys()

**定义**

 `**keys()** `方法返回一个包含数组中每个索引键的`**Array Iterator**`对象

**参数**

```javascript
arr.keys()
```

**返回值**

一个新的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 迭代器对象

**实例**!!!!

[索引迭代器会包含那些没有对应元素的索引](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys#索引迭代器会包含那些没有对应元素的索引)

```javascript
var arr = ["a", , "c"];
var sparseKeys = Object.keys(arr);
var denseKeys = [...arr.keys()];
console.log(sparseKeys); // ['0', '2']
console.log(denseKeys);  // [0, 1, 2]
```

**其他**

这里要注意是的是和对象Object.keys()方法的比较,对象的方法返回的是一个数组.



#### ES6-values()

**定义**

**`values()`** 方法返回一个新的 **`Array Iterator`** 对象，该对象包含数组每个索引的值

**参数**

```javascript
arr.values()
```

**返回值**

一个新的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 迭代对象

**描述**

* **Array.prototype.values** 是 **Array.prototype[Symbol.iterator]** 的默认实现。
* 一次性：数组迭代器是一次性的，或者说临时对象

**实例**

[使用 `for...of` 循环进行迭代](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values#使用_for...of_循环进行迭代)

```javascript
let arr = ['w', 'y', 'k', 'o', 'p'];
let eArr = arr.values();

for (let letter of eArr) {
  console.log(letter);
} //"w" "y "k" "o" "p"
```

[使用 `.next()` 迭代](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values#使用_.next_迭代)

```javascript
var arr = ['a', 'b', 'c', 'd', 'e'];
var iterator = arr.values();
iterator.next();               // Object { value: "a", done: false }
iterator.next().value;         // "b"
iterator.next()["value"];      // "c"
iterator.next();               // Object { value: "d", done: false }
iterator.next();               // Object { value: "e", done: false }
iterator.next();               // Object { value: undefined, done: true }
iterator.next().value;         // undefined
```

一次性：数组迭代器是一次性的，或者说临时对象

```javascript
var arr = ['a', 'b', 'c', 'd', 'e'];
 var iterator = arr.values();
 for (let letter of iterator) {
 console.log(letter);
} //"a" "b" "c" "d"
for (let letter of iterator) {
console.log(letter);
} // undefined
```



#### ES6-entries()

**定义**

`entries()` 方法返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对

**参数**

```javascript
arr.entries()
```

**返回值**

一个新的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 迭代器对象。[Array Iterator](https://www.ecma-international.org/ecma-262/6.0/#sec-createarrayiterator)是对象，它的原型（__proto__:Array Iterator）上有一个[next](https://www.ecma-international.org/ecma-262/6.0/#sec-%arrayiteratorprototype%.next)方法，可用用于遍历迭代器取得原数组的[key,value]。



**实例**

1.Array.iterator

```javascript
var arr = ["a", "b", "c"];
var iterator = arr.entries();
console.log(iterator);

/*Array Iterator {}
         __proto__:Array Iterator
         next:ƒ next()
         Symbol(Symbol.toStringTag):"Array Iterator"
         __proto__:Object
*/
```

2.iterator.next()

```javascript
var arr = ["a", "b", "c"];
var iterator = arr.entries();
console.log(iterator.next());

/*{value: Array(2), done: false}
          done:false
          value:(2) [0, "a"]
           __proto__: Object
*/
// iterator.next()返回一个对象，对于有元素的数组，
// 是next{ value: Array(2), done: false }；
// next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是false，
// 直到迭代器结束done才是true。
// next.value是一个["key","value"]的数组，是返回的迭代器中的元素值。
```

3.iterator.next方法运行

```javascript
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries
```

4.二维数组按行排序

```javascript
var arr = [[1, 34], [456, 2, 3, 44, 234], [4567, 1, 4, 5, 6], [34, 78, 23, 1]]


//entries
function sortArr(arr) {
    var goNext = true;
    var entries = arr.entries();
    while (goNext) {
        var result = entries.next();
        if (result.done !== true) {
            result.value[1].sort((a, b) => a - b);
            goNext = true;
        } else {
            goNext = false;
        }
    }
    return arr;
}

sortArr(arr);

/*(4) [Array(2), Array(5), Array(5), Array(4)]
    0:(2) [1, 34]
    1:(5) [2, 3, 44, 234, 456]
    2:(5) [1, 4, 5, 6, 4567]
    3:(4) [1, 23, 34, 78]
    length:4
    __proto__:Array(0)
*/



//reduce
let result = arr.reduce((acc, cur) => {
  acc.push(cur.sort((a, b) => a - b))
  return acc;
 }, [])
```

5.使用for...of循环

```javascript
var arr = ["a", "b", "c"];
var iterator = arr.entries();
// undefined

for (let e of iterator) {
    console.log(e);
}

// [0, "a"]
// [1, "b"]
// [2, "c"]
```



#### ES2022-at()



