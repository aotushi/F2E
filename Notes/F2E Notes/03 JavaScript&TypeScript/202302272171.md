---
aliases: sort, Array.prototype.sort
---

### Array.prototype.sort


#### **定义**

`sort()`方法用[原地算法](https://en.wikipedia.org/wiki/In-place_algorithm)对数组的元素进行排序，并返回数组的引用。默认排序是升序, 创建在转换元素为字符串,并比较它们UTF-16代码单元值序列的基础上.

可以用来对一个数组进行排序,它是一个**破坏性的方法**..调用后,原数组的顺序就会被改变.

可以通过传递一个 回调函数 来自定义排序规则

#### **参数**

```javascript
arr.sort([compareFunction])
```

`compareFunction` 可选

* 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的<u>Unicode位点</u>进行排序。([字符编码笔记:ASCII, Unicode和UTF-8](https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html))
* `firstEl` 第一个用于比较的元素。
* `secondEl` 第二个用于比较的元素

#### **返回值**

排序后的数组。请注意，数组已原地排序，并且不进行复制。

#### **描述**

* 如果没有指明`compareFn`, 那么元素会按照转换为字符串的诸个字符的Unicode位点进行排序.
  * 例如: 'Banana'排在'cherry'之前. 数字9排在80之后.
  
* 所有`Undefined`元素会被排在数组的末尾
  
* 如果指明了 `compareFunction` ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素(所有`undefined`元素被排在数组末尾, 没有调用`compareFn`)

| `compareFn(a, b)` return value | sort order      |
| ------------------------------ | --------------- |
| > 0                            | `a` 在 `b` 之后 |
| < 0                            | `a` 在 `b`之前  |
| === 0                          | 保持原来的顺序  |



```javascript
//比较函数格式:
function compare(a, b) {
  if (a < b ) {           // 按某种排序标准进行比较, a 小于 b
    return -1;
  }
  if (a > b ) {
    return 1;
  }
  // a must be equal to b
  return 0;
}
```


* 更正式,比较函数被期望具有以下属性,为了确保更好的排序行为:
* *Pure*: 比较器不会改变被比较的对象或任何外部状态(这很重要,因为不能保证比较函数在什么时候什么方式被调用,所以任何特定的调用将不会产生可见的影响对外部)
* *Stable*: 比较器根据相同的输入对返回相同的结果
* *Anti-symmetric*(反对称): `compareFn(a,b)` 和 `compareFn(b,a)` 必须都是0或有相反的符号.
* *Transitive*: 如果`compareFn(a,b)`和`compareFn(b,c)`都是整数,0或负数, 那么`compareFn(a,b)`像前两者具有相同的正值.



要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列(如果不包含`Infinity`和`NaN`.



```javascript
- 如果希望 升序 排列(从小到大),传:
function(a, b){
  return a - b;  //记忆方法: 26个字符从a到z是从小到大, a - b理解为从小到大,是升序. b -a是从大到小
}

- 如果希望降序排列(从大到小),传:
function(a, b){
  return b - a;
}

- 乱序排列
function(a, b){ //参数a与b写不写都一样了
  return Math.random() - Math.random
}
() => Math.random() - 0.5;

//没有传递参数的写法
[1,3,2,5,4].sort(() => -1); //[4, 5, 2, 3, 1]
[1,3,2,5,4].sort(() => 1); //[1,3,2,5,4]
[1,3,2,5,4].sort(() => 0); //[1,3,2,5,4]
```





#### **为什么升序是a - b????**  

```javascript
//https://blog.csdn.net/weixin_42207975/article/details/107538527
// 是结果推原因, 怎么说呢, 总是记不住.
let arr = [1, 22, 15, 32, 4, 5];
arr.sort((a, b) => a - b); //升序排列 [1, 4, 5, 15, 22, 32]
arr.sort((a, b) => b - a); //降序排列 [...]

```

回调函数的格式为（a,b）=> { return xxx }，ab为数组中任意两个数:

* 当返回值大于0, a放在b的后面
* 当返回值小于0, a放在b的前面
* 当返回值等于0, 位置不变

```javascript
当 a>b 时，

a - b > 0  ，排序结果 ===> b，a （升序）

b - a < 0  ，排序结果 ===> a，b （降序）

当 b>a 时，

a - b < 0  ，排序结果 ===> a，b （升序）

b - a > 0  ，排序结果 ===> b，a （降序）

当 a=b 时，

a - b = b - a =0 , 排序结果 ===> 保持不变
```

`结论`: 无论a>b还是b>a，return a-b 总能得到升序的结果，而 return b-a 总能得到降序的结果. 另外，return a-b / return b - a 只是一种在理解的基础上简便的写法。复杂的写法就是使用上面的'比较函数的格式'.



#### [[202302272171b|重写sort]]



#### [[202302272171c|sort实例]]
