---
alias: 数组
---


## 数组
>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#description


### 概述

* 数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。
* JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式。一般来说，数组的这些特性会给使用带来方便，但如果这些特性不适用于你的特定使用场景的话，可以考虑使用类型数组 [`TypedArray`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)。

* 只能用整数作为数组元素的索引，而不能用字符串。后者称为 [关联数组](https://en.wikipedia.org/wiki/Associative_array)。使用非整数并通过 [方括号](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#对象和属性) 或 [点号](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors) 来访问或设置数组元素时，所操作的并不是数组列表中的元素，而是数组对象的 [属性集合](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#属性) 上的变量。

* ==数组对象的属性和数组元素列表是分开存储的，并且数组的遍历和修改操作也不能作用于这些命名属性。==
* JS数组是可扩展的且可包含不同[[202301170824|数据类型]]的混合(当这些特征是不合需要的, 使用类型数组代替)
* JS数组不是[[202304101041|关联数组]]等,数组元素不能通过使用作为索引的任意字符串来访问,必须通过使用非负整数(或它们各自的字符串形式)的索引来访问.
* JS数组是零索引(zero-indexed): 数组第一个元素在索引0,以此类推,最后一个元素在数组length属性减1的位置.
* JS**数组拷贝操作**创建的是浅拷贝(shallow copies)(所有标准内建的拷贝操作)





### 特点

* 数组是值的有序集合,其中的值叫做*元素*,每个元素有一个数值表示的位置,叫做*索引*.
* JS数组是无类型限制的,即数组中的元素可以是任意类型
* JS数组是基于零且使用32位数值索引的,第一个元素的索引是0,最大可能的索引是 `4 294 967 294 (2**32 - 2)`,即数组最大包含`4 294 967 295(2**32`个元素. 
* JS数组是动态的,按需增大或缩小,无需再大小变化时重新为它们分配内存空间
* JS数组可以是稀疏的,即元素不一定具有连续的索引,中间也可能有间隙.
* 每个JS数组都有一个length属性. 
  * 对稀疏数组, length大于所有元素的最高索引
  * 对非稀疏数组, length属性保存数组中元素的个数
* ES6新增定型数组(typed array).具有固定的长度和固定的元素类型.其具有极高性能,支持对二进制数据的字节级访问. ????


### 数组索引
* 数组对象不能使用任意字符串作为元素索引(如关联数组中)但必须使用非负整数(或它们各自字符串形式).
* 通过非整数设置或访问将不会设置或检索数组列表自身的元素,将会设置或访问一个与**数组的对象属性集合(object property collection)**相关的一个变量.
* 数组的**对象属性**和数组**元素列表**是分离的,并且数组的==遍历和更新==操作不能应用到命名的属性上.
* 按下面方式尝试访问数组元素会抛出语法错误.因为属性名称是不合法的.  `console.log(arr.0) //a syntax error`
* JS语法要求使用括号标识代替点标识来访问属性.也可以引用数组索引（例如，年份`['2']`而不是年份`[2]`），尽管通常不是必需的。
* `year[2]`中的2会通过JS引擎的隐式`toString`转换强制转换为字符串. 作为结果`2`和`02`在`year`对象上将引用不同的插槽.
* 只有`year[2]`是真正的数组索引,`year[02]`是一个在数组迭代中不会被访问的任意字符串属性



### 长度和数字属性关系

当设置一个合法的数组索引属性,且这个属性在数组边界之外,JS引擎将更新数组的`length`属性

```js
const fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3


fruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6


//Increasing the length.
fruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6


//Decreasing the length property does, however, delete elements.
fruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2
```



### 数组方法和空插槽

[[202304101356|稀疏数组]](sparse array)中的空插槽行为在数组之间是不一致的. 
通常来说,较老的方法将跳过空插槽,而新的方法将插槽作为`undefined`.

在遍历多个元素的方法之中,以下方法在访问索引之前会执行`in`检查,并且不会用`undefined`合并空插槽.

- [`concat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)
- [`copyWithin()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)
- [`every()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every)
- [`filter()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
- [`flat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
- [`flatMap()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)
- [`forEach()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
- [`indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
- [`lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
- [`map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [`reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
- [`reduceRight()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight)
- [`reverse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
- [`slice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)
- [`some()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
- [`sort()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
- [`splice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)


如下方法对空插槽就像它们是`undefined`一样.
- [`entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)
- [`fill()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)
- [`find()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
- [`findIndex()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)
- [`findLast()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast)
- [`findLastIndex()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex)
- [`group()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/group) Experimental
- [`groupToMap()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/groupToMap) Experimental
- [`includes()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)
- [`join()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join)
- [`keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)
- [`toLocaleString()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString)
- [`values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values)

### 复制方法和变更方法
一些方法调用时不会更改存在的谁说,相反会返回一个新数组.首先通过构造一个新数组并填充元素. 复制总是发生在浅层(浅拷贝), 这些方法永远不会拷贝初始化数组之外的任何东西.原始数组的元素(Elements)拷贝进新数组.通过区分对象数据和原始数据两种形式进行分别拷贝.

以下方法通过访问`this.constructor[Symbol.species]`来确定使用的构造函数来创建数组:
- [`concat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)
- [`filter()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
- [`flat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
- [`flatMap()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)
- [`map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [`slice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)
- [`splice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) (to construct the array of removed elements that's returned)

下面的方法总是用基于`Array`构造函数创建新数组:
- [`toReversed()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed)
- [`toSorted()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted)
- [`toSpliced()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced)
- [`with()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/with)


以下表格列举了更改原始数组的方法,和对应的不更改数组的方法.
| 更改的方法     | 对应的非更改的方法 |
| -------------- | ------------------ |
| copyWith()     | 无                 |
| fill()         | 无                 |
| pop()          | slice(0,-1)        |
| push(v1,v2)    | concat(v1,v2)      |
| reverse()      | toReversed()       |
| shift()        | slice(1)           |
| sort()         | toSorted()         |
| splice()       | toSpliced()        |
| unshift(v1,v2) | toSpliced(v1,v2)   |

将一个改变的方法转换为可选的非改变方法的简单方式是使用[[202301171524|扩展运算符]]或slice()来首先创建一个拷贝.



### 迭代的方法
很多数组的方法那一个回调函数当做一个参数. 这个回调函数按顺序调用并为数组中每个元素最多调用一次,回调函数的返回值用来确定方法的返回值.它们共用相同的共识:
```js
method(callbackFn, thisArg)
```

`callbackFn`拥有3个参数:
* element 数组中正在处理的当前元素
* index   数组中正在处理的当前元素的索引
* array   调用该方法的数组

`callbackFn`预计的返回值依赖于被调用的数组方法.
当调用`callbackFn`时,`thisArg`参数(默认是`undefined`)将被用作`this`值.
`callbackFn`最终观察到的`this`值根据通常的规则(this 缺)来决定:
如果`callbackFn`是non-strict:
* 原始this值会被包装成对象
* `undefined/null`会被globalThis(缺了)替换
* `thisArg`与任何使用箭头函数定义的`callbackFn`无关,因为箭头函数没有自己的this绑定

所有的iterative 方法都是复制方法和原生方法,尽管它们对空插槽的行为不同.

以下是可迭代方法:
- [`every()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every)
- [`filter()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
- [`find()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
- [`findIndex()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)
- [`findLast()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast)
- [`findLastIndex()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex)
- [`flatMap()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)
- [`forEach()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
- [`group()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/group)
- [`groupToMap()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/groupToMap)
- [`map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [`some()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)

值得一提的是, every/some/find/finedIndex/finedLast/findLastIndex不总是在每个元素上调用`callbackFn`,一旦返回值确定它们会停止迭代.
reduce/reduceRight和通常迭代方法不同,它们不接受thisArg
sort方法也接受一个回调函数,但是它不是一个可迭代方法.



### 原生数组方法
数组方法总是原生的,它们不能访问数组对象的任意内部数据. 它们只能通过`length`属性和索引元素(也就是索引)访问数组元素. 这意味着数组方法在类数组对象也同样可以被调用.


### length属性规范化

`length`属性转换成整数然后限制其范围在0到2<sup>53</sup>-1. 
`NaN`变成0, 所以即使length属性不存在或为undefined, 它表现的就像它的值为0一样.
JS避免设置length属性为一个[不安全的整数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER).
如果长度设为大于2<sup>53</sup>-1的数字,所有内建的方法将抛出一个[[202301302098a2|TypeError]].
然而,因为数组的length属性如果被设置为大于2<sup>32</sup>会抛出一个错误,安全整数的阈值通常不会达到,除非在一个非数组对象中调用这个方法.

```js
Array.prototype.flat.call({}) //[]
```

一些数组方法设置数组对象的length属性. 它们通常在规范化之后设置这个值,所以length通常以一个整数结束.  ???
```js
const a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0
```






### 类数组(array-like)对象



### 问题

#### JS中关联数组和索引数组的区别
**内部数据类型不同**
关联数组内部使用键/值对来存储数据，其中“键”是一个字符串或者数字，而“值”可以是任何 JavaScript 数据类型。数组则是使用数字作为索引来存储数据，它们不需要明确的“键”和“值”类型。

**遍历方式不同**
关联数组可以使用 for-in 循环遍历，因为它的键都是字符串或者数字。而数组则通常使用 for 或者 forEach 循环遍历。

**数组具有内置方法**
在 JavaScript 中，数组具有大量的内置方法（如 push、pop、splice、shift 等），这些方法可以方便地对数组进行操作。关联数组则没有这些内置方法，但是可以通过 JavaScript 对象方法（如 Object.keys、Object.values、Object.entries 等）来实现一些类似的操作。

**存储方式不同**
关联数组使用具有唯一身份的“键”来存储数据，这些键可以是字符串或者数字，并且用于访问和修改存储在数组中的“值”。而数组则是使用数字索引来存储和访问数组中的元素。也就是说，关联数组可以视为对象的特殊形式，而通常的 JavaScript 数组则是数字索引的标号元素集合。

关联数组和数组都是 JavaScript 中用于表示集合的方式，各有其优点和应用场景。如果你需要使用唯一身份的“键”来存储数据，则关联数组是更好的选择。但如果你需要使用数字索引来存储和访问数据，则数组是更常用的方式。



#### 为什么数组最大索引是2<sup>32</sup>-2 ?

为什么JS数组索引最大是`4 294 967 294`, 而不是`4 294 967 295`?

> [Why is a JavaScript Array index at most 4294967294 but not 4294967295? - Stack Overflow](https://stackoverflow.com/questions/12766422/why-is-a-javascript-array-index-at-most-4294967294-but-not-4294967295)
>
> 数组长度是32位整数.所以数组长度可以从`0`到`Math.pow(2, 32) - 1` ,也就是`4 294 967 295`  ???
>
> 数组长度`n`表明其范围是从`0`到`n-1`. 所以JS数组最大的索引是`(Math.pow(2, 32)-1) - 1)` 或 `Math.pow(2, 32) - 2`, 也就是`4 294 967 294`.
>
> 所以JS数组可以包含最大`4 294 967 295`个元素,而不是`2 294 967 296`个元素.

```js
# 数组Array    //A大写,是一个类,首字母需要大写
 * 数组也是一个对象    //对象主要是用来存储对象的
 * 数组用来存储有序的数据   //Object对象中存储的数据是无序的
 * 数组中存储的数据成为 元素(element)
 * 数组中每一个元素都有一个唯一的序号,这个序号被称为 索引(index)
 * 索引是一组从0开始的整数
 * 使用typeof检查数组时,返回的是 'object'

```





#### 空位empty和undefined的区别

> https://juejin.cn/post/6844904025993773063#heading-14

**介绍**

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。

**ES5和ES6的不同表现**

**ES5 对空位的处理，就非常不一致，大多数情况下会忽略空位。**

* `forEach()`, `filter()`, `reduce()`, `every()` 和 `some()` 都会跳过空位。

* `map()` 会跳过空位，但会保留这个值。

* `join()` 和 `toString()` 会将空位视为 `undefined`，而 `undefined` 和 `null` 会被处理成空字符串。




**ES6 则是明确将空位转为`undefined`**，

* `entries()`、`keys()`、`values()`、`find()`和 `findIndex()` 会将空位处理成 `undefined`。

* `for...of` 循环会遍历空位。

* `fill()` 会将空位视为正常的数组位置。

* `copyWithin()` 会连空位一起拷贝。

* 扩展运算符（`...`）也会将空位转为 `undefined`。

* `Array.from` 方法会将数组的空位，转为 `undefined`。



```javascript
//ES5 的方法则会忽略这个空位，但具体的行为也会因方法而异：

const options = [1,,,,5];
// map()会跳过空位置
console.log(options.map(() => 6)); // [6, undefined, undefined, undefined, 6]
// join()视空位置为空字符串
console.log(options.join('-')); // "1----5"


//ES6
const a = Array.from([,,,]); // 使用ES6 的Array.from()创建的包含3 个空位的数组
for (const val of a) {
  alert(val === undefined);
}
// true
// true
// true
alert(Array.of(...[,,,])); // [undefined, undefined, undefined]
for (const [index, value] of options.entries()) {
  alert(value);
}
// 1
// undefined
// undefined
// undefined
// 5


//其他
const options = [1,,,,5];
for (const option of options) {
  console.log(option === undefined);
}
// false
// true
// true
// true
// false
```

**实践使用**

注意 由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。<u>如果确实需要空位，则可以显式地用undefined 值代替。</u>



#### 字符串索引和数值索引比较

```markdown
https://www.cnblogs.com/goloving/p/9180588.html
```

**结论**

1. **Javascript数组下标值的范围为0到2的32次方**
2. **对于任意给定的数字下标值，如果不在此范围内，js会将它转换为一个字符串，并将该下标对应的值作为该数组对象的一个属性值而不是数组元素，例如array[-1] = "yes" 其实就相当于给array对象添加了一个名为-1的属性，属性值为yes。**

```js
let arr = [];
arr['a'] = 'ahh';
arr['b'] = 'banner';
arr['c'] = 'cyx';
console.log(arr.length); //0
```



#### 值为null或undefined

如果数组中属性值含有null或undefined, 那么调用toLocaleString(),join(),toString(),<del>valueOf()</del>方法时, 返回的结果中以空字符串表示.

```javascript
let arr = [null, undefined, 1];

//浏览器环境下
console.log(arr.toLocaleString()); //',,1'
console.log(arr.join('')); //'1'
console.log(arr.join()); //',,1'
console.log(arr.toString()); //',,1'
console.log(arr.valueOf()); //[null, undefined, 1]
```



#### 稀疏数组和密集数组

> https://www.cnblogs.com/goloving/p/8686780.html

1.定义
稀疏数组:数组中的元素之间可以有空隙empty,
密集数组:每个元素都有值,即使是undefiend.
2.创建

```javascript
//2.1创建稀疏数组:数组元素实际只有2个，但是长度确实3.当你遍历这个数组的时候,不同的方法会有差异.
let arr = new Array(3);
arr[0]=0;
arr[2]=2; //中间一项是empty,这个arr数组是稀疏数组.

2.2创建密集数组:有真实元素了，虽然元素的值是undefined，但是你可以遍历到这些数组元素
let arr = Array.apply(null,Array(3)); //等同于let arr = Array(undefined,undefined,undefined);
```


