---
alias: 编译过程
---


### 背景

储存变量当中的值，并且能在之后对这个值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将状态带给了程序。

但是将变量引入程序会引起几个很有意思的问题:

* 变量储存在哪里?
* 程序需要时如何找到他们

存储和查找变量的规则,可以被称为作用域.

### 编译过程

#### 编译原理

传统编译语言流程中, 源代码在执行前会经历3个过程:

* <span style="color:blue">分词/词法分析(Tokenizing/Lexing)</span>
  * 将字符串分解成对编程语言有意义的代码块(代码块又被称为词法单元token.)
  * 分词(tokenizing) 和 词法分析(Lexing)的区别: 词法单元的识别是通过有状态还是无..
* <span style="color:blue">解析/语法分析(Parsing)</span>
  * 将词法单元转换成抽象语法树(AST)
* <span style="color:blue">代码生成</span>
  * 将AST转换为可执行代码的过程

比起那些编译过程只有三个步骤的语言的编译器，JavaScript引擎要复杂得多。(执行前短时间编译对要求更高??)

* JS不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript的编译过程不是发生在构建之前的。
* JS中,大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内

#### 处理过程

**实例**

以`var a = 2`为例:

* 首先, 编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。
* 遇到`var a`，<span style="color:blue;">编译器会询问作用域</span>是否在同作用域集合中存在同名变量
  * 是 编译器会忽略该声明，继续进行编译；
  * 否 它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a
* 编译器为引擎生成运行所需的代码,用来处理a=2这个赋值操作.  <span style="color:blue;">引擎运行时会首先询问作用域</span>，在当前的作用域集合中是否存在一个叫作`a`的变量。
  * 是, 引擎就会使用这个变量；
  * 否, 引擎会继续查找该变量
    * 找到, 就会将2赋值给它; 
    * 没找到, 引擎就会举手示意并抛出一个异常！

**编译器具体处理**

> 编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找?

查找变量的两种查询方式:

* LHS查询  “<span style="color:blue">赋值操作的目标是谁（LHS）</span> 一般出现在赋值操作的左侧
* RHS查询  <span style="color:blue">“谁是赋值操作的源头（RHS）”</span>  一般出现在赋值操作的右侧



**小结:**

变量的赋值操作会执行两个动作:

首先编译器会在当前作用域中<span style="color:blue;">**声明一个变量**</span>（如果之前没有声明过）;

然后在运行时引擎会在作用域中<span style="color:blue;">**查找该变量**</span>，如果能够找到就会对它**赋值**。

**查询的异常处理**

在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。具体表现如下:

* RHS查询遍寻不到所需的变量,引擎会抛出`ReferenceError`异常
* LHS查询遍寻不到所需变量,

  * 非严格模式: 全局作用域会创建一个具有该名称的变量,并返还给引擎(非'严格模式'下)
  * 严格模式: 抛出同RHS查询失败时类似的`ReferenceError`异常
* RHS查询找到一个变量,但对变量进行不合理操作(例如,对函数类型进行调用,引用null/undefined值中的属性), 引擎抛出`TypeError`.

> `ReferenceError` 同作用域判别失败相关
>
> `TypeError` 代表作用域判别成功了，但是对结果的操作是非法或不合理的。

