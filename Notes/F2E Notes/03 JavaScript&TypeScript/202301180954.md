---
alias: 对象方法
---



### 对象原型方法

ECMAScript其中一个设计目标是：不再创建新的全局函数，也不在Object.prototype上创建新的方法。

从ECMAScript 5开始，避免创建新的全局方法和在Object.prototype上创建新的方法。 当开发者想向标准添加新方法时，他们会找一个适当的现有对象。

而在ECMAScript 6中，为了使某些任务更易完成，在全局Object对象上引入了一些新方法。

#### 实例方法





####   in

```Markdown
in 
	如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。参数prop是指属性名或者数组索引
	语法: '属性名' in 对象   //注意加引号,是字符串.不加引号会被认为是一个变量
	如果对象中有这个属性名,返回true.如果没有返回false
	
	
delete
	用来删除对象中的指定属性,无论有没有这个属性,返回true 
	语法: 
  delete obj.username
  delete obj['a-b']   
	
hasOwnproperty
hasOwnProperty() 检查属性是否存在于对象自身中
```







JS中对象的**属性值**可以是任意类型的数据,也可以是一个对象

```JavaScript
let obj = Object();

obj.age = 18;
obj.test = Object();
obj.test.name = '猪八戒';
obj.test.tt = Object();

```

 

#### delete
[[202301180954b|delete]]

```js
delete obj.pro
delete obj[pro]
```




#### toJSON()

Object.prototype并非定义toJSON()方法,但JSON.stringify()方法会从要序列化的对象上寻找toJSON()方法. 如果要序列化的对象上存在这个方法就会调用它,然后序列化该方法的返回值, 而不是原始对象.

Date类定义了自己的toJSON()方法,返回一个表示日期的序列化字符串.

```javascript
let point = {
  x: 1,
  y: 2,
  toString: function() {return `${this.x}, ${this.y}`},
  toJSON: function() { return this.toString() }
}
```



#### 3. Object.prototype.toString()

**Define**

> the method returns a string representing the object.

**Syntax**

```javascript
toString()
```

**Return value**



**Desc**

Every object has a `toString()` method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected(或当以预期字符串方式引用对象时).

By default, the `toString()` method is inherited by every object descended from `Object`. If this method is not overridden in a custom object, `toString()` return `[object type]`, where `type` is the object type. 

The following code illustrates this:

```javascript
const o = new Object();
o.toString(); //[object Object]
```

很多类都会重新定义自己的toString方法.例如,在把数组转换为字符串时,可以得到数组元素的一个列表,每个元素也都会转换为字符串; 把函数转换为字符串时,可以得到函数饿源代码.



Note:

> Starting in JavaScript 1.8.5, 'toString()' called on null returns '[object null]', and undefined returns '[object undefined]', as defined in the 5th Edition of ECMAScript and subsequent Errata.

**Parameters**

For Numbers and BigInts `toString()` takes an optional parameter `radix` the value of radix must be minimun 2 and maximum 36.

By using `radix` you can also convert base 10 numbers(like 1,2,3,4,5,....) to another base numbers, in example blow we are conveting base 10 number to a base 2 (binary) number.

```javascript
let base10Int = 10;
console.log(base10Int.toString(2)); //1010
```

and same for big integers

```javascript
let bigNum = BigInt(20);
console.log(bigNum.toString()); //10100
```



**Examples**

<u>1.Overriding the default toString method</u>

You can create a function to be called in place of the default `toString()` method. The `toString()` method takes no arguments and should return a string. The `toString()` method you create can be any value you want, but it will be most useful if it carries information about the object.

The following code defines the 'Dog' object type and creates 'theDog', an object of type 'Dog':

```javascript
function Dog(name, breed , color, sex) {
  this.name = name;
  this.breed = breed;
  this.color = color;
  this.sex = sex;
}

theDog = new Dog('Gabby' , 'Lab', 'chocolate', 'female');
```

If you call the 'toString()' method on this custom object, it returns the default value inherited from `Object`:

```javascript
theDog.toString() //'[object Object]'
```

The following code create and assigns 'dogToString()' to override the default 'toString()' method. This function generates a string containing the 'name breed color and sex'of the object, in the form 'property =value'.

```javascript
Dog.prototype.toString = function dogToString() {
  const ret = 'Dog ' + this.name + ' is a ' + this.sex + ' ' + this.color + ' ' + this.breed;
  return ret;
}
```

With the preceding code in place, any time `toString()` is used in a `Dog` context, JavaScript automatically calls the `dogToString()` function, which returns the following string:

```javascript
"Dog Gabby is a female chocolate Lab"
```



<u>2.Using toString() to detect object class</u>

`toString()` can be used with every object and (by default) allows you to get its class.

To use the `Object.prototype.toString()` with every object, you need to call [`Function.prototype.call()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call) or [`Function.prototype.apply()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) on it, passing the object you want to inspect as the first parameter (called `thisArg`).

```javascript
cosnt toString = Object.prototype.toString;

toString.call(new Date);    // [object Date]
toString.call(new String);  // [object String]
toString.call(Math);        // [object Math]

// Since JavaScript 1.8.5
toString.call(undefined);   // [object Undefined]
toString.call(null);        // [object Null]
```

Using `toString()` in this way is unreliable; objects can change the behavior of `Object.prototype.toString()` by defining a [`Symbol.toStringTag`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag) property, leading to unexpected results. For example:

```javascript
const myDate = new Date();
Object.prototype.toString.call(myDate);     // [object Date]

myDate[Symbol.toStringTag] = 'myDate';
Object.prototype.toString.call(myDate);     // [object myDate]

Date.prototype[Symbol.toStringTag] = 'prototype polluted';
Object.prototype.toString.call(new Date()); // [object prototype polluted]
```

Note:

```javascript
toString.call(true); //[object Boolean]

'toString' in window' //true
```



#### 4. Object.prototype.valueOf()

**Define**

> this method returns the **primite value** of the specified object

与toString()类似,通常在对象转换为某些非字符串原始值(通常是数值)时被调用.内置的一些类定义了自己的valueOf()方法: Date类的valueOf()可以将日期转换为数值,这样就让日期对象可以通过`< 和 >`操作符进行比较.

**Syntax**

> valueOf()

**Return value**

the primitive value of the specified object.

A [(unary) plus sign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus) can sometimes be used as a shorthand for valueOf. e.g. in `+new Number()`.

**Desc**

<u>JavaScript calls the `valueOf` method to convert an object to a primitive value.</u> You rarely need to invoke the `valueOf` method yourself, JavaScript **automatically invoke it** when encountering  an object where a primitive value is expected.

By default, the `valueOf` method is inherited by every object descended from `Object`. Every built-in core object overrides this method to return an appopriate value. **If an object has no primitive value, `valueOf` returns the object iteself.**

<u>You can use `valueOf` within your own code to convert a built-in object into a primitive value.</u> When you create a custom object, you can override `Object.prototype.valueOf()` to call a custom method instead of the default  `Object` method.

Overriding valueOf for custom objects

You can create a function to be called in place of the default `valueOf` method. Your function must take no arguments.

Suppose you have an object type `MyNumberType` and you want to create a `valueOf` method for it. The following code assigns a user-defined function to the object's `valueOf` method.

```javascript
MyNumberType.prototype.valueOf = function() {return customPrimitiveValue;};
```

With the preceding code in place(使用上述代码), any time an object of type `MyNumberType` is used in a context where ti is to be represented as a primitive value,(只要在上下文中使用`MyNumberType`类型的对象,该对象将表示为私有值), JavaScript automatically calls the function defined in the preceding code.

An object's `valueOf` method is usually invoked by JavaScript, but you can invoke it yourself as follows:

```javascript
myNumberType.valueOf()
```

Note:

> Objects in string contexts convert via the 'toString()' method, which is different from 'String' objects converting to string primitive using 'valueOf'. All objects hava a string convertion, if only "[object type]". But many objects do not convert to number, boolean or function.

**Examples**

Using valueOf on custom types

```javascript
function MyNumberType(n) {
  this.number = n;
}
MyNumberType.prototype.valueOf = function() {
  return this.number;
};

let myObj = new MyNumberType(4);
myObj + 3 ;//7
```

Using uary plus

```javascript
+"5" // 5 (string to number)
+"" // 0 (string to number)
+"1 + 2" // NaN (doesn't evaluate)
+new Date() // same as (new Date()).getTime()
+"foo" // NaN (string to number)
+{} // NaN
+[] // 0 (toString() returns an empty string list)
+[1] // 1
+[1,2] // NaN
+new Set([1]) // NaN
+BigInt(1) // Uncaught TypeError: Cannot convert a BigInt value to a number
+undefined // NaN
+null // 0
+true // 1
+false // 0
```





#### Object.prototype.hasOwnProperty()

##### define

> the method returns a boolean indicating whether the object has the specified property as its own property(as opposed to inheriting it)
>
> Note: `Object.hasOwn()` is recommended over `hasOwnProperty()`, in browsers where it it supported.

##### Syntax

> hasOwnProperty(prop)

##### Parameters

`prop`

* The `String` name or `Symbol` of the property to test

##### Return values

> returns `true` if the object has the specified property as own property, `false` otherwise.

##### Desc

* the method returns `true` if the specified property is a direct property of the object --even if the value is `null` or `undefined`.
* the method returns `false` if the property is inherited, or has not been declared at all.
* Unlike the `in` operator, this method does not check for the specified property in the object's prototype chain.
* the method can be called on most JS objects, because most objects descend from `Object`, and hence inherit its methods.
* the method will not be available in objects where it is reimplemented, or on objects created using `Object.create(null)`(as these don't inherit from `Object.prototype`).



#### Object.prototype.toLocalString()

##### 概述

这个方法返回对象的本地化字符串表示.Object定义的默认toLocalString()方法本身没有实现任何本地化,而是简单调用toString()并返回该值. Date和Number类定义了自己的toLocalString()方法, 尝试根据本地管理格式化数值/日期和时间.







### 对象自身方法

#### polyfill和shim的比较

> [Object.defineProperty是Es5中无法shim的特性 shim是什么？_夏目友人帐...的博客-CSDN博客_无法shim的特性](https://blog.csdn.net/xiaoyuer_2020/article/details/111364064)

* shim
  一个shim是一个库，它将一个新的API引入到一个旧的环境中，而且仅靠旧环境中已有的手段实现。

* polyfill

  一个polyfill是一段代码(或者插件)，提供了那些开发者们希望浏览器原生提供支持的功能

通常的做法是，先检查当前浏览器是否支持某个[API](https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020)，如果不支持的话就加载对应的polyfill，然后新旧浏览器就都可以使用这个API了



#### Object.is

当你想在JavaScript中比较两个值时，多使用全等运算符（===），从而避免在比较时触发强制类型转换的行为。

判断两个值是否为[同一个值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness).  于相等运算符,全等运算符一起可以来判断操作数是否为同一个对象的实例.

与`==`运算符不同,`Object.is`不会强制转换两边的值.

与`===`运算符不同,`Object.is`会将`-0`和`+0`视为不相等,将`Number.NaN`与`NaN`视为相等.

`+0  `和 `-0`在JavaScript引擎中被表示为两个完全不同的实体

ECMAScript 6引入了Object.is()方法来弥补全等运算符的不准确运算。这个方法接受两个参数，如果这两个参数类型相同且具有相同的值，则返回true。

```js
Object.is(value1,value2)

返回值:布尔值

//判断条件:



//示例
Object.is([], []);           // false

var foo = { a: 1 };
var bar = { a: 1 };
Object.is(foo, foo);         // true
Object.is(foo, bar);         // false

Object.is(null, null);       // true

Object.is(0, -0);            // false 
Object.is(0, +0);            // true
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true
Object.is(NaN,NaN);          //true
```

**Object.is与`===`比较**

```javascript
//不同
1.它适用于 NaN：Object.is(NaN，NaN) === true
2.Object.is(0，-0) === false，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。

//相同
在所有其他情况下，Object.is(a，b) 与 a === b 相同
```







#### Object.assign()

##### **介绍**

> 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象. 它将返回目标对象.

##### **语法**

```javascript
Object.assign(target, ...sources);
```

**参数**

`target`  目标对象

`sources` 源对象

**返回值**

目标对象

##### **描述**

* 源对象中的属性会覆盖目标对象中有相同属性的键(key).同样,后面源对象的属性也会覆盖前面相同的属性.
* 此方法只拷贝源对象自身可枚举<span style="color: blue;"><sup>enumerable</sup></span>的属性到目标对象.
* 方法在源对象上使用`[[Get]]`,在目标对象上使用`[[Set]]`,所以它会调用[getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) 和 [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set). 
* 所以,这个方法分配属性,而不仅仅是复制或定义新的属性
* 如果合并的源对象中包含getters,那么合并新属性到原型上是不适合的.(Therefore it assign properties, versus copying or defining new properties.)
* <span style="span:hover{color:red;}">为了将属性定义(包括其可枚举性)复制到原型, 应使用`Object.getOwnPropertyDescriptor()` 代替`Object.defineProperty()`.</span>
* `String` 和 `Symbol` 属性会被拷贝.
* 为了预防错误,,例如,一个属性是不可写的,会出现一个类型错误,如果在报错之前添加了任意属性那么`target`对象会改变.

> Note:
>
> Object.assign() does not throw on `null` or `undefined` source
>
> 不会抛出`null`或`undefined`源





**使用概述**

object.assign接受两个或多个对象作为参数. 它会修改并返回第一个参数,第一个参数是目标对象,但不会修改第二个及后续参数,那些事来源对象. 对于每个来源对象,它会把该对象的<span style="color:red">可枚举自有属性(包括名字为符号的属性)</span>复制到目标对象. 它按照参数列表顺序逐个处理来源对象,第一个来源对象的属性会覆盖目标对象的同名属性,而第二个来源对象(如果有)的属性会覆盖第一个来源对象的同名属性.

Object.assign以普通的属性获取和设置方式复制属性. 因此如果一个来源对象有获取方法或目标对象有设置方法, 则他们会在复制期间被调用, 但这些方法本身不会被复制.

**使用原因**

将属性从一个对象分配到另一个对象的一个原因是, 如果有一个默认对象为很多属性定义了默认值,并且如果该对象中不存在同名属性,可以将这些默认属性复制到另一个对象中.

但是像下面这样简单的使用Object.assign不会达到目的:

```javascript
Object.assign(o, defaults) //用default覆盖o的所有属性
```

此时,需要一个新对象,先把默认值复制到新对象中,然后再使用o的属性覆盖那些默认值:

```javascript
o = Object.assign({}, default, o)
```

同时,ES6中新增了扩展操作符也可以表达这种对象复制和覆盖操作:

```javascript
o = {...defaults, ...o}
```

为了避免额外的对象创建和复制, 也可以重写Object.assign(), 只复制那些不存在的属性:

```javascript
// 与Object.assign类似,但不覆盖已经存在的属性
// (同时也不处理符号属性)

function merge(target, ...sources) {
  for (let source of sources) {
    for (let key of Object.keys(source)) {
      if (!(key in target)) { //这里跟Object.assign不同
        target[key] = source[key]
      }
    }
  }
  return target
}
```



**Polyfill**

这个Polyfill不支持symbol属性,由于ES5中本来就不存在symbols

```javascript
if (typeof Object.assign !== 'function') {
  Object.defineProperty(Object, 'assign', {
    value: function assign(target, varArgs) {
      'use strict'
      if (target === null || target === undefined) {
        throw new TypeError('Cannot convert undefined or null to object')
      }
      
      let to = Object(target);
      
      for (let i=1; i<arguments.length; i++) {
        let nextSource = arguments[i];
        
        if (nextSource !== null && nextSource !== undefined) { //why? 使用 或 不行吗
          for (let nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { //nextSource.hasOwnProperty
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      
      return to;
    },
    writable: true,
    configurable: true
  })
}
```





##### **实例**

<u>Cloning an object</u>

```javascript
const obj = {a: 1};
const copy = Object.assign({}, obj);
console.log(copy); //{a: 1}
```



<u>Warning for Deep Clone</u>

For [deep cloning](https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy), we need to use alternatives, because `Object.assign()` copies property values.

If the source value is a reference to an object, it only copies the reference value.

```javascript
function test() {
  'use strict';

  let obj1 = { a: 0 , b: { c: 0}};
  let obj2 = Object.assign({}, obj1);
  console.log(JSON.stringify(obj2)); // { "a": 0, "b": { "c": 0}}

  obj1.a = 1;
  console.log(JSON.stringify(obj1)); // { "a": 1, "b": { "c": 0}}
  console.log(JSON.stringify(obj2)); // { "a": 0, "b": { "c": 0}}

  obj2.a = 2;
  console.log(JSON.stringify(obj1)); // { "a": 1, "b": { "c": 0}}
  console.log(JSON.stringify(obj2)); // { "a": 2, "b": { "c": 0}}

  obj2.b.c = 3;
  console.log(JSON.stringify(obj1)); // { "a": 1, "b": { "c": 3}}
  console.log(JSON.stringify(obj2)); // { "a": 2, "b": { "c": 3}}

  // Deep Clone
  obj1 = { a: 0 , b: { c: 0}};
  let obj3 = JSON.parse(JSON.stringify(obj1));
  obj1.a = 4;
  obj1.b.c = 4;
  console.log(JSON.stringify(obj3)); // { "a": 0, "b": { "c": 0}}
}

test();
```



<u>Merging object</u>

```javascript
const o1 = { a: 1 };
const o2 = { b: 2 };
const o3 = { c: 3 };

const obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.
```

<u>Merging objects with same properties</u>

the properties are overwritten by other objects that have the same properties later in the parameters order.

```javascript
const o1 = { a: 1, b: 1, c: 1 };
const o2 = { b: 2, c: 2 };
const o3 = { c: 3 };

const obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
```

<u>Copying symbol-typed properties</u>

```javascript
const o1 = { a: 1 };
const o2 = { [Symbol('foo')]: 2 };

const obj = Object.assign({}, o1, o2);
console.log(obj); // { a : 1, [Symbol("foo")]: 2 } (cf. bug 1207182 on Firefox)
Object.getOwnPropertySymbols(obj); // [Symbol(foo)]
```

<u>Properties on the prototype chain and non-enumerable properties cannot be copied</u>

```javascript
const obj = Object.create({foo: 1}, {
  bar: {
    value: 2 //bar is a non-enumerable property
  },
  baz: {
    value: 3,
    enumerable: true //baz is an own enumerable property
  }
});

const copy = Object.assign({}, obj);
console.log(copy); //{baz: 3}
```

<u>Primitives will be wrapper to objects</u>

> <span style="color:red;">Note, only string wrappers can have own enumerable properties.</span>

```javascript
const v1 = 'abc';
const v2 = true;
const v3 = 10;
const v4 = Symbol('foo');

const obj = Object.assign({}, v1, null, v2, undefined, v3, v4);
// Primitives will be wrapped, null and undefined will be ignored.
// Note, only string wrappers can have own enumerable properties.
console.log(obj); // { "0": "a", "1": "b", "2": "c" }
```

<u>Exceptions will interrupt the ongoing copying task </u>

```javascript
const target = Object.defineProperty({}, 'foo', {
  value: 1,
  writable: true
});

Object.assign(target, {bar: 2}, {foo2: 3, foo: 3}, {baz: 4});
//TypeError: 'foo' is read-only
//the exception is thrown when assigning target.foo

console.log(target.bar);  // 2, the first source was copied successfully.
console.log(target.foo2); // 3, the first property of the second source was copied successfully.
console.log(target.foo);  // 1, exception is thrown here.
console.log(target.foo3); // undefined, assign method has finished, foo3 will not be copied.
console.log(target.baz);  // undefined, the third source will not be copied either.
```

<u>Copying accessors</u> ????

```javascript
const obj = {
  foo: 1,
  get bar() {
    return 2;
  }
};

let copy = Object.assign({}, obj);
console.log(copy); //{foo:1, bar: 2} //the value of copy.bar is obj.bar's getter's return value.

//this is an assign function that copies full descriptors
function completeAssign(target, ...sources) {
  sources.forEach(source => {
    let descriptors = Object.keys(source).reduce((descriptors, key) => {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {})
    
    //by default, Object.assign copies enumerable Symbols, too
    Object.getOwnPropertySymbol(source).forEach(sym => {
      let descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);  });
  return target;
}


```

##### 实现

**ES5实现ES6Object.assign()功能**

混合（Mixin）是JavaScript中实现对象组合最流行的一种模式。在一个mixin方法中，一个对象接收来自另一个对象的属性和方法

```javascript
function mixin(receiver, supplier) {
  Object.keys(supplier).forEach(key => receiver[key] = supplier[key]);
}
```

mixin()函数遍历supplier的自有属性并复制到receiver中（<u>此处的复制行为是浅复制，当属性值为对象时只复制对象的引用</u>）。这样一来，receiver不通过继承就可以获得新属性，请参考这段代码：

```javascript
function EventTarget() { }
EventTarget.prototype = {
    constructor: EventTarget,
    emit: function() {},
    on: function() {}
  };

let myObject = {};
mixin(myObject, EventTarget.prototype);

myObject.emit('somethingChanged');
```

在这段代码中，myObject接收EventTarget.prototype对象的所有行为，从而使myObject可以分别通过emit()方法发布事件或通过on()方法订阅事件。

这种混合模式非常流行，因而ECMAScript 6添加了Object.assign()方法来实现相同的功能，这个方法接受一个接收对象和任意数量的源对象，最终返回接收对象。<u>mixin()方法使用赋值操作符（assignment operator）=来复制相关属性，却不能复制访问器属性到接收对象中</u>，因此最终添加的方法弃用mixin而改用assign作为方法名。

任何使用mixin()方法的地方都可以直接使用Object.assign()方法来替换

```javascript
function EventTarget() {}
EventTarget.prototype = {
  constructor: EventTarget,
  emit: function() {},
  on: function() {}
}

let myObject = {};
Object.assign(myObject, EventTarget.prototype);
myObject.emit('somethingChanged');
```

Object.assign()方法可以接受任意数量的源对象，并按指定的顺序将属性复制到接收对象中。所以如果多个源对象具有同名属性，则排位靠后的源对象会覆盖排位靠前的





**Object.assign()** 方法用于**将所有可枚举属性的值**从一个或多个源对象分配到目标对象。它将返回目标对象. 同时它也可以实现**浅拷贝**.因为 `Object.assign()`拷贝的是（可枚举）属性值。

```js
//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

const target = {a:1,b:2};
const source = {b:3,c:3};

const returnTarget = Object.assign(target,source);

console.log(target);//{ a: 1, b: 4, c: 5 }
console.log(returnTarget);//{ a: 1, b: 4, c: 5 }

//浅拷贝测试
target['e']=5;
console.log(returnTarget.e) //5
```



**访问器属性**

Object.assign()方法不能将提供者的访问器属性复制到接收对象中。由于Object.assign()方法执行了赋值操作，因此<u>提供者的访问器属性最终会转变为接收对象中的一个数据属性.</u>

```javascript
let receiver = {},
    supplier = {
      get name() {
        return 'file.js'
      }
    };

Object.assign(receiver, supplier);

let descriptor = Object.getOwnPropertyDescriptor(receiver, 'name');

console.log(descriptor.value); //'file.js'
console.log(descriptor.get); //undefined
```



##### 存在的问题

指回替换对象的第一层key, 对于多层的,会当做值处理

> https://blog.csdn.net/weixin_45818024/article/details/114651552
>
> https://juejin.cn/post/6882549580559777800



```javascript
//对象的合并 存在的问题: 原型链污染漏洞
function merge(target, source) {
    for (let key in source) {
        if (key in source && key in target) {
            merge(target[key], source[key])
        } else {
            target[key] = source[key]
        }
    }
}
```





#### Object.keys

返回一个由一个给定对象的**自身可枚举属性**组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致.

**不保证对象属性的顺序**,mdn上没有直接说明,只是说明和手动遍历相同.因为迭代的顺序是依赖于浏览器实现的，结论是不保证.

```js
// simple array
var arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.keys(obj)); // console: ['0', '1', '2']

// array like object with random key ordering
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']
```



```js
//对象中的属性排序,新对象
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
let arr = Object.keys(anObj);
let newObj = {};
for(let i=0;i<arr.length;i++){
  newObj[arr[i]]=anObj[arr[i]]
}
console.log(newObj); //{ '2': 'b', '7': 'c', '100': 'a' }
```





#### Object.values()

> 这个方法返回一个参数对象自身可枚举属性值组成的数组，数组元素顺序和for...in循环相同。(唯一的不同是for...in循环也枚举原型链上的属性)
>
> 描述：
>
> return an array whose elements are the enumerable property values found on the object. the ordering of the properties is the same as that given by looping over the property values of the object manaually.

```javascript
const obj = {
  a: 'something',
  b: 42,
  c: false
};

console.log(Object.values(obj)); //['something', 42, false]

//Array-like object
const arrayLikeObj = {0: 'a', 1: 'b', 2: 'c'};
console.log(Object.values(arrayLikeObj)); //['a', 'b', 'c']

//Array-like object with random key ordering
const arrayLikeObj2 = {100: 'a', 2: 'b', 7: 'c'};
console.log(Object.values(arrayLikeObj2)); //['b', 'c', 'a']

//getFoo is property which isn't enumerable    enumerable默认为false
const my_obj = Object.create({}, {getFoo: {value: function() {return this.foo;}}});
my_obj.foo = 'bar';
console.log(Object.values(my_obj)); //['bar']
```



#### Object.entries()

##### Define

> the method returns an array of a given object's own enumerable string-keyed property `[key, value]` pairs. 
>
> This is the same as iterating with a `for...in` loop, excep that a `for...in` loop enumerates properties in the prototype chain as well.
>
> The order of the array returned by `Object.entries()` is the same as that provided by a `for...in` loop. If there is a need for defferent ordering, then the array should be sorted first, like `Object.entries(obj).sort((a, b) => b[0].localCompare(a[0]))`.

##### Syntax

> Object.entries(obj)

##### Parameters

`obj` 

* The object whose own enumerable <u>string-keyed</u><sup>字符串键控</sup> property `[key, value]` pairs are to be returned.

##### Return value

​	An array of the given object's own enumerable string-keyed property `[key, value]` pairs.

##### Desc

* the method returns an array whose elements are arrays corresponding to the enumerable string-keyed property `[key, value]` pairs found directly upon `object`.
* the ordering of the proeprties is the same as that given by looping over the property values of the object manually.

##### Polyfill

​	to add compatible `Object.entries()`support in older enviroments that do not natively support it, you can use any of the following:

- a demonstration implementation of `Object.entries` in the [tc39/proposal-object-values-entries](https://github.com/tc39/proposal-object-values-entries) (if you don't need any support for IE);
- a polyfill in the [es-shims/Object.entries](https://github.com/es-shims/Object.entries) repositories;
- or, you can use the simple, ready-to-deploy polyfill listed below:

```javascript
if (!Object.entries) {
  Object.entries = function(obj) {
    let ownProps = Object.keys(obj),
        i = ownProps.length,
        resArray = new Array(i); //preallocate the Array
    while(i--)
      resArray[i] = [ownProps[i], obj[ownProps[i]]];
    
    return resArray;
  }
}
```

For the above polyfill code snippet, if you need support for IE<9, then you will also need an `Object.keys()` polyfill (such as the one found on the [`Object.keys`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) page).



##### Examples ????

```javascript
const obj = { foo: 'bar', baz: 42 };
console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]

// array like object
const obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]

// array like object with random key ordering
const anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]

// getFoo is property which isn't enumerable ????
const myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });
myObj.foo = 'bar';
console.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]

// non-object argument will be coerced to an object
console.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]

// returns an empty array for any primitive type except for strings (see the above example), since primitives have no own properties
console.log(Object.entries(100)); // [ ]

// iterate through key-value gracefully
const obj = { a: 5, b: 7, c: 9 };
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
}

// Or, using array extras
Object.entries(obj).forEach(([key, value]) => {
  console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
});
```

Converting an Object to a Map

the `new Map()` constructor accepts an iterable of entries. With `Object.entries`, you can easily convert from `Object` to `Map`:

```javascript
const obj = {foo: 'bar', baz: 42};
const map = new Map(Object.entries(obj));

console.log(map); //Map(2) {'foo' => 'bar', 'baz' => 42}
```

Iterating througn an Object

Using `Array Destructuring`, you can iterate through objects easily:

```javascript
const obj = {foo: 'bar', baz: 42};
Object.entries(obj).forEach(([key, value]) => console.log(`${key}: ${value}`))
```





#### Object.getPrototypeOf()

##### Define

> the method returns the prototype(i.e the value of the internal [[Prototype]] property) of the specified object

##### Syntax

> Object.getPrototype(bj)

##### Parameters

`obj`

* the object whose prototype is to be returned

##### return value

* the prototype of the given object. 
* <u>If there are no inherited properties, `null` is returned.</u>

##### examples

Using getPrototypeOf

```javascript
let proto = {};
var obj = Object.create(proto);
Object.getPrototypeOf(bj) === proto; //true
```

Non-object coercion(强制转换)

In ES5, it will throw a TypeError exception if the obj parameter isn't an object.

In ES2015, the parameter will be coerced to an Object.

```javascript
Object.getPrototypeOf('foo');
// TypeError: "foo" is not an object (ES5 code)
Object.getPrototypeOf('foo');
// String.prototype                  (ES2015 code)
```



#### Object.setPrototypeOf() (未完成)

##### Define

> the method sets the prototype of a specified object to another object or null.

##### Warning

> Changing the [[Prototype]] of an object is, by the nature of [how modern JavaScript engines optimize property accesses](https://mathiasbynens.be/notes/prototypes), currently a very slow operation in every browser and JavaScript engine. In addition, the effects of altering inheritance are subtle and far-flung, and are not limited to the time spent in the `Object.setPrototypeOf()` statement, but may extend to any code that ahs access to any object whose `[[Protootype]]` has been altered.
>
> Because this feature is a part of the language, it is still the burden on engine developers to implement that feature performantly(ideally). Until engine developers address this issue, if u are concerned about performance, u should avoid setting the `[[Prototype]]` of an object. Instead, create a new object with the secired `[[Prototype]]` using `Object.create(null)`.

##### Syntax

> Object.setPrototypeOf(obj, prototype)

##### Parameters

`obj`

* the object which is to have its prototype set.

`prototype`

* the object's new prototype(an object or null).

##### return value

* the specified object

##### Desc

* Throws a TypeError exception if the object whose `[[Prototype]]` is to be modified is non-extensible according to `Object.isExtensible()`.
* Does nothing if the `prototype` parameter isn't an object or `null`(i.e., number , string, boolean, or undefined). Otherwise, this method changes the `[[Prototype]]` of `obj` to the new value.
* `Object.setPrototypeOf()` is in the ECMAScript 2015 specification. It is generally considered the proper way to set the prototype of an object, vs. the more controversial `Object.prototype.__proto__` property.





#### Object.prototype.isPrototypeOf()



#### Object.getOwnPropertyDescriptor()

##### Define

>the method returns an object describing the configuration of a specific property on a given object(that is, one directly present on an object and not in the object's prototype chain).
>
>The object returned is mutable but mutating it has no effect on the original property's configuration.

##### Syntax

> Object.getOwnPropertyDescriptor(obj, prop);

##### Parameter

`obj`

* the object in which to look for the proeprty

`prop`

* the name or `Symbol` of the proeprty whose description is to be retrieved(检索).

##### Desc

* this method permits examinition(检查) of the precise description of a property.
* A property in JavaScript consists of either a string-valued(字符串值) name or a Symbol and a property descriptor.
* Futher information about property descriptor types and their attributes can be found in `Object.defineProperty()`
* A property descriptor is a record with some of the following attributes:
  * `value`  
    * the value associated with the property(data descriptors only)
  * `writable` 
    *  `true` if and only if the value associated with the property may be changed(data descriptors only)
  * `get` 
    * A function which serves as a getter for the property, or `undefined` if there is no getter(accessor descriptor only)
  * `set`
    * A function which serves as a setter for the property, or `undefined` if there is no setter(accessor descriptor only)
  * `configurable`
    * `true` if and only if the type of this proeprty descriptor may be changed and if the property any be deleted from the corresponding object.
  * `enumerable`
    * `true` if and only if the property shows up during enumeration of the properties on the corresponding object.

##### Examples

Using Object.getOwnPropertyDescriptor

```javascript
let o, d;
o = {get foo() {return 17;}};
d = Object.getOwnPropertyDescripor(o, 'foo');
//d 
{
  configurable: true,
  enumerable: true,
  get: /*this getter function*/,
  set: undefined
}

o = {bar: 42};
d = Object.getOwnPropertyDescriptor(o, 'bar');
{
  value: 42,
  writable: true,
  configurable: true,
  enumerable: true
}

o = {[Symbol.for('baz')]: 73};
d = Object.getOwnPropertyDescriptor(o, Symbol.for('baz'));
{
  configurable: true,
  enumerable: true,
  value: 73,
  writable: true
}

o = {};
Object.defineProperty(o, 'qux', {
  value: 8675309,
  writable: false,
  enumerable: false
});
d = Object.getOwnPropertyDescriptor(o, 'qux');
{
  value: 8675309
  writable: false,
  enumerable: false,
  configurable: false
}
```

Non-object coercion(强制转换)

> In ES5, if the first argument to this method is not an object(a primitive), then it will cause a `TypeError`. In ES2015, a non-object first argument will be coerced to an object at first.

```javascript
Object.getOwnPropertyDescriptor('foo', 0);
//TypeError: 'foo' is not an object //ES5 code

Object.getOwnPropertyDescriptor('foo', 0);
{
  configurable: false,
  enumerable: true,
  value: 'f',
  writable: false
}
```



#### Object.getOwnPropertyDescriptors()

##### Define

>the method returns all own property descriptors of a given object

##### Syntax

> Object.getOwnPropertyDescriptors(obj);

##### Parameter

`obj`

* the object for which to get all own property descriptors

##### return value

* An object containing all own property descriptors of an object. 
* Might be <u>an empty object</u>, if there are no properties.

##### Desc

* the method permits examiniation of the precise description of all own properties of an object.
* A property in JavaScript consists of either a string-valued name or a `Symbol` and a property descriptor.
* Futher information about property descriptor types and their attributes can be found in `Object.defineProperty()`
* A proeprty descriptor is a record with some of the following attributes:
  * `value`
    * the value associated with the property(data descriptor only)
  * `writable`
    * `true` if and only if the values associated with property may be changed(data descriptors only)
  * `get`
    * A function which serves as a getter for the property, or `undefined` if there is no getter(accessor descriptors only)
  * `set`
    * A function which serves as a stter for the property, or `undefined` if there is no setter(accessor descriptor only).
  * `configurable`
    * `true` if and only if the type of this proeprty descriptor may be changed and if the property may be deleted from the corresponding object.
  * `enumerable`
    * `true` if and only if this property shows up during enumeration of the properties on the corresponding object.



##### example

<u>Creating a shallow(浅的) clone</u>   ????

Whereas the `Object.assign()` method will only copy enumerable and own properties from a source object to a target object, u are able to use this method and `Object.create()` for a shallow copy between two unknown objects:

```javascript
Object.create(
	Object.getPrototype(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

<u>Creating a subclass</u> ????

A typical way of creating a subclass is to define the subclass, set its prototype to an instance of the superclass, and then define properties on that instance.

This can get awkward(笨拙的) especially for getters and setters. Instead, u can use this code to set the prototype.

```javascript
function superclass() {}
superclass.prototype = {};

function subclass() {}
subclass.prototype = Object.create(
	superclass.prototype,
  {
    // define the subclass constructor, methods, and the properties here
  }
)
```





#### Object.getOwnPropertyNames()

Object.getOwnPropertyNames()返回<u>直接挂在目标对象上的</u>可枚举、不可枚举属性. 但为了和ES5保持一致,不包括Symbol属性.

```js
https://juejin.cn/post/6844903796062191624

//保证对象属性顺序的迭代方式
js内部的ownPropertyKeys方法,定义了对象属性遍历的顺序.
基于内部ownPropertyKeys方法实现的方法有Object.hasOwnPropertyNames()和Reflect.ownKeys(),这两种都保证对象属性的顺序.
Reflect.ownKeys()返回的结果等价于Object.hasOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))包括直接挂在目标对象上的可枚举、不可枚举、Symbols的属性组成的数组。但是要考虑兼容性（ES6提出，ie不支持)

Object.getOwnPropertyNames()返回直接挂在目标对象上的可枚举、不可枚举属性组成的，在ES5提出，兼容性更好，支持IE9+：


//为Object.keys()添加顺序
Object.keys.sort()
```



#### Object.getOwnPropertySymbols()

##### Define

> the method returns an array of all symbol properties found directly upon a given object.

##### Syntax

> Object.getOwnPropertySymbol(obj)

##### Parameters

`obj`

* the object whose symbol properties are to be returned

##### return value

* an array of all symbol properties found directly upon the given object

##### Desc

* Similar to `Object.getOwnPropertyNames()`, u can get all symbol properties of a given object as an array of symbols.
* Note that `Object.getOwnPropertyNames()` itself does not contain the symbol properties of an object and only the string properties.
* As all objects have no own symbols properties initially, `Object.getOwnPropertySymbols()` returns an empty array unless u have set symbol properties on ur object.

##### example

```javascript

//xxx
```



#### Object.defineProperty()

**define**

> the static method defines a new property directly on an object, or modifies an existing property on an object, and return the object.

**syntax**

> Object.definePorperty(object, prop, descriptor)

`object`

* the object on which to define the property

`prop`

* the name or Symbol of the property to be defined or modefied

`descriptor`

* the descriptor for the property being defined or modefied.

**return value**

the object that was passed to the function



**Desc**

this method allows a precise addition to or modification of a property on an object.

<u>Normal property addition through assignment(赋值) creates properties</u> which show up during property enumeration(for...in or Object.keys() method), whose values may be changed, and which may be deleted.

this method allows these extra details to be changed from their defaults.

<span style="text-decoration: underline wavy">By default, values added using `Object.defineProperty()` are <u>immutable(不可改变的)</u> and not enumerable.</span>

Property descriptors present in objects come in two main flavors:  data descriptors and accessor descriptor.

* A data descriptor is a property that has a value, which may or may not be writable
* An accessor descriptor is a property described by a getter-setter pair of functions.
* A descriptor must be one of these two flavors; it cannot be both.

Both data and accessor descriptors are objects. they share the following optional keys(note: the defaults mentioned here are in the case of defining properties using 'Object.defineProperty()'):

* `configurable`
  * true if the type of this proeprty descriptor may be changed and if the property may be deleted from the correspongding object.
  * default to false
* `enumerable`
  * true if and only if this property shows up during enumeration of the properties on the correspongding object.
  * default to false

**A data descriptor** also has the following optional keys:

* `value`
  * default to false
  * the value associated with the property. can be any valid JavaScript value (number, object, function, etc)

* `writable`
  * default to false
  * true if the value associated with the property may be changed with an <u>assignment operator(赋值运算符)</u>.

**A accessor descriptor** also has the following optional keys:

* `get`
  * A function which serves as a getter for the property, or undefined if there is no getter.
  * when the property is accessed, this function is called without arguments and with this set to the object through which the property is accessed(this may not be the object on which the property is defined due to inheritance). the return value will be used as the value of the property.(这个长句不明白. 当访问该属性时, 会调用这个函数,没有参数,但会传入this对象(由于继承关系,this并不一定是该属性的对象). 返回值会被用作属性的值.
  * default to undefined
* `set`
  * A function which serves as a setter for the property, or undefined if there is no setter.
  * when the property is assigned, this function is called with one argument(the value being assigned to the property) and with this set to the object through which the property is assigned.
  * default to undefined

If a descriptor has <u>neither of</u> `value` ,`writable`, `get` and `set` keys, ti is treated as a data descriptor. If a descriptor has both [`value` or `writable`] and [`get` or `set` ]keys, an exception is thrown.

Bear in mind that these attributes <u>are not necessarily(不一定是)</u> the descriptor's own properties. Inherited properties will be considered as well. In order to ensure these defaults are preserved, you might freeze the `Object` upfront, specify all options explicityly, or point to null with `Object.create(null)`. 



**修改属性**

Writable属性

当writable属性设为false时,该属性被称为'不可写的'. 它不能被重新赋值.

```javascript
let o = {};
Object.defineProperty(o, 'a', {
  value: 37,
  writable: false
});

console.log(o.a); //37
o.a = 25; //No error thrown(it would throw in strict mode, even if the value had been the same)
console.log(o.a); //37


//strict mode
(function() {
  'use strict'
  let o = {};
  Object.defineProperty(o, 'a', {
    value: 3,
    writable: false
  });
  
  o.a = 3; //throws TypeError: 'b' is read-only
  return o.b;
})();
```



Enumerable属性

`enumerable`定义了对象的属性是否可以在`for...in`循环和`Object.keys()`中被枚举.

```javascript
```



Configurable属性

`configurable`特性标识对象的属性是否可以被删除,以及除`value`和`writable`特性外的其他特性是否可以被修改.



添加多个属性和默认值

使用点运算符和 `Object.defineProperty()` 为对象的属性赋值时，数据描述符中的属性默认值是不同的

```javascript
let o = {};
o.a = 1;
//等同于
Object.defineProperty(o, 'a', {
  value: 1,
  writable: true,
  configurable: true,
  enumerable: true
})


Object.defineProperty(o, 'a', {value: 1});
//等同于
Object.defineProperty(o, 'a', {
  value: 1,
  writable: false,
  configurable: false,
  enumerable: false
})
```



继承属性

如果访问者的属性是被继承的，它的 `get` 和 `set` 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。

```javascript
function myclass() {}

let value;
Object.defineProperty(myclass.prototype, 'x', {
  get() {
    return value;
  },
  set(x) {
    value = x;
  }
})
let a = new myclass();
let b = new myclass();

a.x = 1;
console.log(b.x); //1
```

可以通过将值存储在另一个属性中解决.在get和set方法中,this指向某个被访问和修改属性的对象.

```javascript
function myclass() {}

Object.defineProperty(myclass.prototype, 'x', {
  get() {
    return this.stored_x;
  },
  set(x) {
    this.stored_x = x;
  }
});

let a = new myclass();
let b = new myclass();

a.x = 1;
console.log(b.x);//undefined
```

不像访问者属性,值属性始终在对象自身上设置,而不是一个原型.然而,如果一个不可写的属性被继承,它仍然可以防止修改对象的属性.

```javascript
function myclass() {}

myclass.prototype.x = 1;
Object.defineProperty(myclass.prototype, 'y', {
  writable: false,
  value: 1
});

let a = new myclass();
a.x = 2;
console.log(a.x); // 2
console.log(myclass.prototype.x); // 1
a.y = 2; // Ignored, throws in strict mode
console.log(a.y); // 1
console.log(myclass.prototype.y); // 1

```



**实例**

> https://juejin.cn/post/6950664413317693470

使用defineProperty实现`a==1&&b==2&&c==3`为true

```javascript
var val = 0;
Object.defineProperty(window, 'a', {
  get() {
    return ++val;
  }
});
console.log(....); //true
```













#### Object.defineProperties()

**define**

> the method defines new or modifies existing properties directly on an object, returning the object.

**syntax**

> Object.defineProperties(obj, props);

`obj` 

* the object on which to define or modify properties

`props` 

> An Object whose keys represent the names of properties to be defined or modified and whose values are objects describing those properties. Each value in 'props' must be either a data descriptor or an accessor descriptor; it cannot be both.

Data descriptors and access descriptors may <u>optionally</u> contain the following keys:

`configurable`

* true <u>if and only if</u> (当且仅当) the type of this property descriptor may be changed <u>and if</u>(并且) the proeprty may be deleted from the corresponding object.  

* Default to false.

`enumerable`

* true if and only if this property shows up during enumeration of the properties on the corresponding object.
* default to false

A data descriptor also has the following <u>optional</u> keys:

`value`

* the value associated with the property. Can be any valid JavaScript value(number, object,function,etc).
* default to undefined

`writable`

* true if and only if the value associated with the property may be changed with an [<u>assignment operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#assignment_operators)</u>(赋值运算符).
* default to false

An access descriptor also has the following <u>optional</u> keys:

`get`

* A function which <u>serves as(作为)</u> a getter for the property, or undefined if there is no getter.
* the function's return value will be used as the value of the property.
* default to undefined

`set`

* A function which serves as a setter for the property, or undefined if there is no setter.
* the function will receive as ites only argument the new value being assigned to the property
* default to undefined

If a descriptor has neither of `value`, `writable`, `get` and `set` keys, it is treated as a data descriptor.

If a descriptor has both `value` or `writable` and `get` or `set` keys, an exception is thrown.

**return value**

the object that was passed to the function

**Example**

Using Object.defineProperties

```javascript
let obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'hello',
    writabel: false
  }
})
```





#### Object.hasOwn():pencil2:

##### Define

> the static method return `true` if the specified object has the indicated property as its own property. If the property is inherited, or does not exist, the method returns `false`
>
> Note: `Object.hasOwn()` is intended as a replacement for `Object.hasOwnProperty()`

##### **Syntax**

> Object.hasOwn(instance, prop);

##### **Parameters**

`instance`

* the JavaScript object instace to test.

`prop`

* the `String` name or `Symbol` of the property to test.

##### **Desc**

* the `Object.hasOwn()` method returns `true` if the specified property is a direct property of the object -even if the property values is `null` or `undefined`.
* the method returns `false` if the property is inherited, <u>or has not been declared at all.</u>  ????
* Unlike the `in` operator, this method <u>does not check for the specified property in the object's prototype chain.</u>
* It is recommended over `Object.hasOwnProperty()` because it works for objects created using `Object.create(null)` and with objects that have overridden the inherited `hasOwnProperty()` method.
* While it is possible to workaround these problems by calling `Object.prototype.hasOwnProperty()` on an external object, `Object.hasOwn()` is more intuitive(直观的).

##### **example**

<u>Using hasOwn to test for a property's existence</u>

> The following code shows how to determine whether the `example` oject contains a proeprty named `prop`

```javascript
let example = {};
Object.hasOwn(example, 'prop');   // false = 'prop' has not been defined

example.prop = 'exists';
Object.hasOwn(example, 'prop');   // true - 'prop' has been defined

example.prop = null;
Object.hasOwn(example, 'prop');   // true - own property exists with value of null

example.prop = undefined;
Object.hasOwn(example, 'prop');   // true - own property exists with value of undefined
example.hasOwnProperty('prop')
```





<u>Direct  vs. inherited properties</u>

> the following example differentiates between direct properties and properties inherited through the prototype chain.

```javascript
let example = {}
example.prop = 'exists';

// `hasOwn` will only return true for direct properties:
Object.hasOwn(example, 'prop');             // returns true
Object.hasOwn(example, 'toString');         // returns false
Object.hasOwn(example, 'hasOwnProperty');   // returns false

// The `in` operator will return true for direct or inherited properties:
'prop' in example;                          // returns true
'toString' in example;                      // returns true
'hasOwnProperty' in example;                // returns true
```





<u>Iterating over the properties of an object</u>

> To iterate over the enumerable properties of an object, 

```javascript
let example = { foo: true, bar: true };
for (let name of Object.keys(example)) {
  // ...
}
```

but if you need to use `for...in`, u can use `Object.hasOwn()` to skip the inherited properties:

```javascript
let example = { foo: true, bar: true };
for (let name in example) {
  if (Object.hasOwn(example, name)) {
    // ...
  }
}
```





<u>Checking if an Array index exists</u>

> the elements of an `Array` are defined as direct properties, so you can use `hasOwn()` method to check whether a particular index exists

```javascript
let fruits = ['Apple', 'Banana','Watermelon', 'Orange'];
Object.hasOwn(fruits, 3);   // true ('Orange')
Object.hasOwn(fruits, 4);   // false - not defined
```



<u>Problematic cases for hasOwnProperty</u>

> the section demonstrate that `hasOwn()` is immune to the problems that affect `hasOwnProperty`.
>
> Firstly, it can be used with objects that have reimplemented `hasOwnProperty()`

```javascript
let foo = {
  hasOwnProperty: function() {
    return false;
  },
  bar: 'xxx'
};

if (Object.hasOwn(foo, 'bar')) {
  console.log(foo.bar); //
}
```

It can also be used to test objects created using `Object.create(null)`. These do not inherit from `Object.prototype`, and so `hasOwnProperty()` is inaccessible.

```javascript
let foo = Object.create(null);
foo.prop = 'exists';

if (Object.hasOwn(foo, 'prop')) {
  console.log(foo.prop);
}
```



#### Object.prototype.toString()

**Syntax**

```javascript
toString()
```



**Return value**

A string representing the object

**Desc**

An object's toString() method is most commonly invoked when that object undergoes...

* explicit(明确的) [type conversion](https://developer.mozilla.org/en-US/docs/Glossary/Type_Conversion) to a string(for example, String(myObject))
* implicit(含蓄的)  [type coercion](https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion) into a string(for example, myObject + 'hello world')

> Note: This assumes the object does not have a custom implementation of <span style="color:red;">**`Symbol.toPrimitive`**</span>. If it does, that method will take priority and be called instaed of `toString()`

While not as common, the method can be invoked directly(for example, myObject.toString())

By default toString() returns "[object Type]", where Type is the object type.

```javascript
const o = new Object().toString(); //o is "[object Object]"

//Symbol.toPrimitive
let obj = {
  toString() {return 1},
  [Symbol.toPrimitive]() {return 2}
};
obj + '1' //'21'
String(obj); //'2'
```

This method is inherited by every object descended from Object, but can be overridden by either the author or built-in descendant objects (for example, `Number.prototype.toString()`)



**Parameters**

* Be default `toString()` takes no parameters.
* however,objects that inherit from `Object` may override it with their own implementation that do take parameters. For example, the `toString()` methods implemented by `Number` and `BigInt` take an optional `radix`  parameter.

**Examples**

<u>Overriding the default toString method.</u>

* the `toString()` function you create must return a primitive.
* If it returns an object and the method is called implicitly<sup>含蓄的暗中的</sup>(i.e. during type conversion or coercion), then its result will be ignored 
  * and the value of a related method  <span style="color: red;"> **`valueOf()`**</span>, will be used instead, 
  * or a `TypeError` will be thrown if none of these methods return a primitive.

```javascript
//varify the upside conclusion
let obj = {
  toString() {return {} },
  valueOf() {return 1}
};
String(obj); //'1'
obj + 'a'; //'1a'
```



<u>Using toString() to detect object class</u>

`toString()` can be used with every object and (by default) allows you to get its class.

* To use the base `Object.prototype.toString()` with an object that has had it overridden, you need to call [`Function.prototype.call()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call) or [`Function.prototype.apply()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) on it, passing the object you want to inspect as the first parameter (called `thisArg`).

```javascript
const toString = Object.prototype.toString;

toString.call(new Date); //[object Date]
toString.call(new String); //[object String]
toString.call(Math); //[object Math]

//since JavaScript 1.8.5
toString.call(undefined) //[object Undefined]
toString.call(null); //[object Null]
```



* Using `toString()` in this way is unreliable; objects can change the behavior of `Object.prototype.toString()`by defining a <span style="color: red;">**`Symbol.toStringTag`** </span>property, leading to unexpected results.

```javascript
const myDate = new Date();
Object.prototype.toString.call(myDate); //[object Date]

myDate[Symbol.toSTringTag] = 'myDate';
Object.prototype.toString.call(myDate); //[object myDate]

Date.prototype[Symbol.toStringTag] = 'prototype polluted';
Object.prototype.toString.call(new Date()); //[object prototype polluted]
```



**应用**

使用toString方法实现`a==1&&a==2&&a==3`结果为true

> https://juejin.cn/post/6950664413317693470
>
> 还有数组,Object.defineProperty方法

```javascript
let a = {
  i: 1,
  toString() {
    return a.i;
  }
}

a==1&&a==2&&a==3
//true
```





#### ES2022-Object.hasOwn()




#### Object.is

```js
- 判断两个值是否完全相等
- 和'==='相似,但是在NaN比较上不一致.
Object.is(a, b); //判断a与b是否全等
Object.is(NaN, NaN); //true
console.log(NaN === NaN); //false
Object.is(100, '100'); //false

```



#### Object.assign

> 于将所有==可枚举属性的值==从一个或多个源对象分配到目标对象。它将返回目标对象。

```js
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
- 对象的合并, 应用场景:配置对象的合并

- 语法:
Object.assign(proto, [, propertiesObject]); 
 - 参数:proto:必须.表示新建对象的原型对象,即该参数会被赋值到目标对象(即新对象,或说是最后返回的对象)的原型上.该参数可以是null(创建空的对象时需传入null),对象,函数的prototype属性. 否则会抛出TypeError错误.
 - prototiesObject:可选.该参数对象是一组属性与值//[,] mdn上的语法,表示可选参数
该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与 Object.defineProperties() 的第二个参数一样）。这些属性是新对象自身的属性，而不是新对象原型链上的属性。

- 案例:
let obj={a:1, b:2};
let obj2={c:3, d:4, a:100}; //属性相同,后面的覆盖前面的
const result = Object.assign(obj, obj2);
console.log(result); //{a: 100, b: 2, c: 3, d: 4}
console.log(obj);// {a: 100, b: 2, c: 3, d: 4}
console.log(result === obj);//true


Object.assign方法只会拷贝源对象自身的并且可枚举(数组,对象等)的属性到目标对象.
修改属性和属性值为变量和字符串-,新对象会跟着改变.

继承属性和不可枚举属性是不能拷贝的
const obj=Object.create({foo:1},{//foo是个继承属性
    bar:{
        value:2 //bar是不可枚举属性
    },
    baz:{
        value:3,
        enumerable:true //baz是个自身可枚举属性
    }
})

const copy=Object.assign({}, obj);
console.log(copy);//{baz:3}

```



#### 直接修改\_\_proto\_\_设置原型

```js
let obj={a:1, b:2};
let obj2={c:3, d:4, a:100};

obj.__proto__ = obj2;
console.log(obj);//打印显示obj__proto__的obj2
```

