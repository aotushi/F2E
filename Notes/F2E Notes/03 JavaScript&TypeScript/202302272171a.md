---
aliases: sort, Array.prototype.sort
---

### Array.prototype.sort


**定义**

`sort()`方法用[原地算法](https://en.wikipedia.org/wiki/In-place_algorithm)对数组的元素进行排序，并返回数组的引用。默认排序是升序, 创建在转换元素为字符串,并比较它们UTF-16代码单元值序列的基础上.

可以用来对一个数组进行排序,它是一个**破坏性的方法**..调用后,原数组的顺序就会被改变.

可以通过传递一个 回调函数 来自定义排序规则

**参数**

```javascript
arr.sort([compareFunction])
```

`compareFunction` 可选

* 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的<u>Unicode位点</u>进行排序。([字符编码笔记:ASCII, Unicode和UTF-8](https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html))
* `firstEl` 第一个用于比较的元素。
* `secondEl` 第二个用于比较的元素

**返回值**

排序后的数组。请注意，数组已原地排序，并且不进行复制。

**描述**

* 如果没有指明`compareFn`, 那么元素会按照转换为字符串的诸个字符的Unicode位点进行排序.
  * 例如: 'Banana'排在'cherry'之前. 数字9排在80之后.
  
* 所有`Undefined`元素会被排在数组的末尾
  
* 如果指明了 `compareFunction` ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素(所有`undefined`元素被排在数组末尾, 没有调用`compareFn`)

| `compareFn(a, b)` return value | sort order      |
| ------------------------------ | --------------- |
| > 0                            | `a` 在 `b` 之后 |
| < 0                            | `a` 在 `b`之前  |
| === 0                          | 保持原来的顺序  |



```javascript
//比较函数格式:
function compare(a, b) {
  if (a < b ) {           // 按某种排序标准进行比较, a 小于 b
    return -1;
  }
  if (a > b ) {
    return 1;
  }
  // a must be equal to b
  return 0;
}
```

要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列(如果不包含`Infinity`和`NaN`.



```javascript
- 如果希望 升序 排列(从小到大),传:
function(a, b){
  return a - b;  //记忆方法: 26个字符从a到z是从小到大, a - b理解为从小到大,是升序. b -a是从大到小
}

- 如果希望降序排列(从大到小),传:
function(a, b){
  return b - a;
}

- 乱序排列
function(a, b){ //参数a与b写不写都一样了
  return Math.random() - Math.random
}
() => Math.random() - 0.5;

//没有传递参数的写法
[1,3,2,5,4].sort(() => -1); //[4, 5, 2, 3, 1]
[1,3,2,5,4].sort(() => 1); //[1,3,2,5,4]
[1,3,2,5,4].sort(() => 0); //[1,3,2,5,4]
```





**为什么升序是a - b????**  

```javascript
//https://blog.csdn.net/weixin_42207975/article/details/107538527
// 是结果推原因, 怎么说呢, 总是记不住.
let arr = [1, 22, 15, 32, 4, 5];
arr.sort((a, b) => a - b); //升序排列 [1, 4, 5, 15, 22, 32]
arr.sort((a, b) => b - a); //降序排列 [...]

```

回调函数的格式为（a,b）=> { return xxx }，ab为数组中任意两个数:

* 当返回值大于0, a放在b的后面
* 当返回值小于0, a放在b的前面
* 当返回值等于0, 位置不变

```javascript
当 a>b 时，

a - b > 0  ，排序结果 ===> b，a （升序）

b - a < 0  ，排序结果 ===> a，b （降序）

当 b>a 时，

a - b < 0  ，排序结果 ===> a，b （升序）

b - a > 0  ，排序结果 ===> b，a （降序）

当 a=b 时，

a - b = b - a =0 , 排序结果 ===> 保持不变
```

`结论`: 无论a>b还是b>a，return a-b 总能得到升序的结果，而 return b-a 总能得到降序的结果. 另外，return a-b / return b - a 只是一种在理解的基础上简便的写法。复杂的写法就是使用上面的'比较函数的格式'.



**重写**

> https://juejin.cn/post/6844903986479251464#heading-33    本篇文章重要 精读  看不懂

```javascript
//插入排序 v1.0
const insertSort = (arr, start=0, end) => {
  end = end || arr.length;
  for (let i=start; i<end; i++) {
    for (let j=i; j>start&&arr[j-1]>arr[j]; j--) {
      let temp = arr[j];
      arr[j] = arr[j-1];
      arr[j-1] = temp;
    }
  }
  return arr;
}

//插入排序v2.0 优化插入
//实际上交换元素会有相当大的性能消耗，我们完全可以用变量覆盖的方式来完成   ???? 这个我不明白
const insertSort = (arr, start = 0, end) => {
  end = end || arr.length;
  for (let i=start; i<arr.length; i++) {
    let e = arr[i];
    let j;
    for (j=i; j>start&&arr[j-1]>e; j--) {
      arr[j-1] = arr[j];
    }
    arr[j] = e;
  }
  return arr;
}


//
```



实现数组的sort方法  看不懂????

> [(建议精读)原生JS灵魂之问(中)，检验自己是否真的熟悉JavaScript？ - 掘金 (juejin.cn)](https://juejin.cn/post/6844903986479251464#heading-33)

**实例**

使用映射改善排序 !!!!

> `compareFunction` 可能需要对元素做多次映射以实现排序，尤其当 `compareFunction` 较为复杂，且元素较多的时候，某些 `compareFunction` 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。

```js
let arr = ['Delta', 'alpha', 'CHARLIE', 'bravo'];
// 对需要排序的数字和位置的临时存储
let mappedObj = arr.map((item,index)=>{
  return {index:index,value:item.toLowerCase()};
})
// 按照多个值排序数组
mappedObj.sort((a,b)=>{
  return +(a.value>b.value)||+(a.value===b.value)-1;
})
// 根据索引得到排序的结果
let result = mappedObj.map((item)=>{
  return list[item.index]
})
```

排序稳定性

> 自 ES10（EcmaScript 2019）起，[规范](https://tc39.es/ecma262/#sec-array.prototype.sort) 要求 `Array.prototype.sort` 为稳定排序。

也就是说,当有相同排序条件时,按排序之前的位置来排序

```javascript
const students = [
  { name: "Alex",   grade: 15 },
  { name: "Devlin", grade: 15 },
  { name: "Eagle",  grade: 13 },
  { name: "Sam",    grade: 14 },
];


students.sort((firstItem, secondItem) => firstItem.grade - secondItem.grade);

[
  { name: "Eagle",  grade: 13 },
  { name: "Sam",    grade: 14 },
  { name: "Alex",   grade: 15 }, // grade 相同时维持原先的顺序 (稳定排序)
  { name: "Devlin", grade: 15 }, // grade 相同时维持原先的顺序 (稳定排序)
];
```



数组乱序

```javascript
const shuffleArr = arr => arr.sort(() => Math.random() - 0.5)
```



// todo  20220928

https://juejin.cn/post/6971747560784560165

**sort接口代码实现**

> [数组的 sort() 方法详解 - 掘金 (juejin.cn)](https://juejin.cn/post/6971747560784560165)
>
> [v8/array.js at ad82a40509c5b5b4680d4299c8f08d6c6d31af3c · v8/v8 (github.com)](https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js)

 [array.js](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fv8%2Fv8%2Fblob%2Fad82a40509c5b5b4680d4299c8f08d6c6d31af3c%2Fsrc%2Fjs%2Farray.js) 文件下，关于 sort 接口实现的代码如下：

```js
function InnerArraySort(array, length, comparefn) {
  // In-place QuickSort algorithm
  // For short (length <= 22) arrays, insertion sort is used for efficiency.
  
  if (!IS_CALLABLE(comparefn)) {
    comparefn = function (x, y) {
      if (x === y) return 0;
      if (% _IsSmi(x) && % _IsSmi(y)) {
        return % SmiLexicographicCompare(x, y);
      }
      //将数组元素转换为字符串
      x = TO_STRING(x);
      y = TO_STRING(y);
      if (x === y) return 0;
      else return x < y ? -1 : 1;
    };
  }
  var InsertionSort = function InsertionSort(a, from, to) {
    for (var i = from + 1; i < to; i++) {
      var element = a[i];
      for (var j = i - 1; j >= from; j--) {
        var tmp = a[j];
        //调用比较函数 a: tmp, b:element
        var order = comparefn(tmp, element);
        if (order > 0) {
          a[j + 1] = tmp;
        } else {
          break;
        }
      }
      a[j + 1] = element;
    }
  };

  var QuickSort = function QuickSort(a, from, to) {
    //some code here
  }
}

function ArraySort(comparefn) {
  CHECK_OBJECT_COERCIBLE(this, "Array.prototype.sort");

  var array = TO_OBJECT(this);
  var length = TO_LENGTH(array.length);
  return InnerArraySort(array, length, comparefn)
}
```

代码分析：

1. v8 中实现 sort() 方法时，采用了 ”**插入排序**“ 和 ”**快速排序**“ 两种排序方式。
2. 对于短数组（长度 <= 22）来说，插入排序效率更高。
3. 如果没有传入 `comparefn` ，则生成一个 `comparefn` 比较函数。
4. 在自动生成的比较函数中，会将传入的数组元素通过 `TO_STRING` 方法转换为字符串，再行比较。
5. 对比比较函数中的 b 为游标值，这一点和最新版的 chrome 浏览器表现不同。

我们在 sort 方法中传入的函数用在了这里：

```javascript
var order = comparefn(tmp, element);
```

根据我们传入函数的返回值，数组进行排序操作：

```javascript
if (order > 0) {
    a[j + 1] = tmp;
} else {
    break;
}
```

- 如果返回值`（a-b）`大于0，即 `a > b`, 则将当前拿来比较的值 a 复制给它的下一位，并继续使用游标值 b 向前进行比较。
- 如果返回值小于等于 0 ，则结束比较，并将游标值 b 填在最后一次比较值 a 的后面。

比较函数如果写完全的话，应该是：

```javascript
arr.sort((a,b) => {
    const res = a - b;
    return res > 0 ? 1 : (res < 0 ? -1 : 0 );
});
```

即比较函数的返回值严格来说只有三个：-1、0 和 1 。

